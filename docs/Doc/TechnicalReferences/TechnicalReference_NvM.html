---
layout: default
title: TechnicalReference_NvM
nav_order: 39
parent: Doc
---
{% raw %}
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
     "http://www.w3.org/TR/html4/transitional.dtd">
<html>
<head>

  <meta http-equiv="content-type" content="text/html; charset=utf-8"/>
  <title></title>
  <meta name="generator" content="LibreOffice 24.2.7.2 (Linux)"/>
  <meta name="created" content="00:00:00"/>
  <meta name="changed" content="00:00:00"/>
</head>
<body>
<h1></h1>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p><b>MICROSAR NVM </b></p>
<p>Technical Reference </p>
<p> </p>
<p>  </p>
<p>Version 5.07.01 </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>Authors </p>
<p>Christian Kaiser, Tomas Ondrovic </p>
<p>Status </p>
<p>Released </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 5.07.01 </p>
<p>2 </p>
<p>based on template version 3.01 </p>
<p><b>1 </b></p>
<p><b>Document Information </b></p>
<p><b>1.1 </b></p>
<p><b>History </b></p>
<p><b>Author </b></p>
<p><b>Date </b></p>
<p><b>Version </b></p>
<p><b>Remarks </b></p>
<p>Christian Kaiser </p>
<p>2007-08-20 </p>
<p>1.4 </p>
<p>AUTOSAR 2.1, </p>
<p>updated for EAD3.1 usage, </p>
<p>conversion to new template   </p>
<p>Christian Kaiser </p>
<p>2007-12-06 </p>
<p>3.01.00 </p>
<p>Change of the document's versioning </p>
<p>scheme to correspond to the module's </p>
<p>major and minor, </p>
<p>update of parameter description in </p>
<p>chapter 'Graphical Configuration of NvM' </p>
<p>and service port generation description, </p>
<p>remove of DATASET ROM, feature not </p>
<p>supported anymore, </p>
<p>remove of introduction paragraphs from </p>
<p>'Description of Memory Mapping and </p>
<p>Compiler Abstraction', not subject of this </p>
<p>document, </p>
<p>simplified 'Block Management Types' </p>
<p>naming, </p>
<p>formal changes    </p>
<p>Christian Kaiser </p>
<p>2008-01-11 </p>
<p>3.01.01 </p>
<p>New chapter to clarify the dependency on </p>
<p>the CRC library, </p>
<p>stated explicitly that DET is optional, </p>
<p>corrected default values   </p>
<p>Manfred Duschinger, </p>
<p>Heike Bischof </p>
<p>2008-05-23 </p>
<p>3.02.00 </p>
<p>AUTOSAR 3, </p>
<p>conversion to Technical Reference </p>
<p>Manfred Duschinger </p>
<p>2008-12-08 </p>
<p>3.03.00 </p>
<p>ESCAN00027300: Description of </p>
<p>NvM_ServiceIdType </p>
<p>in </p>
<p>SingleBlockCallbackFunction and </p>
<p>MultiBlockCallbackFunction </p>
<p>Description and expected caller context </p>
<p>of </p>
<p>NvM_SetBlockLockStatus</p>
<p>-API </p>
<p>reworked. </p>
<p>Chapter 4.4.17 ‘Concurrent access to NV </p>
<p>data for DCM’ added. </p>
<p>Chapter 4.4.5.2: Write order at redundant </p>
<p>blocks added. </p>
<p>Expansion of glossary. </p>
<p>Chapter 7.2.2: Description of ‘Dataset </p>
<p>Selection Bits’ added. </p>
<p>Manfred Duschinger </p>
<p>2009-02-25 </p>
<p>3.03.01 </p>
<p>ESCAN00031177: Manufacturer specific </p>
<p>requirements attribute for traceability </p>
<p>reasons </p>
<p>Manfred Duschinger </p>
<p>2009-03-24 </p>
<p>3.03.02 </p>
<p>ESCAN00032480: Missing information in </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 5.07.01 </p>
<p>3 </p>
<p>based on template version 3.01 </p>
<p>documentation: </p>
<p>Chapter 6.4.5: ‘Description of </p>
<p>NvM_RequestResultType added’. </p>
<p>Chapters 6.4.15 and 6.4.16: ‘Services are </p>
<p>multiblock requests’. </p>
<p>Manfred Duschinger </p>
<p>2009-06-03 </p>
<p>3.04.00 </p>
<p>ESCAN00032480: Update of History of </p>
<p>version 3.03.02: Updated changed </p>
<p>chapters.  </p>
<p>Chapter  6.2: ‘Block ID 0 is only allowed </p>
<p>for API NvM_GetErrorStatus()’ </p>
<p>ESCAN00033075: Chapter 4.5.1.1: </p>
<p>DataIndex Check in NvM_ReadBlock() </p>
<p>added. DataIndex Check was also added </p>
<p>to NvM_InvalidateNvBlock() and </p>
<p>NvM_EraseNvBlock(). </p>
<p>ESCAN00033900: Chapter 4.4.17: </p>
<p>“Priority Handling of DCM-Blocks” </p>
<p>ESCAN00035089: Chapters 4.1, 7.2.2 </p>
<p>“Callbacks NvM_JobEndNotification, </p>
<p>NvM_JobErrorNotification implemented” </p>
<p>ESCAN00034073: Chapters 2, 4.4.5.1, </p>
<p>7.2.2 “Crc Handling is configurable: Either </p>
<p>an internal buffer is used or Crc is stored </p>
<p>at the end of RAM Block.” </p>
<p>ESCAN00035891: Chapter 7.1.1 </p>
<p>“Integrate SWC-Generation into CFG </p>
<p>Pro's Generation process” </p>
<p>Chapter 3.1: update AUTOSAR </p>
<p>architecture figure. </p>
<p>Christian Kaiser </p>
<p>2010-01-25 </p>
<p>3.04.01 </p>
<p>ESCAN00039648 – Rebuilt document; </p>
<p>made hyperlinks working. Updated Logo; </p>
<p>No changes in content. </p>
<p>Christian Kaiser </p>
<p>2010-03-26 </p>
<p>3.05.00 </p>
<p>Updated Component history </p>
<p>Whole document: “EAD” </p>
<p></p>
<p> “DaVinci </p>
<p>Configurator” </p>
<p>Added Ch. 7.3 “Attributes only </p>
<p>configurable using GCE” </p>
<p>Updated Ch. 5.6.1 – “RAM Usage” </p>
<p>ESCAN00040662: Chapter 4.4.3: Added </p>
<p>note about restricted access to RAM </p>
<p>block during job execution. </p>
<p>ESCAN00035134: Chapter 5.1.2 </p>
<p>reworked </p>
<p>ESCAN00039749: Ch. 4.4.10, 8.2.4: </p>
<p>Guaranteed CRC values; Ch 6.4.7: note </p>
<p>about asynchronous CRC calculation </p>
<p>ESCAN00031315: added Ch. 4.2.1, Ch  </p>
<p>8.2.3; updated Ch. 7.2.5 </p>
<p>ESCAN00042745 – corrected Ch. 4.5.2 </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 5.07.01 </p>
<p>4 </p>
<p>based on template version 3.01 </p>
<p>Manfred Duschinger </p>
<p>2011-01-25 </p>
<p>3.07.00 </p>
<p>ESCAN00047171: Ch. 6.4.18: </p>
<p>NvM_KillWriteAll; Abbreviations: ECUM </p>
<p>ESCAN00045141: Ch. 4.4.5.1: </p>
<p>information about names of Block </p>
<p>Handles </p>
<p>Manuela Scheufele  </p>
<p>2011-02-03 </p>
<p>3.07.01 </p>
<p>Minor changes </p>
<p>Manfred Duschinger </p>
<p>2011-07-12 </p>
<p>3.08.00 </p>
<p>ESCAN00049327: Ch. 4.5.2 DEM errors </p>
<p>inserted into MICROSAR DEM </p>
<p>Christian Kaiser </p>
<p>2012-01-24 </p>
<p>3.09.00 </p>
<p>ESCAN00053235, ESCAN00051729: Ch. </p>
<p>7.1 – updated PortInterface names </p>
<p>Manfred Duschinger </p>
<p>2013-01-02 </p>
<p>5.00.00 </p>
<p>Ch. 4.1: supported features added </p>
<p>Ch. 4.4.3 and ch. 4.4.4: added </p>
<p>NvM_CancelJobs </p>
<p>Ch. 4.3.5: error handling updated </p>
<p>Ch. 4.4.20: added explicit synchronization </p>
<p>mechanism </p>
<p>Ch. 5.4.6: updated callback functions </p>
<p>Ch. 5.5: updated initialization process of </p>
<p>memory stack </p>
<p>Ch. 6.4: updated return values of most </p>
<p>synchronous APIs </p>
<p>Ch. 6.4.6: instanceID deleted </p>
<p>Ch. 6.4.16: updated NvM_WriteAll </p>
<p>handling </p>
<p>Ch. 6.4.19: description of API </p>
<p>NvM_CancelJobs </p>
<p>Ch. 6.7.4 and 6.7.5: Callback routines for </p>
<p>explicit synchronization mechanism </p>
<p>Ch. 7: completely reworked </p>
<p>Ch. 9.2: added abbreviations </p>
<p>Ch. 7.2.1 and ch. 7.3 removed </p>
<p>Manfred Duschinger </p>
<p>2013-01-04 </p>
<p>5.01.00 </p>
<p>Ch. 5.4.8 Interaction with BswM </p>
<p> </p>
<p>Manfred Duschinger, </p>
<p>Christian Kaiser </p>
<p>2013-08-23 </p>
<p>5.01.01 </p>
<p>ESCAN00064110: Ch. 4.4.8 Description </p>
<p>of synchronous Job-End Notification </p>
<p>ESCAN00062895: Ch. 4.4.5.1 Symbolic </p>
<p>name values of Nv Block Handles </p>
<p>updated. </p>
<p>ESCAN00062896: Ch. 4.4.13. 4.4.20, </p>
<p>5.4.8, 6.7.3, 6.7.4 and 6.7.5: Added </p>
<p>information that block is still busy during </p>
<p>invoking callback. </p>
<p>ESCAN00063639: Ch. 4.4.20: Extended </p>
<p>information about explicit synchronization </p>
<p>mechanism </p>
<p>ESCAN00064063: Ch. 6.2 Improve </p>
<p>description of </p>
<p>NvM_RequestResultType </p>
<p>ESCAN00064173: Ch. 5.3: Explanation </p>
<p>of some necessity of memory mapping </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 5.07.01 </p>
<p>5 </p>
<p>based on template version 3.01 </p>
<p>ESCAN00068239: Ch. 6.4, Ch. 4.4.20: </p>
<p>Limitations Explicit Synchronization </p>
<p>Mechanism </p>
<p>ESCAN00063532 – Ch. 6.4.16 Block </p>
<p>Processing order during NvM_WriteAll </p>
<p>Christian Kaiser </p>
<p>2014-06-17 </p>
<p>5.02.00 </p>
<p>Internal release; no changes </p>
<p>Christian Kaiser </p>
<p>2014-10-13 </p>
<p>5.02.01 </p>
<p>Updated Ch. 2. Component history. </p>
<p>ESCAN00073178 </p>
<p>– </p>
<p>updated </p>
<p>Ch. </p>
<p>4.1 </p>
<p>unsupported features, Ch. 8.1 Deviations </p>
<p>ESCAN00074672 </p>
<p>– </p>
<p>Description </p>
<p>of </p>
<p>Redundant Blocks; extended Ch. 4.4.5.2 </p>
<p>ESCAN00076366 </p>
<p>– </p>
<p>SWCs’ </p>
<p>callback </p>
<p>return types – added Ch. 7.1.5 </p>
<p>Removed Ch. 4.4.18, 4.4.19 </p>
<p>ESCAN00071933 </p>
<p>– </p>
<p>Description </p>
<p>of </p>
<p>internal </p>
<p>buffering </p>
<p>and </p>
<p>internal </p>
<p>CRC </p>
<p>storage,  rewording  Ch.  4.4.5.1,  4.4.5.5, </p>
<p>4.4.10, 5.6.1 </p>
<p>ESCAN00075284 </p>
<p>– </p>
<p>Reworked </p>
<p>Ch. </p>
<p>4.4.17, Ch. 6.4.8 </p>
<p>Review </p>
<p>findings </p>
<p>– </p>
<p>Development </p>
<p>Error </p>
<p>Codes in chapter 4.5.1, minor rephrasing, </p>
<p>Glossary (PIM) </p>
<p>Added Chapter 5.7 </p>
<p>Christian Kaiser </p>
<p>2015-01-07 </p>
<p>5.02.02 </p>
<p>Chapters 6.4.8, 8.1 </p>
<p>NvM_SetBlockLockStatus – emphasized </p>
<p>deviation from AUTOSAR. </p>
<p>Tomas Ondrovic </p>
<p>2015-02-02 </p>
<p>5.03.00 </p>
<p>Chapter 4.2.1, 4.5.1 – removed RAM and </p>
<p>ROM block length DET check </p>
<p>Chapter 4.5.3 – describes the new </p>
<p>compile time RAM and ROM block length </p>
<p>checks </p>
<p>Chapter 4.1.1.1– created to describe </p>
<p>feature Block Id check </p>
<p>Chapter 6.4.20 – describes the new </p>
<p>feature “Repair Redundant Blocks” </p>
<p>Tomas Ondrovic </p>
<p>2015-09-28 </p>
<p>5.03.01 </p>
<p>Only improvements </p>
<p>Tomas Ondrovic </p>
<p>2015-11-25 </p>
<p>5.0400 </p>
<p>Added chapter 4.1.2 and updated chapter </p>
<p>4.5.3 </p>
<p>Tomas Ondrovic </p>
<p>2016-02-11 </p>
<p>5.05.00 </p>
<p>Removed the possibility to configure dev </p>
<p>error hook, include file and reporting </p>
<p>Tomas Ondrovic </p>
<p>2016-04-14 </p>
<p>5.06.00 </p>
<p>ESCAN00088791: updated function </p>
<p>signatures to AUTOSAR4 in chapter 6.4 </p>
<p>FEAT-1888: described changed callback </p>
<p>invoking during ReadAll in chapters 4.4.8 </p>
<p>and 4.4.13 </p>
<p>Added new chapter 5.2 with critical </p>
<p>section list. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 5.07.01 </p>
<p>6 </p>
<p>based on template version 3.01 </p>
<p>ESCAN00091004: extended chapter 4.2 </p>
<p>Tomas Ondrovic </p>
<p>2016-10-18 </p>
<p>5.06.01 </p>
<p>ESCAN00073639: improved chapter </p>
<p>4.4.17 </p>
<p>Tomas Ondrovic </p>
<p>2017-02-23 </p>
<p>5.06.02 </p>
<p>ESCAN00094128: improved DEM error </p>
<p>handling description (chapter 4.5.2 and </p>
<p>5.5.2) </p>
<p>Tomas Ondrovic </p>
<p>2017-07-19 </p>
<p>5.07.00 </p>
<p>FEAT-2914: added 4.4.19 CRC Compare </p>
<p>Mechanism </p>
<p>Tomas Ondrovic </p>
<p>2018-05-16 </p>
<p>5.07.01 </p>
<p>ESCAN00098248: improved chapter </p>
<p>4.4.9 </p>
<p>Table 1-1  </p>
<p>History of the document </p>
<p><b>1.2 </b></p>
<p><b>Reference Documents </b></p>
<p><b>No. </b></p>
<p><b>Title </b></p>
<p><b>Version </b></p>
<p>[1] </p>
<p> </p>
<p>AUTOSAR_SWS_NVRAMManager.pdf </p>
<p>V 3.2.0 </p>
<p>[2] </p>
<p>A </p>
<p>AUTOSAR_SWS_NVRAMManager.pdf </p>
<p>V 4.2.2 </p>
<p>[3] </p>
<p> </p>
<p>AUTOSAR_SWS_DET.pdf </p>
<p>V 2.2.0 </p>
<p>[4] </p>
<p> </p>
<p>AUTOSAR_SWS_DEM.pdf </p>
<p>V 2.2.1 </p>
<p>[5] </p>
<p> </p>
<p>AUTOSAR_BasicSoftwareModules.pdf </p>
<p>V 1.2.0 </p>
<p>Table 1-2  </p>
<p>Reference documents </p>
<p> </p>
<p> </p>
<p><b>Please note </b></p>
<p>We have configured the programs in accordance with your specifications in the </p>
<p>questionnaire. Whereas the programs do support other configurations than the one </p>
<p>specified in your questionnaire, Vector´s release of the programs delivered to your </p>
<p>company is expressly restricted to the configuration you have specified in the </p>
<p>questionnaire. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 5.07.01 </p>
<p>7 </p>
<p>based on template version 3.01 </p>
<p><b>Contents </b></p>
<p><b>1</b></p>
<p> </p>
<p><b>Document Information ................................................................................................. 2</b></p>
<p> </p>
<p>1.1</p>
<p> </p>
<p>History ............................................................................................................... 2</p>
<p> </p>
<p>1.2</p>
<p> </p>
<p>Reference Documents ....................................................................................... 6</p>
<p> </p>
<p><b>2</b></p>
<p> </p>
<p><b>Component History .................................................................................................... 13</b></p>
<p> </p>
<p><b>3</b></p>
<p> </p>
<p><b>Introduction................................................................................................................. 15</b></p>
<p> </p>
<p>3.1</p>
<p> </p>
<p>Architecture Overview ...................................................................................... 16</p>
<p> </p>
<p><b>4</b></p>
<p> </p>
<p><b>Functional Description ............................................................................................... 18</b></p>
<p> </p>
<p>4.1</p>
<p> </p>
<p>Features .......................................................................................................... 18</p>
<p> </p>
<p>4.1.1</p>
<p> </p>
<p>Safety Features ................................................................................ 19</p>
<p> </p>
<p>4.1.2</p>
<p> </p>
<p>Automatic Block Length ................................................................... 19</p>
<p> </p>
<p>4.2</p>
<p> </p>
<p>Initialization ...................................................................................................... 20</p>
<p> </p>
<p>4.2.1</p>
<p> </p>
<p>Start-up ............................................................................................ 20</p>
<p> </p>
<p>4.2.2</p>
<p> </p>
<p>Initialization of the Data Blocks ........................................................ 20</p>
<p> </p>
<p>4.3</p>
<p> </p>
<p>States .............................................................................................................. 21</p>
<p> </p>
<p>4.4</p>
<p> </p>
<p>Main Functions ................................................................................................ 21</p>
<p> </p>
<p>4.4.1</p>
<p> </p>
<p>Hardware Independence .................................................................. 21</p>
<p> </p>
<p>4.4.2</p>
<p> </p>
<p>Synchronous Requests .................................................................... 21</p>
<p> </p>
<p>4.4.3</p>
<p> </p>
<p>Asynchronous Requests .................................................................. 22</p>
<p> </p>
<p>4.4.4</p>
<p> </p>
<p>API Configuration Classes and additional API Services ................... 22</p>
<p> </p>
<p>4.4.5</p>
<p> </p>
<p>Block Handling ................................................................................. 23</p>
<p> </p>
<p>4.4.6</p>
<p> </p>
<p>Prioritized or non-prioritized Queuing of asynchronous Requests .... 27</p>
<p> </p>
<p>4.4.7</p>
<p> </p>
<p>Asynchronous Job-End Polling ........................................................ 27</p>
<p> </p>
<p>4.4.8</p>
<p> </p>
<p>Single Block Job End Notifications ................................................... 27</p>
<p> </p>
<p>4.4.9</p>
<p> </p>
<p>Immediate Priority Jobs and cancellation of current Jobs ................. 28</p>
<p> </p>
<p>4.4.10</p>
<p> </p>
<p>Asynchronous CRC Calculation ....................................................... 28</p>
<p> </p>
<p>4.4.11</p>
<p> </p>
<p>Write Protection ............................................................................... 29</p>
<p> </p>
<p>4.4.12</p>
<p> </p>
<p>Erase and Invalidate ........................................................................ 29</p>
<p> </p>
<p>4.4.13</p>
<p> </p>
<p>Init Block Callbacks .......................................................................... 30</p>
<p> </p>
<p>4.4.14</p>
<p> </p>
<p>Define Locking/ Unlocking Services ................................................. 30</p>
<p> </p>
<p>4.4.15</p>
<p> </p>
<p>Interrupts .......................................................................................... 30</p>
<p> </p>
<p>4.4.16</p>
<p> </p>
<p>Data Corruption ................................................................................ 30</p>
<p> </p>
<p>4.4.17</p>
<p> </p>
<p>Concurrent access to NV data for DCM ........................................... 30</p>
<p> </p>
<p>4.4.18</p>
<p> </p>
<p>Explicit synchronization mechanism between application and NVM . 31</p>
<p> </p>
<p>4.4.19</p>
<p> </p>
<p>CRC Compare Mechanism .............................................................. 33</p>
<p> </p>
<p>4.5</p>
<p> </p>
<p>Error Handling .................................................................................................. 34</p>
<p> </p>
<p>4.5.1</p>
<p> </p>
<p>Development Error Reporting ........................................................... 34</p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 5.07.01 </p>
<p>8 </p>
<p>based on template version 3.01 </p>
<p>4.5.2</p>
<p> </p>
<p>Production Code Error Reporting ..................................................... 36</p>
<p> </p>
<p>4.5.3</p>
<p> </p>
<p>Compile-time Block Length Checks .................................................. 37</p>
<p> </p>
<p><b>5</b></p>
<p> </p>
<p><b>Integration ................................................................................................................... 38</b></p>
<p> </p>
<p>5.1</p>
<p> </p>
<p>Scope of Delivery ............................................................................................. 38</p>
<p> </p>
<p>5.1.1</p>
<p> </p>
<p>Static Files ....................................................................................... 38</p>
<p> </p>
<p>5.1.2</p>
<p> </p>
<p>Dynamic Files .................................................................................. 38</p>
<p> </p>
<p>5.2</p>
<p> </p>
<p>Critical Sections ............................................................................................... 39</p>
<p> </p>
<p>5.3</p>
<p> </p>
<p>Include Structure .............................................................................................. 39</p>
<p> </p>
<p>5.4</p>
<p> </p>
<p>Compiler Abstraction and Memory Mapping ..................................................... 39</p>
<p> </p>
<p>5.5</p>
<p> </p>
<p>Dependencies on SW Modules ........................................................................ 41</p>
<p> </p>
<p>5.5.1</p>
<p> </p>
<p>OSEK / AUTOSAR OS ..................................................................... 41</p>
<p> </p>
<p>5.5.2</p>
<p> </p>
<p>DEM ................................................................................................. 41</p>
<p> </p>
<p>5.5.3</p>
<p> </p>
<p>DET ................................................................................................. 42</p>
<p> </p>
<p>5.5.4</p>
<p> </p>
<p>MEMIF ............................................................................................. 42</p>
<p> </p>
<p>5.5.5</p>
<p> </p>
<p>CRC Library ..................................................................................... 42</p>
<p> </p>
<p>5.5.6</p>
<p> </p>
<p>Callback Functions ........................................................................... 42</p>
<p> </p>
<p>5.5.7</p>
<p> </p>
<p>RTE ................................................................................................. 42</p>
<p> </p>
<p>5.5.8</p>
<p> </p>
<p>BSWM.............................................................................................. 42</p>
<p> </p>
<p>5.6</p>
<p> </p>
<p>Integration Steps .............................................................................................. 43</p>
<p> </p>
<p>5.7</p>
<p> </p>
<p>Estimating Resource Consumption .................................................................. 44</p>
<p> </p>
<p>5.7.1</p>
<p> </p>
<p>RAM Usage ..................................................................................... 44</p>
<p> </p>
<p>5.7.2</p>
<p> </p>
<p>ROM Usage ..................................................................................... 44</p>
<p> </p>
<p>5.7.3</p>
<p> </p>
<p>NV Usage ........................................................................................ 45</p>
<p> </p>
<p>5.8</p>
<p> </p>
<p>How-To: Integrate NVM with AUTOSAR3 SWC’s ............................................. 45</p>
<p> </p>
<p>5.8.1</p>
<p> </p>
<p>NVM’s provided Interfaces/Ports. ..................................................... 45</p>
<p> </p>
<p>5.8.2</p>
<p> </p>
<p>Callbacks (Ports provided by client SWCs) ...................................... 46</p>
<p> </p>
<p>5.8.3</p>
<p> </p>
<p>Request Result Types ...................................................................... 46</p>
<p> </p>
<p><b>6</b></p>
<p> </p>
<p><b>API Description ........................................................................................................... 47</b></p>
<p> </p>
<p>6.1</p>
<p> </p>
<p>Interfaces Overview ......................................................................................... 47</p>
<p> </p>
<p>6.2</p>
<p> </p>
<p>Type Definitions ............................................................................................... 47</p>
<p> </p>
<p>6.3</p>
<p> </p>
<p>Global API Constants ....................................................................................... 49</p>
<p> </p>
<p>6.4</p>
<p> </p>
<p>Services provided by NVM ............................................................................... 49</p>
<p> </p>
<p>6.4.1</p>
<p> </p>
<p>NvM_Init ........................................................................................... 49</p>
<p> </p>
<p>6.4.2</p>
<p> </p>
<p>NvM_SetDataIndex .......................................................................... 49</p>
<p> </p>
<p>6.4.3</p>
<p> </p>
<p>NvM_GetDataIndex.......................................................................... 50</p>
<p> </p>
<p>6.4.4</p>
<p> </p>
<p>NvM_SetBlockProtection ................................................................. 51</p>
<p> </p>
<p>6.4.5</p>
<p> </p>
<p>NvM_GetErrorStatus ........................................................................ 52</p>
<p> </p>
<p>6.4.6</p>
<p> </p>
<p>NvM_GetVersionInfo ........................................................................ 52</p>
<p> </p>
<p>6.4.7</p>
<p> </p>
<p>NvM_SetRamBlockStatus ................................................................ 53</p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 5.07.01 </p>
<p>9 </p>
<p>based on template version 3.01 </p>
<p>6.4.8</p>
<p> </p>
<p>NvM_SetBlockLockStatus ................................................................ 54</p>
<p> </p>
<p>6.4.9</p>
<p> </p>
<p>NvM_MainFunction .......................................................................... 55</p>
<p> </p>
<p>6.4.10</p>
<p> </p>
<p>NvM_ReadBlock .............................................................................. 55</p>
<p> </p>
<p>6.4.11</p>
<p> </p>
<p>NvM_WriteBlock .............................................................................. 56</p>
<p> </p>
<p>6.4.12</p>
<p> </p>
<p>NvM_RestoreBlockDefaults ............................................................. 57</p>
<p> </p>
<p>6.4.13</p>
<p> </p>
<p>NvM_EraseNvBlock ......................................................................... 58</p>
<p> </p>
<p>6.4.14</p>
<p> </p>
<p>NvM_InvalidateNvBlock ................................................................... 59</p>
<p> </p>
<p>6.4.15</p>
<p> </p>
<p>NvM_ReadAll ................................................................................... 60</p>
<p> </p>
<p>6.4.16</p>
<p> </p>
<p>NvM_WriteAll ................................................................................... 61</p>
<p> </p>
<p>6.4.17</p>
<p> </p>
<p>NvM_CancelWriteAll ........................................................................ 62</p>
<p> </p>
<p>6.4.18</p>
<p> </p>
<p>NvM_KillWriteAll .............................................................................. 62</p>
<p> </p>
<p>6.4.19</p>
<p> </p>
<p>NvM_CancelJobs ............................................................................. 63</p>
<p> </p>
<p>6.4.20</p>
<p> </p>
<p>NvM_RepairRedundantBlocks ......................................................... 63</p>
<p> </p>
<p>6.5</p>
<p> </p>
<p>Services used by NVM ..................................................................................... 64</p>
<p> </p>
<p>6.6</p>
<p> </p>
<p>Callback Functions ........................................................................................... 65</p>
<p> </p>
<p>6.6.1</p>
<p> </p>
<p>NvM_JobEndNotification .................................................................. 65</p>
<p> </p>
<p>6.6.2</p>
<p> </p>
<p>NvM_JobErrorNotification ................................................................ 66</p>
<p> </p>
<p>6.7</p>
<p> </p>
<p>Configurable Interfaces .................................................................................... 66</p>
<p> </p>
<p>6.7.1</p>
<p> </p>
<p>SingleBlockCallbackFunction ........................................................... 66</p>
<p> </p>
<p>6.7.2</p>
<p> </p>
<p>MultiBlockCallbackFunction ............................................................. 67</p>
<p> </p>
<p>6.7.3</p>
<p> </p>
<p>InitBlockCallbackFunction ................................................................ 67</p>
<p> </p>
<p>6.7.4</p>
<p> </p>
<p>Callback function for RAM to NvM copy ........................................... 68</p>
<p> </p>
<p>6.7.5</p>
<p> </p>
<p>Callback function for NvM to RAM copy ........................................... 69</p>
<p> </p>
<p>6.8</p>
<p> </p>
<p>Service Ports ................................................................................................... 69</p>
<p> </p>
<p>6.8.1</p>
<p> </p>
<p>Client Server Interface ..................................................................... 69</p>
<p> </p>
<p><b>7</b></p>
<p> </p>
<p><b>Configuration .............................................................................................................. 72</b></p>
<p> </p>
<p>7.1</p>
<p> </p>
<p>Software Component Template ........................................................................ 72</p>
<p> </p>
<p>7.1.1</p>
<p> </p>
<p>Generation ....................................................................................... 72</p>
<p> </p>
<p>7.1.2</p>
<p> </p>
<p>Import into DaVinci Developer .......................................................... 72</p>
<p> </p>
<p>7.1.3</p>
<p> </p>
<p>Dependencies on Configuration of NVM Attributes ........................... 73</p>
<p> </p>
<p>7.1.4</p>
<p> </p>
<p>Service Port Prototypes ................................................................... 74</p>
<p> </p>
<p>7.1.5</p>
<p> </p>
<p>Modelling SWC’s callback functions ................................................. 74</p>
<p> </p>
<p>7.2</p>
<p> </p>
<p>Configuration of NVM Attributes ....................................................................... 76</p>
<p> </p>
<p><b>8</b></p>
<p> </p>
<p><b>AUTOSAR Standard Compliance............................................................................... 78</b></p>
<p> </p>
<p>8.1</p>
<p> </p>
<p>Deviations ........................................................................................................ 78</p>
<p> </p>
<p>8.2</p>
<p> </p>
<p>Additions/ Extensions ....................................................................................... 78</p>
<p> </p>
<p>8.2.1</p>
<p> </p>
<p>Parameter Checking ........................................................................ 78</p>
<p> </p>
<p>8.2.2</p>
<p> </p>
<p>Concurrent access to NV data ......................................................... 78</p>
<p> </p>
<p>8.2.3</p>
<p> </p>
<p>RAM-/ROM Block Size checks ......................................................... 78</p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 5.07.01 </p>
<p>10 </p>
<p>based on template version 3.01 </p>
<p>8.2.4</p>
<p> </p>
<p>Calculated CRC value does not depend on number of calculation </p>
<p>steps ................................................................................................ 78</p>
<p> </p>
<p>8.3</p>
<p> </p>
<p>Limitations........................................................................................................ 79</p>
<p> </p>
<p><b>9</b></p>
<p> </p>
<p><b>Glossary and Abbreviations ...................................................................................... 80</b></p>
<p> </p>
<p>9.1</p>
<p> </p>
<p>Glossary .......................................................................................................... 80</p>
<p> </p>
<p>9.2</p>
<p> </p>
<p>Abbreviations ................................................................................................... 80</p>
<p> </p>
<p><b>10</b></p>
<p> </p>
<p><b>Contact ........................................................................................................................ 82</b></p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 5.07.01 </p>
<p>11 </p>
<p>based on template version 3.01 </p>
<p><b>Illustrations </b></p>
<p>Figure 3-1</p>
<p> </p>
<p>AUTOSAR 4.x Architecture Overview ....................................................... 16</p>
<p> </p>
<p>Figure 3-2</p>
<p> </p>
<p>Interfaces to adjacent modules of the NVM .............................................. 17</p>
<p> </p>
<p>Figure 5-1</p>
<p> </p>
<p>The file structure of the NVM sections module .......................................... 39</p>
<p> </p>
<p>Figure 7-1</p>
<p> </p>
<p>Import a new software component into DaVinci Developer ....................... 72</p>
<p> </p>
<p>Figure 7-2 A </p>
<p> </p>
<p>“Single Block Job End Notification” with return type Std_ReturnType ....... 75</p>
<p> </p>
<p>Figure 7-3 A </p>
<p> </p>
<p>“Single Block Job End Notification” with return type void. ......................... 76</p>
<p> </p>
<p><b> </b></p>
<p><b>Tables </b></p>
<p>  </p>
<p>Table 1-1 </p>
<p> </p>
<p>History of the document .............................................................................. 6</p>
<p> </p>
<p>Table 1-2 </p>
<p> </p>
<p>Reference documents ................................................................................. 6</p>
<p> </p>
<p>Table 2-1 </p>
<p> </p>
<p>Component history.................................................................................... 14</p>
<p> </p>
<p>Table 4-1 </p>
<p> </p>
<p>Supported SWS features from main AUTOSAR version [1] ...................... 18</p>
<p> </p>
<p>Table 4-2 </p>
<p> </p>
<p>Not supported SWS features from main AUTOSAR version [1]................. 18</p>
<p> </p>
<p>Table 4-3 </p>
<p> </p>
<p>Supported SWS features from AUTOSAR version [2] ............................... 19</p>
<p> </p>
<p>Table 4-4 </p>
<p> </p>
<p>Block concept ........................................................................................... 25</p>
<p> </p>
<p>Table 4-5 </p>
<p> </p>
<p>Mapping of service IDs to services ........................................................... 34</p>
<p> </p>
<p>Table 4-6 </p>
<p> </p>
<p>Errors reported to DET ............................................................................. 35</p>
<p> </p>
<p>Table 4-7 </p>
<p> </p>
<p>Development Error Checking: Assignment of checks to services .............. 36</p>
<p> </p>
<p>Table 4-8 </p>
<p> </p>
<p>Errors reported to DEM ............................................................................. 36</p>
<p> </p>
<p>Table 5-1 </p>
<p> </p>
<p>Static files ................................................................................................. 38</p>
<p> </p>
<p>Table 5-2 </p>
<p> </p>
<p>Generated files ......................................................................................... 38</p>
<p> </p>
<p>Table 5-3 </p>
<p> </p>
<p>Compiler abstraction and memory mapping .............................................. 40</p>
<p> </p>
<p>Table 6-1 </p>
<p> </p>
<p>Type definitions ......................................................................................... 49</p>
<p> </p>
<p>Table 6-2 </p>
<p> </p>
<p>NvM_Init ................................................................................................... 49</p>
<p> </p>
<p>Table 6-3 </p>
<p> </p>
<p>NvM_SetDataIndex................................................................................... 50</p>
<p> </p>
<p>Table 6-4 </p>
<p> </p>
<p>NvM_GetDataIndex .................................................................................. 51</p>
<p> </p>
<p>Table 6-5 </p>
<p> </p>
<p>NvM_SetBlockProtection .......................................................................... 51</p>
<p> </p>
<p>Table 6-6 </p>
<p> </p>
<p>NvM_GetErrorStatus ................................................................................ 52</p>
<p> </p>
<p>Table 6-7 </p>
<p> </p>
<p>NvM_GetVersionInfo ................................................................................. 53</p>
<p> </p>
<p>Table 6-8 </p>
<p> </p>
<p>NvM_SetRamBlockStatus......................................................................... 53</p>
<p> </p>
<p>Table 6-9 </p>
<p> </p>
<p>NvM_SetBlockLockStatus......................................................................... 54</p>
<p> </p>
<p>Table 6-10 </p>
<p> </p>
<p>NvM_MainFunction ................................................................................... 55</p>
<p> </p>
<p>Table 6-11 </p>
<p> </p>
<p>NvM_ReadBlock ....................................................................................... 56</p>
<p> </p>
<p>Table 6-12 </p>
<p> </p>
<p>NvM_WriteBlock ....................................................................................... 57</p>
<p> </p>
<p>Table 6-13 </p>
<p> </p>
<p>NvM_RestoreBlockDefaults ...................................................................... 58</p>
<p> </p>
<p>Table 6-14 </p>
<p> </p>
<p>NvM_EraseNvBlock .................................................................................. 59</p>
<p> </p>
<p>Table 6-15 </p>
<p> </p>
<p>NvM_InvalidateNvBlock ............................................................................ 60</p>
<p> </p>
<p>Table 6-16 </p>
<p> </p>
<p>NvM_ReadAll ............................................................................................ 61</p>
<p> </p>
<p>Table 6-17 </p>
<p> </p>
<p>NvM_WriteAll ............................................................................................ 62</p>
<p> </p>
<p>Table 6-18 </p>
<p> </p>
<p>NvM_CancelWriteAll ................................................................................. 62</p>
<p> </p>
<p>Table 6-19 </p>
<p> </p>
<p>NvM_KilllWriteAll ...................................................................................... 63</p>
<p> </p>
<p>Table 6-20 </p>
<p> </p>
<p>NvM_CancelJobs ..................................................................................... 63</p>
<p> </p>
<p>Table 6-21 </p>
<p> </p>
<p>NvM_RepairRedundantBlocks .................................................................. 64</p>
<p> </p>
<p>Table 6-22 </p>
<p> </p>
<p>Services used by the NVM ........................................................................ 65</p>
<p> </p>
<p>Table 6-23 </p>
<p> </p>
<p>NvM_JobEndNotification .......................................................................... 65</p>
<p> </p>
<p>Table 6-24 </p>
<p> </p>
<p>NvM_JobErrorNotification ......................................................................... 66</p>
<p> </p>
<p>Table 6-25 </p>
<p> </p>
<p>SingleBlockCallbackFunction .................................................................... 67</p>
<p> </p>
<p>Table 6-26</p>
<p> </p>
<p>MultiBlockCallbackFunction ...................................................................... 67</p>
<p> </p>
<p>Table 6-27</p>
<p> </p>
<p>InitBlockCallbackFunction ......................................................................... 68</p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 5.07.01 </p>
<p>12 </p>
<p>based on template version 3.01 </p>
<p>Table 6-28</p>
<p> </p>
<p>Callback function for RAM to NvM copy .................................................... 69</p>
<p> </p>
<p>Table 6-29</p>
<p> </p>
<p>Callback function for NvM to RAM copy .................................................... 69</p>
<p> </p>
<p>Table 6-30</p>
<p> </p>
<p>Operations of Port Prototype Padmin_&lt;BlockName&gt; ............................... 70</p>
<p> </p>
<p>Table 6-31</p>
<p> </p>
<p>Operations of Port Prototype PS_&lt;BlockName&gt; ....................................... 70</p>
<p> </p>
<p>Table 6-32</p>
<p> </p>
<p>Operation of Port prototype NvM_RpNotifyFinished_Id&lt;BlockName&gt; ...... 71</p>
<p> </p>
<p>Table 9-1 </p>
<p> </p>
<p>Glossary ................................................................................................... 80</p>
<p> </p>
<p>Table 9-2 </p>
<p> </p>
<p>Abbreviations ............................................................................................ 81</p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 5.07.01 </p>
<p>13 </p>
<p>based on template version 3.01 </p>
<p><b>2 </b></p>
<p><b>Component History </b></p>
<p><b>Component </b></p>
<p><b>Version </b></p>
<p><b>(Implementation)</b></p>
<p><b> </b></p>
<p><b>New Features </b></p>
<p>5.07.xx </p>
<p>Added NvMCRCCompMechanism (from AUTOSAR 4.2.2) </p>
<p>5.05.xx </p>
<p>Reworked job end and init block callback invocation during ReadAll for blocks </p>
<p>with service ports </p>
<p>5.03.xx </p>
<p>Specific development errors cannot be switched on/off, only global development </p>
<p>error mode can be enabled/disabled </p>
<p>5.02.xx </p>
<p>Added RepairRedundantBlocks functionality </p>
<p>SafeBSW </p>
<p>5.01.xx </p>
<p>Interaction with BswM added. </p>
<p>Defined Block Write Order (descending IDs) during write all </p>
<p>5.xx.xx </p>
<p>AUTOSAR4.0. </p>
<p>•</p>
<p> </p>
<p>Changed API (return types) </p>
<p>•</p>
<p> </p>
<p>New service: </p>
<p>NvM_CancelJobs</p>
<p> </p>
<p>•</p>
<p> </p>
<p>New DEM Errors  </p>
<p>•</p>
<p> </p>
<p>“Write Block during WriteAll” configurable </p>
<p>•</p>
<p> </p>
<p>Explicit Synchronization Mechanism </p>
<p>4.xx.xx </p>
<p>Skipped/Reserved. </p>
<p>3.09.xx </p>
<p>Removed AUTOSAR Version Check for DEM </p>
<p>NvM_Mainfunction</p>
<p> runnable is always generated into SWC 13escription </p>
<p>Generation of SWC Interface Names according to AUTOSAR  </p>
<p>3.08.xx </p>
<p>NVM provides information about error codes for MICROSAR Dem to automate </p>
<p>configuration. </p>
<p>3.07.xx </p>
<p>Service </p>
<p>NvM_KillWriteAll</p>
<p> added. </p>
<p>Significant changes in internal handling (CRC/internal buffer) </p>
<p>3.06.xx </p>
<p>Never released; no new features. </p>
<p>3.05.xx </p>
<p>Calculated CRC32 value does not depend anymore on configuration of </p>
<p>parameter NvmCrcNumOfBytes. </p>
<p>Added RAM and ROM block size checks: The NVM can be configured to check </p>
<p>each RAM block’s and/or each ROM block’s size against the configured NV </p>
<p>block length, considering CRC setting, internal buffering, etc. </p>
<p>3.04.xx </p>
<p>Crc Handling is configurable: Either the internal buffer, available since </p>
<p>component version 3.02, is used or Crc is stored at the end of RAM Block. </p>
<p>3.03.xx </p>
<p>At processing a redundant NVRAM Block NVM determines an appropriate write </p>
<p>order, depending on the NV Block’s current state/content. A defect NV block is </p>
<p>written in preference to a valid one. </p>
<p>NVM provides possibility for DCM to access NV data concurrently with NVM’s </p>
<p>applications. </p>
<p>3.02.xx </p>
<p>Update to AUTOSAR 3 specification. </p>
<p>Additional API </p>
<p>NvM_SetBlockLockStatus</p>
<p>. </p>
<p>Storing each NVRAM block’s CRC internally: RAM Blocks provided by the </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 5.07.01 </p>
<p>14 </p>
<p>based on template version 3.01 </p>
<p><b>Component </b></p>
<p><b>Version </b></p>
<p><b>(Implementation)</b></p>
<p><b> </b></p>
<p><b>New Features </b></p>
<p>application don’t have to allocate additional space for CRC. </p>
<p>Configurability, whether the NVM shall create the RAM Block associated with the </p>
<p>ConfigID NVRAM Block on its own, or the user creates the RAM block. </p>
<p>Table 2-1  </p>
<p>Component history </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 5.07.01 </p>
<p>15 </p>
<p>based on template version 3.01 </p>
<p><b>3 </b></p>
<p><b>Introduction </b></p>
<p>This document describes the functionality, API and configuration of the AUTOSAR BSW </p>
<p>module NVM as specified in [1].  </p>
<p> </p>
<p><b>Supported AUTOSAR Release*: </b></p>
<p>4 </p>
<p><b>Supported Configuration Variants: </b></p>
<p>link-time </p>
<p><b> </b></p>
<p> </p>
<p><b>Vendor ID: </b></p>
<p>NVM_VENDOR_ID </p>
<p>30 decimal </p>
<p>(= </p>
<p>Vector-Informatik, </p>
<p>according to HIS) </p>
<p><b>Module ID: </b></p>
<p>NVM_MODULE_ID   </p>
<p>20 decimal </p>
<p>(according to ref. [5]) </p>
<p>* For the precise AUTOSAR Release 3.x please see the release specific documentation.  </p>
<p> </p>
<p>The  module  NVM  is  created  to  abstract  the  usage  of  non-volatile  memory,  such  as </p>
<p>EEPROM or Flash, from application. All access to NV memory is block based. To avoid </p>
<p>conflicts and inconsistent data the NVM shall be the only module to access non-volatile </p>
<p>memory. </p>
<p>The  NVM  accesses  the  module  MEMIF  (Memory Abstraction  Interface)  which  abstracts </p>
<p>the modules FEE (Flash EEPROM Emulation) and EA (EEPROM Abstraction). Thus, the </p>
<p>NVM is hardware independent. The modules FEE and EA abstract the access to Flash or </p>
<p>EEPROM driver. To select the appropriate device (FEE or EA) the NVM uses a handle that </p>
<p>is provided by the MEMIF.  </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>MICROSAR FEE and MICROSAR EA are different products that are not part of </p>
<p>MICROSAR NVM! </p>
<p><b> </b></p>
<p><b> </b></p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 5.07.01 </p>
<p>16 </p>
<p>based on template version 3.01 </p>
<p><b>3.1 </b></p>
<p><b>Architecture Overview </b></p>
<p>The following figure shows where the NVM is located in the AUTOSAR architecture. </p>
<p> </p>
<p>Figure 3-1 </p>
<p>AUTOSAR 4.x Architecture Overview </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 5.07.01 </p>
<p>17 </p>
<p>based on template version 3.01 </p>
<p>The next figure shows the interfaces to adjacent modules of the  NVM. These interfaces </p>
<p>are described in chapter 6.  </p>
<p> </p>
<p>Figure 3-2 </p>
<p>Interfaces to adjacent modules of the NVM </p>
<p>Applications normally do not access the services of the BSW modules directly. They use </p>
<p>the service ports provided by the BSW modules via the RTE. The service ports provided </p>
<p>by the NVM are listed in chapter 6.8 and are defined in [1]. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 5.07.01 </p>
<p>18 </p>
<p>based on template version 3.01 </p>
<p><b>4 </b></p>
<p><b>Functional Description </b></p>
<p><b>4.1 </b></p>
<p><b>Features </b></p>
<p>The features listed in this chapter cover the complete functionality specified in [1]. </p>
<p>The <b>supported </b>and <b>not supported </b>features are presented in the following two tables. For </p>
<p>further information on not supported features also see chapter 8. </p>
<p> </p>
<p>The following features described in [1] are supported: </p>
<p><b>Supported Feature </b></p>
<p>Complete API </p>
<p>Block Management Types (Native, Redundant, Dataset) </p>
<p>CRC handling (CRC16, CRC32) </p>
<p>Priority handling, including Immediate (Crash) Data write </p>
<p>Job queuing </p>
<p>ROM defaults (ROM defaults block, Init callback) </p>
<p>Config Id handling </p>
<p>RAM block valid/modified handling </p>
<p>Re-Validation of RAM blocks during start up using CRC </p>
<p>Job end notifications </p>
<p>Skipping Blocks during Start-Up </p>
<p>API Configuration Classes </p>
<p>Service Ports – Generation of Software Component Description </p>
<p>Concurrent access to NV data for DCM </p>
<p>Explicit Synchronization mechanism between application and NVM </p>
<p>Interaction with BswM </p>
<p>Table 4-1  </p>
<p>Supported SWS features from main AUTOSAR version [1] </p>
<p>The following features described in [1] are not supported: </p>
<p><b>Not Supported Feature </b></p>
<p>Dataset ROM blocks (Management Type Dataset, multiple ROM blocks) </p>
<p>Disabling Set/Get_DataIndex API </p>
<p>Static Block ID Check during read </p>
<p>Write Verification </p>
<p>Read Retries </p>
<p>Table 4-2  </p>
<p>Not supported SWS features from main AUTOSAR version [1] </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 5.07.01 </p>
<p>19 </p>
<p>based on template version 3.01 </p>
<p>The following features described in [2] are supported </p>
<p><b>Supported Feature </b></p>
<p>CRC Compare Mechanism </p>
<p>Table 4-3  </p>
<p>Supported SWS features from AUTOSAR version [2] </p>
<p><b>4.1.1 </b></p>
<p><b>Safety Features </b></p>
<p><b>4.1.1.1 </b></p>
<p><b>Block Id check </b></p>
<p>NvM  provides  a  feature  to  ensure  the  underlying  devices  deliver  data  for  the  currently </p>
<p>processing NvM block – Block Id Check. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>Since the Block Id Check is implemented via extension in CRC calculation, the feature </p>
<p>is only working for NvM block configured with CRC. </p>
<p>Since the feature uses the NvM Block Id, during configuration update the user has to </p>
<p>ensure the Block Id remains the same for each NvM Block. Otherwise the check will fail </p>
<p>though the correct data was read. </p>
<p><b> </b></p>
<p><b> </b></p>
<p>To check the data to belong to currently processing NvM Block, the NvM calculates the </p>
<p>NvM Block Id and the current Dataindex into its CRC. That means in fact that the NvM </p>
<p>calculates the CRC over the Block Id (2 bytes), Dataindex (1 byte) and the actual data –  </p>
<p>NvM needs one CRC calculation function call more that without the Block Id check.  </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>The NvM is not able to distinguish between wrong CRC and CRC calculated for </p>
<p>another NvM Block! In case the underlying modules deliver data belonging to wrong </p>
<p>NvM Block, the NvM behaves in same way as in case of CRC mismatch. </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>4.1.2 </b></p>
<p><b>Automatic Block Length </b></p>
<p>Since the block length might be unknown during configuration time, the feature Automatic </p>
<p>Block Length can be enabled for NvM blocks with permanently configured RAM. </p>
<p>The feature changes the meaning of block length from actual length to maximum length - </p>
<p>the actual block length is set via size of permanent RAM within generated structures. The </p>
<p>configured length is used by underlying modules to initialize their structures, therefore it </p>
<p>must not be less than the actual length. To check the configured length to be valid, Block </p>
<p>Length Check (see 4.5.3) shall be enabled. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 5.07.01 </p>
<p>20 </p>
<p>based on template version 3.01 </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>After the system is running and the actual block lengths are known, the configuration </p>
<p>shall be adjusted to the actual length. Since the configured lengths are used by </p>
<p>underlying modules, there might be a lot of unused space in Flash or EEPROM. </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>4.2 </b></p>
<p><b>Initialization </b></p>
<p>Before the module NVM can be used it has to be initialized. All modules, NVM depends </p>
<p>on, need to be initialized before. The initialization of all these modules should be done by </p>
<p>the ECU State Manager. If the NVM is not used in an AUTOSAR environment it should be </p>
<p>done by a different entity. Pay attention that the NVM <b>will not </b>initialize the used modules </p>
<p>by its own. </p>
<p>Depending  on  the  configuration  of  the  NVM  stack,  different  modules  might  need  to  be </p>
<p>initialized. It is advised to use a bottom up strategy for initialization: </p>
<p><b>&gt; </b> NV device drivers for internal devices (FLS/EEP) </p>
<p><b>&gt; </b> Low level driver that an external NV device driver might depend on (e.g. DIO, SPI) </p>
<p><b>&gt; </b> Drivers for external NV devices (e.g. external EEP or FLS) </p>
<p><b>&gt; </b> NV device abstraction modules (EA/FEE) </p>
<p><b>&gt; </b> Non-Volatile Manager (NVM) </p>
<p>Initializing the modules in this sequence ensures that, as soon as a module is used, the </p>
<p>modules it depends on are ready. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Basic Knowledge </b></p>
<p>NvM initialization consists of two steps </p>
<p>1.</p>
<p> </p>
<p>NvM_Init()</p>
<p> (see 4.2.1)</p>
<p> </p>
<p>2.</p>
<p> </p>
<p>NvM_ReadAll()</p>
<p> (see 4.2.2)</p>
<p> </p>
<p>Indenpendently from </p>
<p>SelectBlockForReadAll</p>
<p> NvM uses the </p>
<p>NvM_ReadAll()</p>
<p> to </p>
<p>initialize all its blocks. Therefore it is not possible to access any NvM block until it was </p>
<p>initialized during </p>
<p>NvM_ReadAll()</p>
<p>. </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>4.2.1 </b></p>
<p><b>Start-up </b></p>
<p>The basic initialization of the NVRAM Manager is done by the request </p>
<p>NvM_Init().</p>
<p> It </p>
<p>shall  be  invoked  e.g.  by  the  ECU  State  Manager  exclusively.  Due  to  strong  constraints </p>
<p>concerning  the  ECU  start-up  time  the </p>
<p>NvM_Init()</p>
<p>  request  does  not  contain  the  basic </p>
<p>initialization  of  the  configured  NVRAM  blocks.  The </p>
<p>NvM_Init()</p>
<p>  request  resets  the </p>
<p>internal variables of the NVM such as the queue and the state machine. </p>
<p><b>4.2.2 </b></p>
<p><b>Initialization of the Data Blocks </b></p>
<p>The initialization of the single blocks is normally also initiated by the ECU State Manager </p>
<p>by calling </p>
<p>NvM_ReadAll().</p>
<p> All blocks that have no valid RAM data anymore and have </p>
<p>SelectBlockForReadAll</p>
<p>  set  will  be  reloaded  from  NV  memory  or  from  ROM  (if </p>
<p>available).  All  other  blocks  won’t  be  reloaded,  they  must  be  loaded  manually  by  the </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 5.07.01 </p>
<p>21 </p>
<p>based on template version 3.01 </p>
<p>application </p>
<p>calling </p>
<p>NvM_ReadBlock()</p>
<p>, </p>
<p>but </p>
<p>they </p>
<p>will </p>
<p>be </p>
<p>initialized, </p>
<p>e.g. </p>
<p>their </p>
<p>write </p>
<p>protection and status. </p>
<p>Block 1 (the configuration ID) has a special role. It is stored in NV memory and also as a </p>
<p>constant </p>
<p>(</p>
<p>NvM_CompiledConfigId_t</p>
<p>) </p>
<p>that </p>
<p>is </p>
<p>externally </p>
<p>visible </p>
<p>and </p>
<p>link-time </p>
<p>configurable.  During </p>
<p>NvM_ReadAll()</p>
<p>  the  NV  value  of  block 1  is compared  against  the </p>
<p>constant </p>
<p>NvM_CompiledConfigId_t</p>
<p>. In case of a match all NV blocks are presumed to </p>
<p>be  valid  and  NVM  tries  to  read them from NV  memory.  In  case of  a mismatch or if  the </p>
<p>configuration ID cannot be read the system behaves as following: </p>
<p><b>&gt; </b> If the configuration switch <b>Dynamic Configuration Handling </b>is <b>OFF</b>, the mismatch is </p>
<p>ignored. It will be tried to read all blocks from NV memory (also called ‘normal runtime </p>
<p>preparation’). </p>
<p><b>&gt; </b> If the <b>Dynamic Configuration Handling </b>is <b>ON</b>, the normal runtime preparation is </p>
<p>processed for all blocks having been configured with the option ‘Resistant to Changed </p>
<p>SW’. For all other blocks an ‘extended runtime preparation’ will take place. </p>
<p><b>&gt; </b> All blocks that will be processed with the ‘extended runtime preparation’ will be treated </p>
<p>as invalid or blank. Thus, it is possible to rewrite a block having been marked as ‘Write </p>
<p>Once’. If available, ROM defaults are loaded or the initialization callback is invoked. </p>
<p><b>4.3 </b></p>
<p><b>States </b></p>
<p>The NVRAM Manager is internally organized with a state machine which is shown in the </p>
<p>following chapters. </p>
<p><b>4.4 </b></p>
<p><b>Main Functions </b></p>
<p><b>4.4.1 </b></p>
<p><b>Hardware Independence </b></p>
<p>The NVRAM Manager is independent from its underlying memory hardware. It accesses </p>
<p>the API of the MEMIF (Memory Abstraction Interface). The MEMIF abstracts the modules </p>
<p>FEE (Flash EEPROM Emulation) and EA (EEPROM Abstraction) for the NVM. FEE and </p>
<p>EA are used for storing data blocks in Flash or EEPROM devices. For selecting at which </p>
<p>FEE or EA instance a block shall be stored, the NVM uses a device handle (device ID) that </p>
<p>is provided by the MEMIF. </p>
<p><b>4.4.2 </b></p>
<p><b>Synchronous Requests </b></p>
<p>The NVM API services are divided into synchronous and asynchronous requests.  </p>
<p>The synchronous services are executed immediately when called. They are executed in </p>
<p>the context of the calling task. This means, that behavior depends on the characteristics of </p>
<p>the calling task and not on the NVM. For example, if the calling task is a non-preemptive </p>
<p>one, the synchronous NVM request will be executed until it has finished. Otherwise, if the </p>
<p>calling  task  is  a  preemptive  one,  the  synchronous  NVM  request  can  be  preempted  by </p>
<p>another higher prioritized task. </p>
<p>Following NVM API services initiate synchronous requests: </p>
<p><b>&gt;</b></p>
<p><b> </b></p>
<p>NvM_Init() </p>
<p><b>&gt;</b></p>
<p><b> </b></p>
<p>NvM_SetDataIndex() </p>
<p><b>&gt;</b></p>
<p><b> </b></p>
<p>NvM_GetDataIndex() </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 5.07.01 </p>
<p>22 </p>
<p>based on template version 3.01 </p>
<p><b>&gt;</b></p>
<p><b> </b></p>
<p>NvM_SetBlockProtection() </p>
<p><b>&gt;</b></p>
<p><b> </b></p>
<p>NvM_SetBlockLockStatus() </p>
<p><b>&gt; </b></p>
<p>NvM_SetRamBlockStatus()</p>
<p> (for not CRC protected blocks) </p>
<p><b>&gt;</b></p>
<p><b> </b></p>
<p>NvM_GetErrorStatus() </p>
<p><b>&gt;</b></p>
<p><b> </b></p>
<p>NvM_GetVersionInfo() </p>
<p><b>4.4.3 </b></p>
<p><b>Asynchronous Requests </b></p>
<p>Following NVM API services initiate asynchronous requests: </p>
<p><b>&gt;</b></p>
<p><b> </b></p>
<p>NvM_ReadBlock() </p>
<p><b>&gt;</b></p>
<p><b> </b></p>
<p>NvM_WriteBlock() </p>
<p><b>&gt;</b></p>
<p><b> </b></p>
<p>NvM_RestoreBlockDefaults() </p>
<p><b>&gt;</b></p>
<p><b> </b></p>
<p>NvM_EraseNvBlock() </p>
<p><b>&gt;</b></p>
<p><b> </b></p>
<p>NvM_InvalidateNvBlock() </p>
<p><b>&gt; </b></p>
<p>NvM_SetRamBlockStatus()</p>
<p> (for CRC protected blocks) </p>
<p><b>&gt;</b></p>
<p><b> </b></p>
<p>NvM_ReadAll() </p>
<p><b>&gt;</b></p>
<p><b> </b></p>
<p>NvM_WriteAll() </p>
<p><b>&gt;</b></p>
<p><b> </b></p>
<p>NvM_CancelWriteAll() </p>
<p><b>&gt;</b></p>
<p><b> </b></p>
<p>NvM_CancelJobs() </p>
<p>The API call is handled in the context of the calling task. Here the service is queued and </p>
<p>will be processed asynchronously. The processing of the queued requests is done in the </p>
<p>context of the caller of the cyclic function </p>
<p>NvM_MainFunction(). </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>RAM blocks must not be accessed by any user while a request to its associated </p>
<p>NVRAM Block is pending! </p>
<p>There are some exceptions to this limitation: </p>
<p><b>&gt; </b></p>
<p>NvM_InvalidateNvBlock</p>
<p> and </p>
<p>NvM_EraseNvBlock</p>
<p> don’t access any RAM </p>
<p>blocks. Thus access is still possible without limitations </p>
<p><b>&gt; </b></p>
<p>While the NVM processes an </p>
<p>NvM_WriteBlock</p>
<p> request, the RAM block may still </p>
<p>read. </p>
<p><b>&gt; </b></p>
<p>Though applications are not expected to be running while NVM processes </p>
<p>NvM_WriteAll</p>
<p>, RAM blocks may be read, as during </p>
<p>NvM_WriteBlock</p>
<p> </p>
<p>processing. </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>4.4.4 </b></p>
<p><b>API Configuration Classes and additional API Services </b></p>
<p>Depending on the needs of the customer, the extent of the NVM can be tailored. Three </p>
<p>configuration classes are specified that offer a different amount of functionality/functions of </p>
<p>the NVM: </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 5.07.01 </p>
<p>23 </p>
<p>based on template version 3.01 </p>
<p><b>API configuration class 1: </b></p>
<p>A minimum set of API services is used. Queuing and job prioritization are not implemented. </p>
<p>Following functions are available: </p>
<p><b>&gt;</b></p>
<p><b> </b></p>
<p>NvM_Init() </p>
<p><b>&gt;</b></p>
<p><b> </b></p>
<p>NvM_GetErrorStatus() </p>
<p><b>&gt;</b></p>
<p><b> </b></p>
<p>NvM_SetRamBlockStatus() </p>
<p><b>&gt;</b></p>
<p><b> </b></p>
<p>NvM_ReadAll() </p>
<p><b>&gt;</b></p>
<p><b> </b></p>
<p>NvM_WriteAll() </p>
<p><b>&gt;</b></p>
<p><b> </b></p>
<p>NvM_CancelWriteAll() </p>
<p><b>API configuration class 2: </b></p>
<p>Intermediate set of API services. Queuing and job prioritization are implemented. Following </p>
<p>functions are available additionally according to API configuration class 1: </p>
<p><b>&gt;</b></p>
<p><b> </b></p>
<p>NvM_SetDataIndex() </p>
<p><b>&gt;</b></p>
<p><b> </b></p>
<p>NvM_GetDataIndex() </p>
<p><b>&gt;</b></p>
<p><b> </b></p>
<p>NvM_ReadBlock() </p>
<p><b>&gt;</b></p>
<p><b> </b></p>
<p>NvM_WriteBlock() </p>
<p><b>&gt;</b></p>
<p><b> </b></p>
<p>NvM_RestoreBlockDefaults() </p>
<p><b>&gt;</b></p>
<p><b> </b></p>
<p>NvM_CancelJobs() </p>
<p><b>API configuration class 3: </b></p>
<p>All  API </p>
<p>services </p>
<p>are  available.  Following  functions  can  be  used </p>
<p>additionally </p>
<p>to  API </p>
<p>configuration class 2:</p>
<p> </p>
<p><b>&gt;</b></p>
<p><b> </b></p>
<p>NvM_SetBlockProtection() </p>
<p><b>&gt;</b></p>
<p><b> </b></p>
<p>NvM_EraseNvBlock() </p>
<p><b>&gt;</b></p>
<p><b> </b></p>
<p>NvM_InvalidateNvBlock() </p>
<p>The </p>
<p>functions </p>
<p>NvM_SetRamBlockStatus()</p>
<p> </p>
<p>and </p>
<p>NvM_GetVersionInfo()</p>
<p> </p>
<p>can </p>
<p>be </p>
<p>enabled/disabled </p>
<p>additionally </p>
<p>via </p>
<p>the </p>
<p>configuration </p>
<p>tool. </p>
<p>The </p>
<p>function </p>
<p>NvM_SetBlockLockStatus() </p>
<p>is  always  available  independent  of  API  configuration </p>
<p>class. </p>
<p><b>4.4.5 </b></p>
<p><b>Block Handling </b></p>
<p><b>4.4.5.1 </b></p>
<p><b>NV Blocks and Block Handles </b></p>
<p>Every  application’s  data packet  that  is intended for  storage  in  NV  memory  is seen  as  a </p>
<p>block.  For each  block  a  unique  block  handle  (block  ID)  is  used.  For  the  application  the </p>
<p>(RAM) block is just one of its variables associated with the block. To write this variable to </p>
<p>NV memory it calls the </p>
<p>NvM_WriteBlock()</p>
<p> service with the block handle that is mapped </p>
<p>to this variable. The block handle names are given during configuration of the NVM. They </p>
<p>are published to the application by including </p>
<p>NvM.h</p>
<p>. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 5.07.01 </p>
<p>24 </p>
<p>based on template version 3.01 </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>The block handle names are automatically prefixed according to the AUTOSAR </p>
<p>Specification EcucConfiguration: </p>
<p> &lt;Module Definition&gt;Conf_&lt;Container Definition Short Name&gt;_&lt;Container Instance </p>
<p>Short Name&gt; </p>
<p>The prefixing has no influence on RTE. </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>The actual processing of an asynchronous job (such as a write job) is done in </p>
<p>NvM_MainFunction</p>
<p>. Therefore it needs to be called cyclically. Usually this is done by </p>
<p>the Basic Software Scheduler (SCHM). </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>4.4.5.2 </b></p>
<p><b>Different Types of NV Blocks </b></p>
<p>The application data can be stored in different types of blocks in the NV memory. </p>
<p><b>4.4.5.2.1 </b></p>
<p><b>Native Blocks </b></p>
<p>This is the standard block type. The data is stored once in the NV area. </p>
<p><b>4.4.5.2.2 </b></p>
<p><b>Redundant Blocks </b></p>
<p>This  type  is  intended  to  increase <b> availability </b> of  data,  in  case  of  errors,  i.e.  it  is  not </p>
<p>intended  to  provide  additional  error  detection.  The  main  focus  lies  on  write  aborts, </p>
<p>especially resets due to under-voltage conditions. </p>
<p>The  user  data  is  stored  twice  in  the  NV  area.  While  relying  on  lower  layers’  (FEE/EA) </p>
<p>detection of aborted write accesses, NVM makes sure that a readable data block remains </p>
<p>readable, even in case of write aborts. </p>
<p>For that purpose, before starting a write access, NVM checks primary and secondary NV </p>
<p>blocks to determine the adequate write order (which NV block to write first): If it detects a </p>
<p>defective NV Block, it is written in preference to a valid NV Block. If writing to one single </p>
<p>NV Block failed, the NVM reports the error NVM_E_REQ_FAILED (see chapter 4.5.2) to </p>
<p>the  DEM.  If  writing  to  primary  NV  block  failed,  NVM  ends  the  request  always  with  a </p>
<p>negative job result. If the primary NV block was written successfully, the request always </p>
<p>ends with a positive job result, even when the secondary NV block failed. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>It is recommended to configure CRC usage for Redundant Blocks, because CRC </p>
<p>provides adequate <b>error detection</b>, beyond the scope of aborts. </p>
<p><b> </b></p>
<p><b> </b></p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 5.07.01 </p>
<p>25 </p>
<p>based on template version 3.01 </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Expert Knowledge </b></p>
<p>NVM does not check any data to determine the write order. Rather, it just checks </p>
<p>whether lower layers would find valid data instances (i.e. whether they successfully </p>
<p>read a block’s first data byte). At this point, NVM relies on lower layers’ abort detection </p>
<p>capabilities. </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>NVM always attempts writing both NV blocks, regardless of errors reported by lower </p>
<p>layers. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> A read request is successful even if one block is corrupted but the  other block could be </p>
<p>read.  An  erase  or  invalidate  request  is  only  successful  if  both  blocks  could  be  erased </p>
<p>respectively invalidated.  </p>
<p><b>4.4.5.2.3 </b></p>
<p><b>Dataset Blocks </b></p>
<p>A dataset block can be seen as an array. A configurable number of instances of this block </p>
<p>are stored in NV-memory. In the RAM area there is only one RAM buffer. The appropriate </p>
<p>NV block instance is selected by the so called <b>data index</b>. The data index can be read and </p>
<p>set by synchronous API services </p>
<p>NvM_GetDataIndex()</p>
<p> and </p>
<p>NVM_SetDataIndex()</p>
<p>. </p>
<p>Concept </p>
<p><b>Description </b></p>
<p>Block </p>
<p>General notion of the structure composed of data, state and CRC. It is </p>
<p>spread over RAM, ROM and NVRAM. </p>
<p>NV Block </p>
<p>One block in NVRAM – CRC is optional. </p>
<p>NV Block of </p>
<p><b>&gt; </b></p>
<p>Native type </p>
<p><b>&gt; </b></p>
<p>Redundant type </p>
<p><b>&gt; </b></p>
<p>Dataset type </p>
<p>One NV Block of specified type. </p>
<p>RAM Block </p>
<p>One data Block in RAM. The data is shared by NVRAM Manager and </p>
<p>application. E. g. application writes data to this block and requests </p>
<p>NVRAM Manager to write it into NVRAM. </p>
<p>ROM Block </p>
<p>One data block in ROM. Default data supplied by application. </p>
<p>NVRAM Block </p>
<p>A logical composition of one RAM block and its corresponding NV and </p>
<p>ROM Block. </p>
<p>NV = NVRAM </p>
<p>Non-volatile memory. Actually a synonym for Flash or EEPROM devices. </p>
<p>Table 4-4  </p>
<p>Block concept </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Expert Knowledge </b></p>
<p>After a write abort, the “age” of data is not defined. NVM may deliver previous or recent </p>
<p>data; in fact it does not distinguish them. Before NVM completed the result with </p>
<p>NVM_REQ_OK, clients shall make no assumption on “age” of data in NV memory. </p>
<p><b> </b></p>
<p><b> </b></p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 5.07.01 </p>
<p>26 </p>
<p>based on template version 3.01 </p>
<p><b>4.4.5.3 </b></p>
<p><b>Permanent and non-permanent RAM Blocks </b></p>
<p>The  RAM  block  (application  variable)  can  be  either  permanent  or  non-permanent.  A </p>
<p>permanent RAM block belongs to a NV block that is accessed only by one application. The </p>
<p>address of the RAM block is fixed and is stored in the configuration of the NVM. </p>
<p>It  is  also  possible  to  have  multiple  applications  accessing  the  same  NV  block.  Each </p>
<p>application uses its own RAM block. In this case the RAM block is called non-permanent. </p>
<p>As the RAM address is not stored (and may vary) a pointer must be given for reading and </p>
<p>writing a non-permanent block. </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>Asynchronous API functions can be reentered by different tasks. So it is possible that </p>
<p>several tasks queue for example a write job at the same time (a task with higher priority </p>
<p>might interrupt a lower one). But it is not possible to queue the same block multiple </p>
<p>times (neither by different tasks nor for different jobs). So if for instance a read job for </p>
<p>block 5 is queued, an erase job for this block can’t be queued before the read job is </p>
<p>finished. </p>
<p>If one block is used by multiple tasks, which is a common task for non-permanent RAM </p>
<p>blocks, the application is responsible for synchronization. Of course if, for example, an </p>
<p>erase request is in process the RAM block could be read or written without any effect to </p>
<p>the result of the erase job. The only problem is that the NVM does not offer any </p>
<p>information to an application what service is currently processed for a block. The </p>
<p>application that initiated the service of course does know, but a different application that </p>
<p>also uses the block does not. So the safest way for block access is not to use the RAM </p>
<p>block as long as it is <b>pending</b>. This way RAM inconsistency can be avoided definitively. </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>4.4.5.4 </b></p>
<p><b>ROM Defaults </b></p>
<p>ROM defaults can be assigned to any NVRAM block. The ROM defaults block is provided </p>
<p>by the application. Alternatively, an initialization callback (see 4.4.13) can be used. These </p>
<p>features  are  selected  during  configuration.  It  is  only  possible  to  configure  either  ROM </p>
<p>defaults or an initialization callback for a block. </p>
<p>ROM defaults can be read explicit (by a call of </p>
<p>NvM_RestoreBlockDefaults()</p>
<p>). ROM </p>
<p>defaults will also be read implicitly during a read request, if no valid data could be read </p>
<p>from  NV-memory,  either  due  to  a  CRC  error  or  because  of  a  failure  reported  by  the </p>
<p>underlying MemHwA via MEMIF. </p>
<p><b>4.4.5.5 </b></p>
<p><b>Checksum </b></p>
<p>For  each  block  an  optional  checksum  can  be  configured.  This  checksum  can  be  either </p>
<p>CRC16 or CRC32. The checksum will be appended to user data; in NV memory they will </p>
<p>be stored consecutively in one single NV block. </p>
<p>If <b>Internal Buffer for CRC Handling </b>is disabled, Storage for CRC must be provided by </p>
<p>every single user; otherwise NVM provides an internal buffer. In this case it copies user </p>
<p>data (associated with NVRAM blocks configured with CRC) into an internal buffer, instead </p>
<p>of  directly  passing  them  down  to  lower  layers.  Here,  data  gets  appended  with  CRC,  in </p>
<p>order to keep both within one NV block, which requires NVM to pass both down with one </p>
<p>single write request. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 5.07.01 </p>
<p>27 </p>
<p>based on template version 3.01 </p>
<p>If  “Calc  RAM  CRC”  was  additionally  enabled,  NVM  will  internally  store  CRC  values  in </p>
<p>RAM, in order to check against them during </p>
<p>NvM_ReadAll</p>
<p> processing. Without internal </p>
<p>buffering, additional space in RAM block serves for this purpose. </p>
<p><b>4.4.6 </b></p>
<p><b>Prioritized or non-prioritized Queuing of asynchronous Requests </b></p>
<p>As mentioned before, asynchronous services are not processed immediately but queued </p>
<p>and  processed  asynchronously  by  the </p>
<p>NvM_MainFunction()</p>
<p>.  This  is  necessary  to </p>
<p>decrease the runtime of application tasks and to increase the predictability of their duration </p>
<p>(synchronous  write  jobs  on  an  EEPROM  or  Flash  would  block  your  task  for  multiple </p>
<p>milliseconds up to one second).  </p>
<p>Jobs </p>
<p>can </p>
<p>be </p>
<p>queued </p>
<p>either </p>
<p>prioritized </p>
<p>or </p>
<p>non-prioritized, </p>
<p>depending </p>
<p>on </p>
<p>the </p>
<p>user </p>
<p>configuration.  </p>
<p>If  job  prioritization  is  configured,  the  priorities  0  (immediate  priority)  until  255  (lowest </p>
<p>priority) can be selected for a block. It is important that the priority depends on the block, </p>
<p>rather than the request. Multi block requests always have a priority value greater than 255, </p>
<p>i.e. their priority is less than the lowest block specific priority; they will be processed after </p>
<p>all single block requests have been completed. </p>
<p>If block prioritization is not selected, the job queue works as a FIFO buffer. </p>
<p><b>4.4.7 </b></p>
<p><b>Asynchronous Job-End Polling </b></p>
<p>As </p>
<p>alluded </p>
<p>before, </p>
<p>asynchronous </p>
<p>requests </p>
<p>are </p>
<p>processed </p>
<p>in </p>
<p>the </p>
<p>background. </p>
<p>The </p>
<p>application  has  the  possibility  to  poll  the  NVM  for  the  end  of  the  service  by  calling </p>
<p>NvM_GetErrorStatus().</p>
<p> </p>
<p>NVM_REQ_PENDING</p>
<p>  will  be  returned  as  long  as  the  job  is </p>
<p>queued or in process. Once the job is finished </p>
<p>NvM_GetErrorStatus()</p>
<p> will return the </p>
<p>job result. </p>
<p><b>4.4.8 </b></p>
<p><b>Single Block Job End Notifications </b></p>
<p>Alternatively  to  poll  for  the  job-end,  a  job  end  notification  can  be  implemented  and </p>
<p>configured for every block. NvM invokes the notification each time a job was processed for </p>
<p>the block and informs about the finished job and its result via parameter. </p>
<p>The return value of the functions is specified but will not be used by the NVM. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>There  are  two  different  exceptions  where  the  NvM  does  not  invoke  the  job  end </p>
<p>notification: </p>
<p><b>&gt; </b></p>
<p>During </p>
<p>NvM_WriteAll()</p>
<p> the single block job end notification won’t be called </p>
<p><b>&gt; </b></p>
<p>During </p>
<p>NvM_ReadAll()</p>
<p> the single block job end notification won’t be called, if </p>
<p>the block is configured with enabled </p>
<p>NvMUseServicePorts</p>
<p>. This will be done </p>
<p>because during the </p>
<p>NvM_ReadAll()</p>
<p> the RTE is not initialed yet and callback </p>
<p>invocations </p>
<p>could </p>
<p>lead </p>
<p>to </p>
<p>DET </p>
<p>error. </p>
<p>For </p>
<p>all </p>
<p>blocks </p>
<p>with </p>
<p>disabled </p>
<p>NvMUseServicePorts</p>
<p> the callbacks will be invoked during </p>
<p>NvM_ReadAll()</p>
<p> </p>
<p>without restrictions. </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 5.07.01 </p>
<p>28 </p>
<p>based on template version 3.01 </p>
<p><b>4.4.9 </b></p>
<p><b>Immediate Priority Jobs and cancellation of current Jobs </b></p>
<p>Normal priority blocks, priority [1,255], do not cancel jobs with lower priority, NvM will wait </p>
<p>until the job is done and then pop the next job with highest priority from its queue.  </p>
<p>Only the NvM blocks with immediate priority, 0, must be processed as soon as possible. </p>
<p>Depending on current processing state following situations are possible: </p>
<p><b></b></p>
<p><b> </b></p>
<p>NvM does not process any job: process the immediate priority job. </p>
<p><b></b></p>
<p><b> </b></p>
<p>NvM processes a job: suspend the job, process the immediate priority job and finally re-</p>
<p>start the suspended job. </p>
<p><b></b></p>
<p><b> </b></p>
<p>NvM waits for underlying module to process a job: cancel the underlying module, </p>
<p>suspend the job, process the immediate priority job and finally re-start the suspended </p>
<p>job. </p>
<p>Before the suspended job can be re-started, all immediate priority jobs will be processed.  </p>
<p>NvM behaves the same for single and multi block jobs, i.e. a multi block job will also be </p>
<p>suspended and re-started after the immediate priority job is done. </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>Pay attention that only blocks with high priority (0) can be erased (by using API </p>
<p>NvM_EraseNvBlock</p>
<p>)! </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>4.4.10 </b></p>
<p><b>Asynchronous CRC Calculation </b></p>
<p>The </p>
<p>(re-)calculation </p>
<p>of </p>
<p>a </p>
<p>block’s </p>
<p>CRC </p>
<p>is </p>
<p>done </p>
<p>asynchronously </p>
<p>by </p>
<p>the </p>
<p>NvM_MainFunction()</p>
<p>. A CRC protected block’s CRC value is calculated every time the </p>
<p>block shall be written to NV memory. If a block is read from NV memory the CRC value is </p>
<p>recalculated and compared to the one that was just read from NV memory. If configuration </p>
<p>option ‘Calculate RAM CRC’  was enabled for a block, its recently calculated CRC value </p>
<p>will be stored in RAM for later use. </p>
<p>If </p>
<p>NvM_SetRamBlockStatus(TRUE)</p>
<p> is called, the re-calculation of the CRC value over </p>
<p>the RAM block’s data will also be initiated, if ‘Calculate RAM CRC’ was enabled for this </p>
<p>block. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 5.07.01 </p>
<p>29 </p>
<p>based on template version 3.01 </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>The purpose of requesting recalculation of the RAM CRC with every call to </p>
<p>NvM_SetRamBlockStatus</p>
<p> is to provide the possibility to re-use the RAM data even if </p>
<p>a reset (short power-loss, watchdog-reset) occurred. </p>
<p>NvM attempts so during </p>
<p>NvM_ReadAll</p>
<p> processing for all NVRAM blocks having ‘Read </p>
<p>during ReadAll’ and ‘Calc RAM CRC’ enabled in their configuration: If the block is </p>
<p>internally still marked as VALID, NVM calculates the CRC value over current RAM </p>
<p>block’s contents and compares it with the value stored elsewhere. If thy match it does </p>
<p>not touch RAM contents; rather NVM pretends having successfully read those values </p>
<p>from NV. </p>
<p><b> </b></p>
<p><b> </b></p>
<p>The CRC calculation is done in the cyclically called service </p>
<p>NvM_MainFunction()</p>
<p>. To be </p>
<p>able to split a CRC calculation job, the number of CRC bytes to be calculated during one </p>
<p>cycle can be configured via the configuration tool. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>If an AUTOSAR compliant CRC library implementation is used, the NVM ensures for all </p>
<p>supported CRC types that calculated values do not depend on the number of cycles </p>
<p>needed for calculation, i.e. for any number of calculation steps any CRC value is </p>
<p>guaranteed to be equal to the CRC value calculated over same data with one single </p>
<p>call to the appropriate library function. </p>
<p>For CRC32 this is a feature in NvM, beyond the requirements of AUTOSAR. </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>4.4.11 </b></p>
<p><b>Write Protection </b></p>
<p>The </p>
<p>NVM </p>
<p>supports </p>
<p>write </p>
<p>protection </p>
<p>of </p>
<p>any </p>
<p>NV </p>
<p>Block. </p>
<p>The </p>
<p>API </p>
<p>services </p>
<p>NvM_SetBlockProtection()</p>
<p> is used for locking and unlocking a NV block. The initial </p>
<p>write protection (after reset) can be configured. It will be set during </p>
<p>NvM_ReadAll()</p>
<p>. </p>
<p>A block can also be configured to be written once. The write protection of such a block </p>
<p>cannot be removed by an API call. Nevertheless, it is possible to rewrite such a block by </p>
<p>using the extended runtime preparation during </p>
<p>NvM_ReadAll()</p>
<p>. </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>Pay attention, for a dataset block configured as write once only one dataset can be </p>
<p>written. The other datasets can’t be written any more. The whole block is protected </p>
<p>after first write. </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>4.4.12 </b></p>
<p><b>Erase and Invalidate </b></p>
<p>There </p>
<p>are </p>
<p>two </p>
<p>services </p>
<p>specified </p>
<p>for </p>
<p>making </p>
<p>a </p>
<p>NV </p>
<p>block </p>
<p>unreadable: </p>
<p>NvM_EraseNvBlock()</p>
<p> and </p>
<p>NvM_InvalidateNvBlock().</p>
<p> </p>
<p>Invalidating  a  block  is  much  faster  than  erasing  the  block  because  only  the  status </p>
<p>information will be invalidated. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 5.07.01 </p>
<p>30 </p>
<p>based on template version 3.01 </p>
<p><b>4.4.13 </b></p>
<p><b>Init Block Callbacks </b></p>
<p>For any block ROM defaults (see 4.4.5.4) or an initialization callback can be configured. </p>
<p>The initialization callback is called every time the default values of the block have to be </p>
<p>loaded, e.g. during a restore block defaults service or for failed read jobs.  </p>
<p>In contrast to ROM defaults NvM does not update the RAM data itself, this shall be done </p>
<p>within the initialization callback. </p>
<p>The return value of the functions is specified but will not be used by the NVM. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note</b> </p>
<p><b>&gt; </b></p>
<p>Init callback is invoked when the related block is still busy, so no request shall </p>
<p>be issued until the block isn’t busy any more. </p>
<p><b>&gt; </b></p>
<p>During </p>
<p>NvM_ReadAll()</p>
<p> the initialization callback won’t be called, if the block is </p>
<p>configured  with  enabled </p>
<p>NvMUseServicePorts</p>
<p>.  This  will  be  done  because </p>
<p>during </p>
<p>the </p>
<p>NvM_ReadAll()</p>
<p> </p>
<p>the </p>
<p>RTE </p>
<p>is </p>
<p>not </p>
<p>initialed </p>
<p>yet </p>
<p>and </p>
<p>callback </p>
<p>invocations </p>
<p>could </p>
<p>lead </p>
<p>to </p>
<p>DET </p>
<p>error. </p>
<p>For </p>
<p>all </p>
<p>blocks </p>
<p>with </p>
<p>disabled </p>
<p>NvMUseServicePorts</p>
<p> the callbacks will be invoked during </p>
<p>NvM_ReadAll()</p>
<p> </p>
<p>without restrictions. </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>4.4.14 </b></p>
<p><b>Define Locking/ Unlocking Services </b></p>
<p>In preemptive systems, it is necessary to protect some actions of preemption. That means </p>
<p>that  a  few  NVM  internal  actions  need  to  be  atomic.  So  for  protecting  these  sequences </p>
<p>functions for entering and leaving such a critical section can be configured. By default the </p>
<p>Operating System (OS) services are used. </p>
<p>The  configuration  tool  can  be  used  to  define  or  configure  services  such  as  the  OSEK </p>
<p>services </p>
<p>GetResource(…)</p>
<p> and </p>
<p>ReleaseResource(…)</p>
<p> to lock and unlock resources. To </p>
<p>use these services of your Operating System, you must also publish the header file of the </p>
<p>Operating System via configuration tool (in the ‘MyECU’ window and the included tab ‘OS </p>
<p>Services’). </p>
<p><b>4.4.15 </b></p>
<p><b>Interrupts </b></p>
<p>When interrupts occur during write accesses, they do not corrupt already saved data or </p>
<p>data  to  be  written.  To  ensure  this,  these  critical  sections  have  to  be  locked,  which  is </p>
<p>configurable via configuration tool. </p>
<p><b>4.4.16 </b></p>
<p><b>Data Corruption </b></p>
<p>Write  operations  to  non-volatile  memories  are  non-atomic  operations.  A  power  supply </p>
<p>failure during write accesses may lead to corrupted/invalid data. Assuring that corrupted </p>
<p>data will not be signaled as valid is no more the task of the NVM but of the FEE or EA. </p>
<p><b>4.4.17 </b></p>
<p><b>Concurrent access to NV data for DCM </b></p>
<p>NVM </p>
<p>provides </p>
<p>possibility </p>
<p>to </p>
<p>access </p>
<p>NV </p>
<p>data </p>
<p>concurrently </p>
<p>with </p>
<p>NVM’s </p>
<p>applications. </p>
<p>Therefore each configured NVRAM block has an additional alias, the “DCM block”. </p>
<p>Aliases have following differences to normal NvM blocks: </p>
<p><b></b></p>
<p><b> </b></p>
<p>Aliases have the same configuration as the origin NvM blocks (e.g CRC or length) </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 5.07.01 </p>
<p>31 </p>
<p>based on template version 3.01 </p>
<p><b></b></p>
<p><b> </b></p>
<p>Aliases are treated as NVRAM blocks without permanent RAM block </p>
<p><b></b></p>
<p><b> </b></p>
<p>Aliases are neither read at start-up (during </p>
<p>NvM_ReadAll</p>
<p> processing) nor written at </p>
<p>shut-down (during </p>
<p>NvM_WriteAll</p>
<p> processing) </p>
<p><b></b></p>
<p><b> </b></p>
<p>explicit read or write requests must supply a reference to a temporary RAM block </p>
<p><b></b></p>
<p><b> </b></p>
<p>NvM_SetRamBlockStatus</p>
<p> invoked for an alias does not have any influence on </p>
<p>processing </p>
<p><b></b></p>
<p><b> </b></p>
<p>Only one asynchronous request for an alias can be queued at a time </p>
<p><b></b></p>
<p><b> </b></p>
<p>If one is already queued, the request will be rejected (API returns </p>
<p>E_NOT_OK</p>
<p>) </p>
<p><b></b></p>
<p><b> </b></p>
<p>NvM_GetErrorStatus</p>
<p> works for all aliases, no matter which alias ID is given to the </p>
<p>function.  </p>
<p><b></b></p>
<p><b> </b></p>
<p>There is only one job result for all aliases which is valid until the next alias is </p>
<p>requested </p>
<p><b></b></p>
<p><b> </b></p>
<p>NvM_SetDataIndex</p>
<p> and </p>
<p>NvM_GetDataIndex</p>
<p> work for all aliases, no matter which </p>
<p>alias ID is given to the functions </p>
<p><b></b></p>
<p><b> </b></p>
<p>NvM_SetBlockProtection</p>
<p> works for all aliases, no matter which alias ID is given to </p>
<p>the function </p>
<p>All jobs of DCM are always put into <b>Standard Job Queue</b>, even if blocks with immediate </p>
<p>priority are requested and job prioritization was enabled. So cancellation of pending jobs </p>
<p>by an immediate DCM-Block is avoided. The original priority itself is kept. </p>
<p>For </p>
<p>accessing </p>
<p>the </p>
<p>alias </p>
<p>of </p>
<p>a </p>
<p>NVRAM </p>
<p>block, </p>
<p>NVM </p>
<p>provides </p>
<p>the </p>
<p>global </p>
<p>macro </p>
<p>NvM_GetDcmBlockId(&lt;NvMBlockId&gt;)</p>
<p>  which  expects  the  origin  NVRAM  BlockId  as </p>
<p>parameter and returns the block’s alias of type </p>
<p>NvM_BlockIdType</p>
<p>.  </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>It is recommended that DCM accesses NVRAM data only via aliases. Otherwise the </p>
<p>DCM would be responsible for synchronization with every single NVM client (blocks’ </p>
<p>owners). </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>DCM should lock the block using </p>
<p>NvM_SetBlockLockStatus</p>
<p> (see chapter 6.4.8) </p>
<p>before requesting jobs (via the alias, especially write requests). In case of an error </p>
<p>during job processing, DCM should also unlock the block again. If job processing </p>
<p>completes successfully the block should remain locked; it will be automatically </p>
<p>unlocked after next start-up (</p>
<p>NvM_ReadAll</p>
<p> processing).  </p>
<p>A lock itself only affects the original block (i.e. the alias cannot be locked). </p>
<p><b>4.4.18 </b></p>
<p><b>Explicit synchronization mechanism between application and NVM </b></p>
<p>NvM  supports  an  optional  explicit  synchronization  mechanism  between  application  and </p>
<p>NvM.  It  is realized  by  a  RAM mirror in  the  NvM  module. The  data  is  transferred  by  the </p>
<p>application in both directions via callback routines, called by the NvM module. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 5.07.01 </p>
<p>32 </p>
<p>based on template version 3.01 </p>
<p>The synchronization mechanism can be configured for every NVRAM block separately. If </p>
<p>the synchronization mechanism is configured NvM uses the internal buffer as RAM mirror </p>
<p>between  NvM  and  application.  It  is  the  same  internal  buffer  which  is  used  for  Crc </p>
<p>calculation (see chapter 4.4.5.1). The size of the internal buffer is the size of the biggest </p>
<p>configured block plus configured Crc bytes. </p>
<p>If  the  synchronization  mechanism  is  configured,  both  NvMWriteRamBlockToNvM  and </p>
<p>NvMReadRamBlockFromNvM must be configured.  </p>
<p>It is not useful to configure a permanent RAM block for a block which uses the </p>
<p>synchronization mechanism. In this case the RAM block will be ignored. It is also not </p>
<p>recommended to configure an Init callback for a block using synchronization mechanism. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>If Explicit Synchronization was configured for a block, clients may modify RAM contents </p>
<p>(which are not visible to NVM) while block is pending. In this case take care they may </p>
<p>get overwritten when a pending read completes. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Basic Knowledge </b></p>
<p>By definition, this mechanism serves as permanent RAM block. </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Expert Knowledge </b></p>
<p><b>Calculate RAM CRC </b>and related fast re-validation of RAM data during </p>
<p>NvM_ReadAll</p>
<p> </p>
<p>processing cannot be used along with explicit synchronization mechanism. </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>4.4.18.1 </b></p>
<p><b>Explicit synchronization mechanism during write requests </b></p>
<p>After application issued </p>
<p>NvM_WriteBlock</p>
<p>, application might modify the RAM block until </p>
<p>callback  NvMWriteRamBlockToNvM  is  called  by  NvM.  If  NvMWriteRamBlockToNvM  is </p>
<p>called, application has to provide a consistent copy of the RAM block to the internal RAM </p>
<p>mirror. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>During calling NvMWriteRamBlockToNvM callback related block is still busy. No </p>
<p>request for it shall be issued as long as block is busy. </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>4.4.18.2 </b></p>
<p><b>Explicit synchronization mechanism during read requests </b></p>
<p>After  application  issued </p>
<p>NvM_ReadBlock</p>
<p>,  application  might  modify  the  RAM  block  until </p>
<p>the </p>
<p>routine </p>
<p>NvMReadRamBlockFromNvM </p>
<p>is </p>
<p>called </p>
<p>by </p>
<p>the </p>
<p>NvM. </p>
<p>If </p>
<p>NvMReadRamBlockFromNvM  is  called,  then  application  has  to  copy  the  data  from  the </p>
<p>internal RAM mirror to the RAM block.  </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 5.07.01 </p>
<p>33 </p>
<p>based on template version 3.01 </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>During calling NvMReadRamBlockFromNvM callback related block is still busy. No </p>
<p>request for it shall be issued as long as block is busy. </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>4.4.19 </b></p>
<p><b>CRC Compare Mechanism </b></p>
<p>In order to avoid unnecessary write operations in NV memory, if the NV data of a specific </p>
<p>RAM  block  was  not  updated  during  runtime,  the  NvM  module  offers  a  CRC  based </p>
<p>compare mechanism which can be applied while processing a write job. </p>
<p>That means, before writing data to NV memory NvM recalculates the CRC for current data </p>
<p>and compares the value with CRC of the previously read or written data (stored in RAM). </p>
<p>If the CRCs match NvM assumes the data has not been changed (is up to date with NV </p>
<p>memory) and doesn’t write but finishes the job successfully. </p>
<p>If the CRCs don’t match NvM assumes the data has been changed (is not up to date with </p>
<p>NV memory) and writes the data to NV RAM. </p>
<p>The mechanism can be enabled for NvM blocks via </p>
<p>NvMBlockUseCRCCompMechanism. </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>Keep in mind that it is possible to calculate the same CRC value for different data. In </p>
<p>that case NvM won’t write and the NV memory content is not up to date with RAM </p>
<p>content – user has to be able to operate with outdated data (after e.g. shutdown and </p>
<p>startup). </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>This feature affects not only the </p>
<p>NvM_WriteAll</p>
<p>, where writing depends on RAM block </p>
<p>status, but also the </p>
<p>NvM_WriteBlock</p>
<p> job – with enabled CRC Compare Mechanism </p>
<p>the </p>
<p>NvM_WriteBlock</p>
<p> won’t write, if the CRCs match. With disabled CRC Compare </p>
<p>Mechanism </p>
<p>NvM_WriteBlock</p>
<p> always writes the data. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 5.07.01 </p>
<p>34 </p>
<p>based on template version 3.01 </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>Same data for multiple datasets won’t be written, if </p>
<p>NvMBlockUseCRCCompMechanism</p>
<p> is enabled, because after the first dataset write, </p>
<p>the CRC matches the data and NvM skips the write to NV RAM. If writing is required, </p>
<p>enable the 4.1.1.1 Block Id check feature. </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>4.5 </b></p>
<p><b>Error Handling </b></p>
<p><b>4.5.1 </b></p>
<p><b>Development Error Reporting </b></p>
<p>By </p>
<p>default, </p>
<p>development </p>
<p>errors </p>
<p>are </p>
<p>reported </p>
<p>to </p>
<p>the </p>
<p>DET </p>
<p>using </p>
<p>the </p>
<p>service </p>
<p>Det_ReportError()</p>
<p> as</p>
<p> </p>
<p>specified in [3], if development error reporting is enabled (i.e. </p>
<p>pre-compile parameter </p>
<p>NVM_DEV_ERROR_DETECT == STD_ON)</p>
<p>. </p>
<p>The reported NVM ID can be seen here [chapter 3]. </p>
<p>The  reported  service  IDs  identify  the  services  which  are  described  in  6.4. The following </p>
<p>table presents the service IDs and the related services: </p>
<p><b>Service ID </b></p>
<p><b>Service </b></p>
<p>0x00 </p>
<p>NvM_Init() </p>
<p>0x01 </p>
<p>NvM_SetDataIndex() </p>
<p>0x02 </p>
<p>NvM_GetDataIndex() </p>
<p>0x03 </p>
<p>NvM_SetBlockProtection() </p>
<p>0x04 </p>
<p>NvM_GetErrorStatus() </p>
<p>0x05 </p>
<p>NvM_SetRamBlockStatus() </p>
<p>0x06 </p>
<p>NvM_ReadBlock() </p>
<p>0x07 </p>
<p>NvM_WriteBlock() </p>
<p>0x08 </p>
<p>NvM_RestoreBlockDefaults() </p>
<p>0x09 </p>
<p>NvM_EraseNvBlock() </p>
<p>0x0A </p>
<p>NvM_CancelWriteAll()       </p>
<p>0x0B </p>
<p>NvM_InvalidateNvBlock() </p>
<p>0x0C </p>
<p>NvM_ReadAll() </p>
<p>0x0D </p>
<p>NvM_WriteAll() </p>
<p>0x0E </p>
<p>NvM_MainFunction() </p>
<p>0x0F </p>
<p>NvM_GetVersionInfo() </p>
<p>0x10 </p>
<p>NvM_CancelJobs() </p>
<p>0x13 </p>
<p>NvM_SetBlockLockStatus() </p>
<p>Table 4-5  </p>
<p>Mapping of service IDs to services </p>
<p>The errors reported to DET are described in the following table: </p>
<p><b>Error Code </b></p>
<p><b>Description </b></p>
<p>0x14 </p>
<p>NVM_E_NOT_INITIALIZED </p>
<p>Every API service, except </p>
<p>NvM_Init()</p>
<p> and </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 5.07.01 </p>
<p>35 </p>
<p>based on template version 3.01 </p>
<p><b>Error Code </b></p>
<p><b>Description </b></p>
<p>NvM_GetVersionInfo(),</p>
<p> may check if NVM has </p>
<p>already been initialized. </p>
<p>0x15 </p>
<p>NVM_E_BLOCK_PENDING </p>
<p>As long as an asynchronous operation on a certain </p>
<p>Block has not been completed, no further requests </p>
<p>belonging to this Block are allowed.  </p>
<p>0x18 </p>
<p>NVM_E_BLOCK_CONFIG </p>
<p>This service is not possible with this configuration. </p>
<p>0x0A </p>
<p>NVM_E_PARAM_BLOCK_ID </p>
<p>NVM API services may check, whether the passed </p>
<p>BlockId</p>
<p> is in the allowed range. </p>
<p>0x0B </p>
<p>NVM_E_PARAM_BLOCK_ TYPE </p>
<p>NvM_SetDataIndex()</p>
<p> and </p>
<p>NvM_GetDataIndex()</p>
<p> are restricted to Dataset </p>
<p>bocks. If these functions are called with any other </p>
<p>bock type, this error code is produced. </p>
<p>NvM_RestoreBlockDefaults()</p>
<p> is restricted to </p>
<p>blocks configured with ROM defaults or an init </p>
<p>callback. </p>
<p>0x0C </p>
<p>NVM_E_PARAM_BLOCK_DATA_</p>
<p>IDX </p>
<p>NvM_SetDataIndex()</p>
<p> may check the range of the </p>
<p>passed </p>
<p>DataIndex</p>
<p>.  </p>
<p>0x0D </p>
<p>NVM_E_PARAM_ADDRESS </p>
<p>A wrong pointer parameter was passed. (</p>
<p>NULL_PTR</p>
<p> </p>
<p>passed in an asynchronous call, e.g. </p>
<p>NvM_WriteBlock()</p>
<p> for a non-permanent block) </p>
<p>0x0E </p>
<p>NVM_E_PARAM_DATA </p>
<p>A </p>
<p>NULL_PTR</p>
<p> was passed in one of the synchronous </p>
<p>functions </p>
<p>NvM_GetDataIndex()</p>
<p>, </p>
<p>NvM_GetErrorStatus()</p>
<p> or </p>
<p>NvM_GetVersionInfo().</p>
<p> </p>
<p>Table 4-6  </p>
<p>Errors reported to DET </p>
<p><b>4.5.1.1 </b></p>
<p><b>Parameter Checking </b></p>
<p>AUTOSAR requires that API functions check the validity of their parameters. The checks in </p>
<p>Table 4-7 are internal parameter checks of the API functions. </p>
<p>The following table shows which parameter checks are performed on which services: </p>
<p><b>Check </b></p>
<p> </p>
<p> </p>
<p> </p>
<p><b>Service </b></p>
<p>Module’s </p>
<p>initialization </p>
<p>Status check </p>
<p>Block’s Manage-</p>
<p>ment Type check </p>
<p>Block’s Pending </p>
<p>State check </p>
<p>Block Id check </p>
<p>DataIndex check </p>
<p>Pointers check </p>
<p>NvM_Init() </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>NvM_SetDataIndex() </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p> </p>
<p>NvM_GetDataIndex() </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p> </p>
<p></p>
<p> </p>
<p> </p>
<p></p>
<p> </p>
<p>NvM_SetBlockProtection() </p>
<p></p>
<p> </p>
<p> </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p> </p>
<p> </p>
<p>NvM_GetErrorStatus() </p>
<p></p>
<p> </p>
<p> </p>
<p> </p>
<p></p>
<p> </p>
<p> </p>
<p></p>
<p> </p>
<p>NvM_GetVersionInfo() </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p></p>
<p> </p>
<p>NvM_SetRamBlockStatus() </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 5.07.01 </p>
<p>36 </p>
<p>based on template version 3.01 </p>
<p><b>Check </b></p>
<p> </p>
<p> </p>
<p> </p>
<p><b>Service </b></p>
<p>Module’s </p>
<p>initialization </p>
<p>Status check </p>
<p>Block’s Manage-</p>
<p>ment Type check </p>
<p>Block’s Pending </p>
<p>State check </p>
<p>Block Id check </p>
<p>DataIndex check </p>
<p>Pointers check </p>
<p>NvM_SetBlockLockStatus() </p>
<p></p>
<p> </p>
<p> </p>
<p> </p>
<p></p>
<p> </p>
<p> </p>
<p> </p>
<p>NvM_ReadBlock() </p>
<p></p>
<p> </p>
<p> </p>
<p> </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p>NvM_WriteBlock() </p>
<p></p>
<p> </p>
<p> </p>
<p> </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p>NvM_RestoreBlockDefaults() </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p> </p>
<p></p>
<p> </p>
<p> </p>
<p></p>
<p> </p>
<p>NvM_EraseNvBlock() </p>
<p></p>
<p> </p>
<p> </p>
<p> </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p> </p>
<p>NvM_CancelWriteAll() </p>
<p></p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>NvM_InvalidateNvBlock() </p>
<p></p>
<p> </p>
<p> </p>
<p> </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p> </p>
<p>NvM_ReadAll() </p>
<p></p>
<p> </p>
<p> </p>
<p></p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>NvM_WriteAll() </p>
<p></p>
<p> </p>
<p> </p>
<p></p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>NvM_MainFunction() </p>
<p></p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>NvM_CancelJobs() </p>
<p></p>
<p> </p>
<p> </p>
<p> </p>
<p></p>
<p> </p>
<p> </p>
<p> </p>
<p>Table 4-7  </p>
<p>Development Error Checking: Assignment of checks to services </p>
<p><b>4.5.2 </b></p>
<p><b>Production Code Error Reporting </b></p>
<p>NvM checks and reports following error codes to DEM: </p>
<p><b>Error Code </b></p>
<p><b>Description </b></p>
<p>NVM_E_INTEGRITY_FAILED </p>
<p>API request integrity failed </p>
<p>NVM_E_REQ_FAILED </p>
<p>API request failed </p>
<p>NVM_E_WRITE_PROTECTED </p>
<p>NvM_WriteBlock</p>
<p>, </p>
<p>NvM_EraseNvBlock</p>
<p> and </p>
<p>NvM_InvalidateNvBlock</p>
<p> check, if the </p>
<p>block with specified BlockId is write-protected, </p>
<p>before it is written (or erased or invalidated). </p>
<p>NVM_E_QUEUE_OVERFLOW </p>
<p>All asynchronous requests can only be en-</p>
<p>queued if the queue is not full. </p>
<p>NVM_E_LOSS_OF_REDUNDANCY </p>
<p>One single block of a redundant block is </p>
<p>invalid. </p>
<p>Table 4-8  </p>
<p>Errors reported to DEM </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 5.07.01 </p>
<p>37 </p>
<p>based on template version 3.01 </p>
<p>According to AUTOSAR component specific DEM error codes must be configured in DEM, </p>
<p>NvM configuration references them. </p>
<p>To report production errors to DEM, NvM uses the </p>
<p>Dem_ReportErrorStatus</p>
<p> API which </p>
<p>has to be published via </p>
<p>Dem.h</p>
<p> (included if NvM references at least one DEM error code). </p>
<p>NvM </p>
<p>invokes </p>
<p>the </p>
<p>DEM </p>
<p>API </p>
<p>with </p>
<p>configured </p>
<p>error </p>
<p>code </p>
<p>and </p>
<p>the </p>
<p>status </p>
<p>DEM_EVENT_STATUS_FAILED</p>
<p>. </p>
<p>NvM </p>
<p>never </p>
<p>uses </p>
<p>the </p>
<p>status </p>
<p>DEM_EVENT_STATUS_PASSED.</p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>NvM does not report DEM errors without reference to DEM. If any DEM error reporting </p>
<p>is required, the NvM error code has to point to a DEM error code. </p>
<p><b> </b></p>
<p><b> </b></p>
<p>For more information about DEM see [4] </p>
<p><b>4.5.3 </b></p>
<p><b>Compile-time Block Length Checks </b></p>
<p>For each block with permanent RAM or ROM, NvM provides the Block Length Check to </p>
<p>ensure the configured block length and the permanent RAM’s/ROM’s length fits to each </p>
<p>other. </p>
<p>There are three different checks for permanent RAM </p>
<p><b>&gt; </b></p>
<p>Automatic  Block  Length  enabled  (see  4.1.2):  size  of  permanent  RAM  must  not </p>
<p>exceed the configured block length </p>
<p><b>&gt; </b></p>
<p>Strict  Block  Length:  configured  block  length  has  to  match  the  size  of  permanent </p>
<p>RAM exactly </p>
<p><b>&gt; </b></p>
<p>Non-strict  Block  Length:  configured  block  length  must  not  exceed  the  size  of </p>
<p>permanent RAM </p>
<p>And one for permanent ROM </p>
<p><b>&gt; </b></p>
<p>Non-strict  Block  Length:  configured  block  length  must  not  exceed  the  size  of </p>
<p>permanent ROM </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Basic Knowledge </b></p>
<p>To check the block length during compile time, NvM uses bitfields – those have to be </p>
<p>initialized with positive length. Once a bitfield is initialized with negative length (block </p>
<p>length check failed), compiler error shall occur and mark the corresponding line. </p>
<p> </p>
<p>Each length check shows all required information: block name, RAM symbol and what </p>
<p>is wrong with the block (depends on strict, non-strict or automatic block length) </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 5.07.01 </p>
<p>38 </p>
<p>based on template version 3.01 </p>
<p><b>5 </b></p>
<p><b>Integration </b></p>
<p>This chapter gives necessary information for the integration of the MICROSAR NVM into </p>
<p>an application environment of an ECU. </p>
<p><b>5.1 </b></p>
<p><b>Scope of Delivery </b></p>
<p>The delivery of the NVM contains the files which are described in the chapters 5.1.1 and </p>
<p>5.1.2: </p>
<p><b>5.1.1 </b></p>
<p><b>Static Files </b></p>
<p><b>File Name </b></p>
<p><b>Description </b></p>
<p>NvM.h </p>
<p>This file must not be modified by user. </p>
<p>Defines the interface of NVM. Only this file shall be included by the </p>
<p>application.</p>
<p> </p>
<p>NvM_Cbk.h </p>
<p>This file must not be modified by user. </p>
<p>Contains the declarations of the callback functions being invoked by </p>
<p>EEPROM driver </p>
<p>NvM_Types.h </p>
<p>This file must not be modified by user. </p>
<p>Defines general types used by NVM.</p>
<p> </p>
<p>NvM.c / </p>
<p>NvM.lib/NvM.a </p>
<p>This file must not be modified by user. </p>
<p>Implementation of NVM, delivered as object library. </p>
<p>NvM_Act / </p>
<p>NvM_Crc / </p>
<p>NvM_JobProc / </p>
<p>NvM_Qry / </p>
<p>NvM_Queue.c *.h </p>
<p>These are files for internal use of the NvM. </p>
<p>If NVM is delivered as object then this parts are content of NvM.lib. </p>
<p>Table 5-1  </p>
<p>Static files </p>
<p><b>5.1.2 </b></p>
<p><b>Dynamic Files </b></p>
<p>The  dynamic  files  are  generated  by  the  configuration  tool  DaVinci  Configurator.  Do  not </p>
<p>modify them manually. </p>
<p><b>File Name </b></p>
<p><b>Description </b></p>
<p>NvM_Cfg.c </p>
<p>It contains configuration parameters of NVM which can be modified after </p>
<p>compilation of </p>
<p>NvM.c</p>
<p>. </p>
<p>NvM_Cfg.h </p>
<p>Contains <b>public </b>configuration parameters of NVM. They are (or might be) </p>
<p>also important to NvM’s user(s), or they may affect NvM’s API </p>
<p>It contains also <b>public </b>types and symbol declarations to be used by NVM as </p>
<p>well as its user(s). </p>
<p>NvM_PrivateCfg.h </p>
<p>Contains parameters as well as type and symbol declarations, which are </p>
<p>private to the NvM, i.e. they only affect internal behavior. </p>
<p>This file is intended to be included only by NvM’s sources. </p>
<p>Table 5-2  </p>
<p>Generated files   </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 5.07.01 </p>
<p>39 </p>
<p>based on template version 3.01 </p>
<p><b>5.2 </b></p>
<p><b>Critical Sections </b></p>
<p>To protect critical code against interruptions NvM uses following critical section: </p>
<p><b>&gt; </b></p>
<p>NvM_NVM_EXCLUSIVE_AREA_0 </p>
<p><b>5.3 </b></p>
<p><b>Include Structure </b></p>
<p>The </p>
<p>following </p>
<p>figure </p>
<p>illustrates </p>
<p>the </p>
<p>hierarchy </p>
<p>of </p>
<p>included </p>
<p>files. </p>
<p>It </p>
<p>also </p>
<p>shows </p>
<p>that </p>
<p>Std_Types.h and Nvm.h must be included by the application. </p>
<p> </p>
<p> </p>
<p>Figure 5-1 </p>
<p>The file structure of the NVM sections module </p>
<p><b>5.4 </b></p>
<p><b>Compiler Abstraction and Memory Mapping  </b></p>
<p>The  objects  (e.g.  variables,  functions,  constants)  are  declared  by  compiler  independent </p>
<p>definitions  –  the  compiler  abstraction  definitions.  Each  compiler  abstraction  definition  is </p>
<p>assigned to a memory section. </p>
<p>The  following  table  contains  the  memory  section  names  and  the  compiler  abstraction </p>
<p>definitions of NVM and illustrates the relationship among each them. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 5.07.01 </p>
<p>40 </p>
<p>based on template version 3.01 </p>
<p><b>Compiler Abstraction </b></p>
<p><b>Definitions </b></p>
<p><b> </b></p>
<p> </p>
<p> </p>
<p><b>Memory Mapping </b></p>
<p><b>Sections </b></p>
<p>NVM_PRIVATE_CODE </p>
<p>NVM_PRIVATE_CONST </p>
<p>NVM_PRIVATE_DATA </p>
<p>NVM_FAST_DATA </p>
<p>NVM_PUBLIC_CODE </p>
<p>NVM_PUBLIC_CONST </p>
<p>NVM_APPL_CODE </p>
<p>NVM_APPL_CONST </p>
<p>NVM_APPL_DATA </p>
<p>NVM_CONFIG_CONST </p>
<p>NVM_CONFIG_DATA </p>
<p>NVM_START_SEC_CODE </p>
<p></p>
<p> </p>
<p> </p>
<p></p>
<p> </p>
<p> </p>
<p></p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>NVM_START_SEC_ </p>
<p>VAR_NOINIT_UNSPECIFIED </p>
<p> </p>
<p> </p>
<p></p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p></p>
<p> </p>
<p>NVM_START_SEC_VAR_NOINIT_8 </p>
<p> </p>
<p> </p>
<p>  </p>
<p></p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>NVM_START_SEC_VAR_UNSPECIFIED </p>
<p> </p>
<p> </p>
<p></p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>NVM_START_SEC_VAR_FAST_8 </p>
<p> </p>
<p> </p>
<p> </p>
<p>  </p>
<p></p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>NVM_START_SEC_ </p>
<p>CONST_UNSPECIFIED </p>
<p> </p>
<p></p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>NVM_START_SEC_CONST_8 </p>
<p> </p>
<p></p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>NVM_START_SEC_CONST_16 </p>
<p> </p>
<p></p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p></p>
<p> </p>
<p> </p>
<p>NVM_START_SEC_ </p>
<p>CONST_DESCRIPTOR_TABLE </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p></p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p></p>
<p> </p>
<p> </p>
<p>NVM_START_SEC_VAR_POWER_ON_I</p>
<p>NIT_UNSPECIFIED </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p></p>
<p> </p>
<p>Table 5-3  </p>
<p>Compiler abstraction and memory mapping </p>
<p>For  each  start  keyword,  there  is  a  stop  keyword. As  these  stop  keywords  are  used  to </p>
<p>restore the default section, the stop keywords do not need to be configured. </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>The size of the section NVM_START_SEC_CONST_DESCRIPTOR_TABLE depends </p>
<p>on the configuration settings. It makes sense to create an own section for this item if it </p>
<p>becomes too big to link it into the same page/section as the elements of the </p>
<p>MICROSAR NVM module. In this case the according memory modifier has to be used </p>
<p>in order to address the elements in this section. </p>
<p><b> </b></p>
<p><b> </b></p>
<p>Above </p>
<p>listed </p>
<p>section </p>
<p>keywords </p>
<p>are </p>
<p>compiler </p>
<p>dependent. </p>
<p>They </p>
<p>are </p>
<p>set </p>
<p>in </p>
<p>the </p>
<p>files </p>
<p>MemMap.h and Compiler.h/Compiler_Cfg.h. Compiler pragmas may be used to open and </p>
<p>close  a  special  memory  section. As  these pragmas  are  already  used  when  creating  the </p>
<p>NVM library (object code) these parameters are not link-time configurable. Libraries with </p>
<p>different settings can be obtained at Vector Informatik GmbH. Please refer to the Software </p>
<p>release notes (SRN) (or to the delivered MemMap.h, Compiler.h/Compiler_Cfg.h) for the </p>
<p>settings made for your delivery. </p>
<p>NVM_START_SEC_VAR_POWER_ON_INIT_UNSPECIFIED</p>
<p>  shall  be  mapped  to  a  section </p>
<p>that is guaranteed to be zeroed out after Power-On Reset (therefore it may be a normal </p>
<p>ZERO_INIT</p>
<p>  section,  being  zeroed  out  after  any  reset.  Make  sure  this  helds  true  for  all </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 5.07.01 </p>
<p>41 </p>
<p>based on template version 3.01 </p>
<p>kinds of variable data (esp. uninitialized). If necessary, create a special section (don’t map </p>
<p>to a common one). </p>
<p>NVM_START_SEC_VAR_UNSPECIFIED </p>
<p>shall </p>
<p>also </p>
<p>be </p>
<p>mapped </p>
<p>to </p>
<p>a </p>
<p>section </p>
<p>that </p>
<p>is </p>
<p>guaranteed to be zeroed out. It holds the variable </p>
<p>NvM_TaskState_t </p>
<p>which has to be </p>
<p>zero since NvM is not initialized. </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>The integrator has to make sure specific section related settings (</p>
<p>#pragma</p>
<p>s) cover <b>all </b></p>
<p>(intended) variables defined within in a particular specific section. (It might be desired, </p>
<p>and possible with a compiler to further divide variables, e.g. by type/size/alignment </p>
<p>requirements). </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Expert Knowledge </b></p>
<p>It is important to understand that a variable declaration lacking an initializer does not </p>
<p>actually mean an uninitialized variable (unless the variable has <i>automatic storage </i></p>
<p><i>duration)</i>. </p>
<p>Instead, according to ANSI/ISO, every <i>object that has static storage duration is not </i></p>
<p><i>initialized explicitly </i>(ISO/IEC 9899:1999 chapter 6.7.8 clause 10) shall <b>be initialized </b></p>
<p>(according to the rules defined there). Technically, they shall be initialized to 0 </p>
<p>However, how a compiler achieves it, is beyond the standard. It is also beyond the </p>
<p>standard, how compilers map variables to sections, what default sections they define, </p>
<p>etc. </p>
<p>A compiler may treat a variable explicitly initialized to 0 like an “uninitialized” variable, it </p>
<p>may treat it like an initialized variable, or it may even treat it completely differently (e.g. </p>
<p>some compilers can be setup to emit all explicitly initialized variables to a section </p>
<p>“.zbss”, in contrast to “.data” and “.bss”, used for initialized, and uninitialized variables, </p>
<p>respectively”. </p>
<p>Therefore, any section definition (</p>
<p>#pragma</p>
<p>s) should consider all variables (regardless </p>
<p>of existence of an explicit initializer, and/or eventually other differentiations a compiler </p>
<p>might provide), unless there’s a good reason to exclude some of them. </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>The sections mentioned above have to fit to the linker configuration (linker command </p>
<p>file) as well as to the memory modifier settings in the Compiler Abstraction! </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>5.5 </b></p>
<p><b>Dependencies on SW Modules </b></p>
<p><b>5.5.1 </b></p>
<p><b>OSEK / AUTOSAR OS </b></p>
<p>An  OS  environment  is  not  necessary  unless  it  is  used  for  interrupt  or  resource  locking </p>
<p>issues. </p>
<p><b>5.5.2 </b></p>
<p><b>DEM </b></p>
<p>NvM reports runtime errors to DEM. For more information see chapter 4.5.2. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 5.07.01 </p>
<p>42 </p>
<p>based on template version 3.01 </p>
<p><b>5.5.3 </b></p>
<p><b>DET </b></p>
<p>Module  DET:  Can  be  used  in  development  mode.  It  records  all  development  errors  for </p>
<p>evaluation  purposes.  Its  usage  can  be  enabled/disabled  via  configuration  tool  by  the </p>
<p>switch <b>Development Error Reporting</b>. </p>
<p><b>5.5.4 </b></p>
<p><b>MEMIF </b></p>
<p>The NVM uses configuration parameters defined by the MEMIF. </p>
<p><b>5.5.5 </b></p>
<p><b>CRC Library </b></p>
<p>For  CRC  calculations  the  NVM  uses  the  services  provided  by  an AUTOSAR  compliant </p>
<p>CRC Library. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>Since the <b>Configuration Id Block </b>must be configured with either CRC16 or CRC32; </p>
<p>you will always need the CRC library. </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>5.5.6 </b></p>
<p><b>Callback Functions </b></p>
<p>MICROSAR  NVM  offers  the  usage  of  notifications  that  can  be  mapped  to  callback </p>
<p>functions  provided  by  other modules,  in  order  to  inform  them  about  job  completion.  For </p>
<p>each  NVRAM  block  a  separate  callback  function  may  be  defined  by  application.  These </p>
<p>callback function declarations must be made within the application and be included by the </p>
<p>NVM. </p>
<p><b>5.5.7 </b></p>
<p><b>RTE </b></p>
<p>When  at  least  one  Service </p>
<p>Port  is  enabled  and  corresponding  PIM  (see  Technical </p>
<p>Reference </p>
<p>of </p>
<p>RTE) </p>
<p>is </p>
<p>available, </p>
<p>all </p>
<p>additional </p>
<p>necessary </p>
<p>header </p>
<p>files </p>
<p>are </p>
<p>included </p>
<p>automatically. SWC must not include </p>
<p>NvM.h.</p>
<p> </p>
<p><b>5.5.8 </b></p>
<p><b>BSWM </b></p>
<p>If the switch <b>BSWM Multi Block Job Status Information </b>is enabled the NVM shall inform </p>
<p>the </p>
<p>BSWM </p>
<p>about </p>
<p>the </p>
<p>current </p>
<p>state </p>
<p>of </p>
<p>a </p>
<p>multi </p>
<p>block </p>
<p>job </p>
<p>via </p>
<p>BswM_NvM_CurrentJobMode()</p>
<p>. The multi job callback is not called. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>During calling </p>
<p>BswM_NvM_CurrentJobMode()</p>
<p>, if called with status</p>
<p> </p>
<p>NVM_REQ_PENDING, </p>
<p>callback related block is still busy. No request for it shall be </p>
<p>issued as long as block is busy. </p>
<p><b> </b></p>
<p><b> </b></p>
<p>If the switch <b>BSWM Block Status Information </b>for a single block is true, the NVM shall </p>
<p>inform </p>
<p>the </p>
<p>BSWM </p>
<p>about </p>
<p>the </p>
<p>current </p>
<p>state </p>
<p>of </p>
<p>the </p>
<p>block </p>
<p>via </p>
<p>BswM_NvM_CurrentBlockMode()</p>
<p>. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 5.07.01 </p>
<p>43 </p>
<p>based on template version 3.01 </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>During calling </p>
<p>BswM_NvM_CurrentBlockMode(),</p>
<p>if called with status</p>
<p> </p>
<p>NVM_REQ_PENDING, </p>
<p>callback related block is still busy. No request for it shall be </p>
<p>issued as long as block is busy. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>5.6 </b></p>
<p><b>Integration Steps </b></p>
<p>To integrate MICROSAR NVM into your system, several steps beginning with configuration </p>
<p>have to be done: </p>
<p><b>&gt; </b> Configure MICROSAR NVM and MICROSAR MEMIF according to applications’ </p>
<p>requirements using MICROSAR configuration tool or a GCE editor.  </p>
<p><b>&gt; </b> Generate the configuration files of the modules NVM and MEMIF. </p>
<p><b>&gt; </b> Configure and generate the lower modules FEE/EA and the driver modules for </p>
<p>FLS/EEP. </p>
<p><b>&gt; </b> If a FEE or EA module is used that is not delivered by Vector, make sure that the </p>
<p>parameters that are exchanged between the two modules are consistent. </p>
<p><b>&gt; </b> Each application is responsible to make their RAM and ROM blocks available (do not </p>
<p>use the static modifier!). The MICROSAR NVM includes the file that declares these </p>
<p>blocks and defines memory modifier to address the blocks. This memory modifier can </p>
<p>be changed in the </p>
<p>Compiler.h</p>
<p>. </p>
<p><b>&gt; </b> Make sure all applications using MICROSAR NVM include </p>
<p>Std_Types.h</p>
<p> and </p>
<p>NvM.h</p>
<p> </p>
<p>(in that order). </p>
<p><b>&gt; </b> Check the initialization of the drivers FLS/EEP, FEE/EA and the MICROSAR NVM </p>
<p>(MICROSAR NVM does not initialize any other module). </p>
<p><b>&gt; </b> Make sure that the initialization sequence is correct. FEE/EA and FLS/EEP must be </p>
<p>initialized before any NVM request (usually </p>
<p>NvM_ReadAll()</p>
<p>) can be used. Take care </p>
<p>initialization sequence of FEE/EA must be finished until FEE/EA is able to accept a job </p>
<p>from NvM. In case Fee_MainFunction calls and/or Fls_MainFunction calls are </p>
<p>necessary to finish initialization process for FEE/EA the calls have to be executed </p>
<p>before NvM requests the first job to FEE/EA.  </p>
<p><b>&gt; </b> Ensure that the main functions of the NVM, the FEE/EA and the FLS/EEP drivers are </p>
<p>called cyclically. This must be done within an application task running at sufficient </p>
<p>priority (to avoid starving). </p>
<p><b>&gt; </b> Ensure that a waiting task frees CPU to make it possible that the action for the task is </p>
<p>waiting for, can be done! </p>
<p>Finally: Compile and link your MICROSAR NVM together with your project. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 5.07.01 </p>
<p>44 </p>
<p>based on template version 3.01 </p>
<p><b>5.7 </b></p>
<p><b>Estimating Resource Consumption </b></p>
<p>Besides resources needed anyway when using NVM, there are some configuration options </p>
<p>influencing  resource  consumption  of  your system.  In  general  these  options affect  usage </p>
<p>independently  of  the  number  of  configured  NVRAM  blocks.  Additionally  each  NVRAM </p>
<p>block requires resources in RAM, ROM and NV, respectively. The following sections will </p>
<p>summarize the options and give you hints, how to estimate their effects. </p>
<p><b>5.7.1 </b></p>
<p><b>RAM Usage </b></p>
<p>In general, each NVRAM block consumes RAM – for the application-defined RAM-block as </p>
<p>well as for the internal block management structure, which holds information about request </p>
<p>results, blocks’ attributes and its current data index. The amount of RAM occupied by the </p>
<p>RAM  block  itself  should  be  equal  to  the  configured  length.  However,  the  actual  size </p>
<p>depends  on  the  size  of  the  object  (variable)  the  application  declares.  The  size  of  each </p>
<p>management area is currently 3 bytes. </p>
<p>However, though they need to be considered when estimating (overall) RAM consumption, </p>
<p>RAM blocks technically belong to the clients of NVM. </p>
<p>The configuration options affecting RAM consumption pertain to size of the queue(s) and </p>
<p>the option job prioritization. The size of one queue entry depends on the target platform </p>
<p>and the compiler options used. It ranges from 8 bytes (16 bit platform, 16bit pointers) to 12 </p>
<p>bytes (32bit architectures, aligned structure members). </p>
<p>Additionally the setting <b>Internal Buffer for Crc Handling </b>affects RAM usage: If enabled, </p>
<p>the NVM internally allocates a RAM buffer. Its size is at least the size of largest NVRAM </p>
<p>block configured with CRC, including CRC size. Sizes of NVRAM Blocks configured with </p>
<p><b>Use  Synchronisation  Mechanism</b>,  will  also  be  considered  in  calculation  of  internal </p>
<p>buffer’s size. </p>
<p>Additionally, each NVRAM block with <b>Calc RAM Block CRC </b>gets a dedicated RAM area </p>
<p>for CRC storage, exactly matching CRC’s size. As a result, applications’ RAM blocks do </p>
<p>not </p>
<p>need </p>
<p>to </p>
<p>provide </p>
<p>additional </p>
<p>space </p>
<p>for </p>
<p>CRC. </p>
<p>Therefore </p>
<p>it </p>
<p>does </p>
<p>not </p>
<p>affect </p>
<p>RAM </p>
<p>consumption. </p>
<p><b>5.7.2 </b></p>
<p><b>ROM Usage </b></p>
<p>Because each NVRAM block’s configuration is compiled into a constant block descriptor, </p>
<p>the  ROM  needed  is  also  affected  by  the  whole  number  of  configured  NVRAM  blocks. </p>
<p>Again, the size of one descriptor varies with the target platform and the compiler options </p>
<p>used.  </p>
<p>There are some configuration options affecting NVM code size. The options  </p>
<p><b>&gt; </b> Development mode </p>
<p><b>&gt; </b> API configuration class </p>
<p><b>&gt; </b> use Version Info API </p>
<p><b>&gt; </b> use Set Ram Block Status API </p>
<p>result in switching on/off complete code sections. </p>
<p>NVM’s  ROM  usage <b> does  not </b> depend  on  block  configured  with  ROM  defaults.  ROM </p>
<p>default blocks (defining default data) belong to the clients of NVM, as any callbacks do.  </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 5.07.01 </p>
<p>45 </p>
<p>based on template version 3.01 </p>
<p><b>5.7.3 </b></p>
<p><b>NV Usage </b></p>
<p>The requirements on NV memory space per device are affected by the NVRAM blocks and </p>
<p>their configuration. Basically, each NV block allocates as many bytes as specified for its </p>
<p>length,  plus  CRC  bytes  (if  configured).  Underlying  components  (FEE  or  EA)  would  also </p>
<p>add  internal  management  information,  as  well  as  padding  bytes  to  meet  NV  memory </p>
<p>device’s alignment requirements. </p>
<p>According to the management type of the NVRAM block, it consists of one or more blocks </p>
<p>consuming NV space: </p>
<p><b>&gt; </b> NATIVE  </p>
<p> </p>
<p> </p>
<p> </p>
<p>1 NV Block </p>
<p><b>&gt; </b> REDUNDANT </p>
<p>2 NV Blocks </p>
<p><b>&gt; </b> DATASET  </p>
<p> </p>
<p> </p>
<p><b>Count </b>NV Blocks </p>
<p><b>5.8 </b></p>
<p><b>How-To: Integrate NVM with AUTOSAR3 SWC’s </b></p>
<p>Embedded Interface of ASR4 NVM is NOT compatible with ASR3; especially return types </p>
<p>have been changed. </p>
<p>However, RTE encapsulates all of them: If an SWC calls a C/S-Interface’s operation (via </p>
<p>RTE), it always gets </p>
<p>Std_ReturnType</p>
<p>. </p>
<p>Finally, existing embedded code – SWCs as well as NVM itself – compiles against these </p>
<p>changed interfaces without modifications. </p>
<p>Unfortunately, to achieve this embedded compatibility, SWC-descriptions (which instruct </p>
<p>the RTE generator, how to create compatible code) slightly differ between AUTOSAR </p>
<p>services. Users will have to adapt their clients’ interface references in order to use </p>
<p>AUTOSAR4 BSW along with AUTOSAR3 SWCs. </p>
<p><b>5.8.1 </b></p>
<p><b>NVM’s provided Interfaces/Ports. </b></p>
<p>Every interface used by client SWCs needs to be remapped. </p>
<p><b>5.8.1.1 </b></p>
<p><b>NvMAdministration </b></p>
<p>The only operation – </p>
<p>SetBlockProtection</p>
<p> – changed from </p>
<p>POSSIBLE-ERRORS() </p>
<p>to </p>
<p>POSSIBLE-ERRORS(E_NOT_OK).</p>
<p> </p>
<p>This definition may be exchanged at R-Port side, because the embedded software already </p>
<p>used </p>
<p>Std_ReturnType</p>
<p> (and </p>
<p>E_OK</p>
<p>/</p>
<p>E_NOT_OK</p>
<p>), due to RTE API. Code should have been </p>
<p>implemented in a defensive way, i.e. it should check return values. </p>
<p>However, this operation can only fail, if development error detection was enabled. </p>
<p><b>5.8.1.2 </b></p>
<p><b>NvMService_AC[1|2|3][_SRBS][_Defs] </b></p>
<p>For information about naming, please refer to 7.1.4 </p>
<p>Return types (</p>
<p>POSSIBLE-ERRORS</p>
<p>) of following operations changed: </p>
<p><b>&gt;</b></p>
<p><b> </b></p>
<p>GetErrorStatus </p>
<p><b>&gt;</b></p>
<p><b> </b></p>
<p>GetDataIndex </p>
<p><b>&gt;</b></p>
<p><b> </b></p>
<p>SetDataIndex </p>
<p><b>&gt;</b></p>
<p><b> </b></p>
<p>SetRamBlockStatus </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 5.07.01 </p>
<p>46 </p>
<p>based on template version 3.01 </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>NvM_SetDataIndex</p>
<p> and </p>
<p>NvM_GetDataIndex</p>
<p> may fail if “Development Error </p>
<p>Detection” is disabled. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p>Similar to NvMAdministration interface, clients’ R-Port Prototypes must be associated with </p>
<p>these new interfaces. The implications on Runnables’ implementations are the same as </p>
<p>above – no changes are necessary. </p>
<p><b>5.8.2 </b></p>
<p><b>Callbacks (Ports provided by client SWCs) </b></p>
<p>Actually, callbacks specifications did not change from AUTOSAR3 to AUTOSAR4. </p>
<p>However,  a  recent  feature  added  to  DaVinci  Developer  and  RTE  Generator  allows  for </p>
<p>more flexibility in modeling and implementing callback’ signatures. Refer to chapter 7.1.5 </p>
<p>for  information  the  relationship  between  modelled  callbacks  (SWC’s  P-Ports)  and  their </p>
<p>RUNNABLEs’ prototypes. </p>
<p><b>5.8.3 </b></p>
<p><b>Request Result Types </b></p>
<p>In AUTOSAR4 new values for </p>
<p>NvM_RequestResultType</p>
<p> have been defined, namely </p>
<p>NVM_REQ_REDUNDANCY_FAILED</p>
<p> and </p>
<p>NVM_REQ_RESTORED_FROM_ROM</p>
<p>. </p>
<p>However, since their actual usage is not specified, they will not be used by NVM; its </p>
<p>interface description omits them, and clients do not need to deal with them.  </p>
<p>Finally, NvM uses the same set of request result values that was specified in AUTOSAR3. </p>
<p>Therefore, this change in specification does not require any actions. </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 5.07.01 </p>
<p>47 </p>
<p>based on template version 3.01 </p>
<p><b>6 </b></p>
<p><b>API Description </b></p>
<p><b>6.1 </b></p>
<p><b>Interfaces Overview </b></p>
<p>For an interfaces overview please see Figure 3-2. </p>
<p><b>6.2 </b></p>
<p><b>Type Definitions </b></p>
<p><b>Type Name </b></p>
<p><b>C-Type </b></p>
<p><b>Description </b></p>
<p><b>Value Range </b></p>
<p>NvM_RequestResult </p>
<p>Type </p>
<p>uint8 </p>
<p>An asynchronous API </p>
<p>service can have following </p>
<p>results or status that can </p>
<p>be polled by </p>
<p>NvM_GetErrorStatus</p>
<p>()</p>
<p>. </p>
<p>NVM_REQ_OK (see chapter </p>
<p>4.5.1) </p>
<p>The last asynchronous request has </p>
<p>been finished successfully. This is the </p>
<p>default value after reset. This status </p>
<p>has the value 0. </p>
<p>Can be delivered by all asynchronous </p>
<p>APIs. </p>
<p>NVM_REQ_NOT_OK (see </p>
<p>chapter 4.5.1) </p>
<p>The last asynchronous request has </p>
<p>been finished unsuccessfully. </p>
<p>Can be delivered by all asynchronous </p>
<p>APIs. </p>
<p>NVM_REQ_PENDING (see </p>
<p>chapter 4.5.1) </p>
<p>An asynchronous request is currently </p>
<p>being processed by the task. </p>
<p>Can be delivered by all asynchronous </p>
<p>APIs.</p>
<p> </p>
<p>NVM_REQ_INTEGRITY_FAILED </p>
<p>(see chapter 4.5.1) </p>
<p>A NV block was supposed to be valid </p>
<p>but it turned out that the data are </p>
<p>corrupted (either CRC mismatch or the </p>
<p>FEE or the EA reported an </p>
<p>inconsistency). </p>
<p>Can be delivered by NvM_ReadBlock </p>
<p>or NvM_ReadAll.</p>
<p> </p>
<p>NVM_REQ_BLOCK_SKIPPED (see </p>
<p>chapter 4.5.1) </p>
<p>The block was skipped during a multi </p>
<p>block request. </p>
<p>Can be delivered by NvM_ReadAll and </p>
<p>NvM_WriteAll.</p>
<p> </p>
<p>NVM_REQ_NV_INVALIDATED </p>
<p>(see chapter 4.5.1) </p>
<p>The NV block is marked as invalid. </p>
<p>Can be delivered by NvM_ReadBlock </p>
<p>or NvM_ReadAll.</p>
<p> </p>
<p>NVM_REQ_CANCELLED (see </p>
<p>chapter 4.5.1) </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 5.07.01 </p>
<p>48 </p>
<p>based on template version 3.01 </p>
<p><b>Type Name </b></p>
<p><b>C-Type </b></p>
<p><b>Description </b></p>
<p><b>Value Range </b></p>
<p>The last asynchronous </p>
<p>NvM_WriteAll() </p>
<p>has been </p>
<p> </p>
<p>cancelled by </p>
<p>NvM_CancelWriteAll().</p>
<p> </p>
<p>NvM_BlockIdType </p>
<p>uint16 </p>
<p>It is the type of a block </p>
<p>handle that is used by the </p>
<p>application in order to </p>
<p>access a NVM block. There </p>
<p>are two reserved IDs: </p>
<p><b>&gt; </b></p>
<p>Block ID 0 for multi </p>
<p>block requests (Block ID </p>
<p>0 is only allowed for API </p>
<p>NvM_GetErrorStatus()) </p>
<p>and </p>
<p><b>&gt; </b></p>
<p>Block ID 1 for the </p>
<p>configuration Id block </p>
<p>The block handles are </p>
<p>created as defines in an </p>
<p>ascending define list. </p>
<p> </p>
<p> </p>
<p>{</p>
<p>[</p>
<p>0. .2</p>
<p>𝑛</p>
<p>[</p>
<p>,</p>
<p>]</p>
<p>2</p>
<p>15</p>
<p>. . 2</p>
<p>15</p>
<p>+ 2</p>
<p>𝑛</p>
<p>[</p>
<p>,</p>
<p> 𝑛 = 16 − NVM_DATASET_SELECTION_BITS</p>
<p>}</p>
<p> </p>
<p> </p>
<p>NVM_DATASET_SELECTION_BITS</p>
<p> </p>
<p>is the maximum number of bits that are </p>
<p>needed in order to store the maximum </p>
<p>dataset value. </p>
<p>The second range describes each </p>
<p>block’s DCM alias. Block ID 0 does not </p>
<p>have such an alias. </p>
<p>Example: </p>
<p>The dataset block with the greatest </p>
<p>number of datasets has six of them. So </p>
<p>it is necessary to store the data index </p>
<p>0…5 to select the appropriate dataset </p>
<p>block. To store the value five, three bits </p>
<p>are necessary. So </p>
<p>NVM_DATASET_SELECTION_BITS</p>
<p> has </p>
<p>the value 3. </p>
<p>This means that only the block IDs </p>
<p>0 … 8191 are available as block </p>
<p>handles. Additionally NVM provides </p>
<p>access to these IDs’ block aliases via </p>
<p>handles 32768+1 … 32768+8191</p>
<p> </p>
<p>NvM_ServiceIdType </p>
<p>uint8 </p>
<p>Service Ids of the different </p>
<p>service routines of the </p>
<p>NVM. </p>
<p>NVM_INIT (0u) </p>
<p>NVM_SET_DATA_INDEX (1u) </p>
<p>NVM_GET_DATA_INDEX (2u) </p>
<p>NVM_SET_BLOCK_PROTECTION </p>
<p>(3u) </p>
<p>NVM_GET_ERROR_STATUS (4u) </p>
<p>NVM_SET_RAM_BLOCK_STATUS </p>
<p>(5u) </p>
<p>NVM_READ_BLOCK (6u) </p>
<p>NVM_WRITE_BLOCK (7u) </p>
<p>NVM_RESTORE_BLOCK_DEFAULTS </p>
<p>(8u) </p>
<p>NVM_ERASE_BLOCK (9u) </p>
<p>NVM_CANCEL_WRITE_ALL (10u) </p>
<p>NVM_INVALIDATE_NV_BLOCK </p>
<p>(11u) </p>
<p>NVM_READ_ALL (12u) </p>
<p>NVM_WRITE_ALL (13u) </p>
<p>NVM_MAINFUNCTION (14u) </p>
<p>NVM_GET_VERSION_INFO (15u) </p>
<p>NVM_SET_BLOCK_LOCK_STATUS </p>
<p>(16u) </p>
<p>The single values are applied as </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 5.07.01 </p>
<p>49 </p>
<p>based on template version 3.01 </p>
<p><b>Type Name </b></p>
<p><b>C-Type </b></p>
<p><b>Description </b></p>
<p><b>Value Range </b></p>
<p>defines. </p>
<p>See also chapter 4.5.1 </p>
<p>Table 6-1  </p>
<p>Type definitions </p>
<p><b>6.3 </b></p>
<p><b>Global API Constants </b></p>
<p>These  NVM  specific  constants  are  available  through  the  inclusion  of </p>
<p>NvM.h</p>
<p>.  They  are </p>
<p>configurable within DaVinci Configurator Pro. </p>
<p><b>&gt; </b></p>
<p>NVM_COMPILED_CONFIG_ID</p>
<p>: configured identifier for the NV memory layout  </p>
<p><b>&gt; </b></p>
<p>NVM_NO_OF_BLOCK_IDS</p>
<p>: number of all defined NVRAM Blocks (including reserved </p>
<p>blocks) </p>
<p><b>&gt; </b> Name of the NVRAM blocks </p>
<p><b>6.4 </b></p>
<p><b>Services provided by NVM </b></p>
<p>The NVM API consists of services, which are realized by function calls. </p>
<p><b>6.4.1 </b></p>
<p><b>NvM_Init </b></p>
<p><b>Prototype </b></p>
<p>void NvM_Init ( void ) </p>
<p><b>Parameter </b></p>
<p>-- </p>
<p>-- </p>
<p><b>Return code </b></p>
<p>void </p>
<p>-- </p>
<p><b>Functional Description </b></p>
<p>Service for basic NVM initialization. The time consuming NVRAM block initialization and setup according to </p>
<p>the block descriptor is done by the </p>
<p>NvM_ReadAll</p>
<p> request. </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>This service is synchronous. </p>
<p><b>&gt; </b></p>
<p>This service is non re-entrant. </p>
<p><b>&gt; </b></p>
<p>This service is always available. </p>
<p>Expected Caller Context </p>
<p><b>&gt; </b></p>
<p>This service is expected to be called in application context. </p>
<p><b>&gt; </b></p>
<p>It is expected to be exclusively called by ECU State Manager (or a comparable component) </p>
<p>Table 6-2  </p>
<p>NvM_Init </p>
<p><b>6.4.2 </b></p>
<p><b>NvM_SetDataIndex </b></p>
<p><b>Prototype </b></p>
<p>Std_ReturnType NvM_SetDataIndex ( NvM_BlockIdType BlockId,  </p>
<p>                                  uint8 DataIndex ) </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 5.07.01 </p>
<p>50 </p>
<p>based on template version 3.01 </p>
<p><b>Parameter </b></p>
<p>BlockId </p>
<p>The Block identifier. </p>
<p>DataIndex </p>
<p>Index position of a Block in the NV Block of Dataset type. </p>
<p><b>Return code </b></p>
<p>E_OK </p>
<p>Request has been accepted. </p>
<p>E_NOT_OK </p>
<p>Request has not been accepted, e.g. Det error occurred. </p>
<p><b>Functional Description </b></p>
<p>The request sets the specified index to associate a dataset NV block (with/without ROM blocks) with its </p>
<p>corresponding RAM block. The </p>
<p>DataIndex</p>
<p> needs to have a valid value before a read/write/erase or </p>
<p>invalidate request is initiated. </p>
<p>If the dataset block has a set of ROM defaults, this function is used (prior to </p>
<p>NvM_ReadBlock()</p>
<p>) to select </p>
<p>the appropriate ROM set.  </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>This service is synchronous. </p>
<p><b>&gt; </b></p>
<p>This service is re-entrant. </p>
<p><b>&gt; </b></p>
<p>This service is available if API configuration class 2 or 3 is configured.  </p>
<p><b>&gt; </b></p>
<p>The NVRAM manager shall have been initialized before this request is called. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>Usage of Explicit Synchronization, does not permit NvM’s clients to issue new requests for a </p>
<p>pending block.</p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p>Expected Caller Context </p>
<p><b>&gt; </b></p>
<p>This service is expected to be called in application context. </p>
<p>Table 6-3  </p>
<p>NvM_SetDataIndex </p>
<p><b>6.4.3 </b></p>
<p><b>NvM_GetDataIndex </b></p>
<p><b>Prototype </b></p>
<p>Std_ReturnType NvM_GetDataIndex ( NvM_BlockIdType BlockId,  </p>
<p>                                  uint8* DataIndexPtr ) </p>
<p><b>Parameter </b></p>
<p>BlockId </p>
<p>The Block identifier. </p>
<p>DataIndexPtr </p>
<p>Address where the current DataIndex shall be written to </p>
<p><b>Return code </b></p>
<p>E_OK </p>
<p>Request has been accepted. </p>
<p>E_NOT_OK </p>
<p>Request has not been accepted, e.g. Det error occurred. </p>
<p><b>Functional Description </b></p>
<p>The request passes the current DataIndex (association) of the specified dataset block. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 5.07.01 </p>
<p>51 </p>
<p>based on template version 3.01 </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>This service is synchronous. </p>
<p><b>&gt; </b></p>
<p>This service is re-entrant. </p>
<p><b>&gt; </b></p>
<p>This service is available if API configuration class 2 or 3 is configured.  </p>
<p><b>&gt; </b></p>
<p>The NVRAM manager shall have been initialized before this request is called. </p>
<p>Expected Caller Context </p>
<p><b>&gt; </b></p>
<p>This service is expected to be called in application context. </p>
<p>Table 6-4  </p>
<p>NvM_GetDataIndex </p>
<p><b>6.4.4 </b></p>
<p><b>NvM_SetBlockProtection </b></p>
<p><b>Prototype </b></p>
<p>Std_ReturnType NvM_SetBlockProtection( NvM_BlockIdType BlockId,  </p>
<p>                                       boolean ProtectionEnabled ) </p>
<p><b>Parameter </b></p>
<p>BlockId </p>
<p>The Block identifier. </p>
<p>ProtectionEnabled </p>
<p>This parameter is responsible for setting the write protection of a selected </p>
<p>NVRAM block: </p>
<p>TRUE</p>
<p>: enable protection </p>
<p>FALSE</p>
<p>: disable protection </p>
<p><b>Return code </b></p>
<p>E_OK </p>
<p>Request has been accepted. </p>
<p>E_NOT_OK </p>
<p>Request has not been accepted, e.g. Det error occurred. </p>
<p><b>Functional Description </b></p>
<p>The request sets the write protection for the NV block. Any further write/erase/invalidate requests to the </p>
<p>NVRAM block are rejected synchronously if the NV block-write protection is set. The data area of the RAM </p>
<p>block remains writable in any case.  </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>This service is synchronous. </p>
<p><b>&gt; </b></p>
<p>This service is re-entrant. </p>
<p><b>&gt; </b></p>
<p>This service is available if API configuration class 3 is configured.  </p>
<p><b>&gt; </b></p>
<p>The NVRAM Manager shall have been initialized before this request is called. The protection </p>
<p>cannot be released for a write once block that has already been written. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>Usage of Explicit Synchronization, does not permit NvM’s clients to issue new requests for a </p>
<p>pending block.</p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p>Expected Caller Context </p>
<p><b>&gt; </b></p>
<p>This service is expected to be called in application context. </p>
<p>Table 6-5  </p>
<p>NvM_SetBlockProtection </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 5.07.01 </p>
<p>52 </p>
<p>based on template version 3.01 </p>
<p><b>6.4.5 </b></p>
<p><b>NvM_GetErrorStatus </b></p>
<p><b>Prototype </b></p>
<p>Std_ReturnType NvM_GetErrorStatus ( NvM_BlockIdType BlockId,  </p>
<p>                              NvM_RequestResultType* RequestResultPtr ) </p>
<p><b>Parameter </b></p>
<p>BlockId </p>
<p>The Block identifier. </p>
<p>RequestResultPtr </p>
<p>Pointer where the result shall be written to. </p>
<p>Result is of type </p>
<p>NvM_RequestResultType</p>
<p>. All possible results are </p>
<p>described in chapter 6.2. </p>
<p><b>Return code </b></p>
<p>E_OK </p>
<p>Request has been accepted. </p>
<p>E_NOT_OK </p>
<p>Request has not been accepted, e.g. Det error occurred. </p>
<p><b>Functional Description </b></p>
<p>The request reads the block dependent error/status information and writes it to the given address. The </p>
<p>status/error information was set by a former or current asynchronous request. </p>
<p>This API can also be requested with BlockId 0 (multi block). Then the multi block error/status information </p>
<p>will be read to the given address. Only </p>
<p>NvM_ReadAll()</p>
<p> and </p>
<p>NvM_WriteAll()</p>
<p> are multi block requests </p>
<p>and change the status/error information of the multi block. </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>This service is synchronous. </p>
<p><b>&gt; </b></p>
<p>This service is re-entrant. </p>
<p><b>&gt; </b></p>
<p>This service is always available. </p>
<p><b>&gt; </b></p>
<p>The NVRAM Manager shall have been initialized before this request is called. </p>
<p>Expected Caller Context </p>
<p><b>&gt; </b></p>
<p>This service is expected to be called in application context. </p>
<p>Table 6-6  </p>
<p>NvM_GetErrorStatus </p>
<p><b>6.4.6 </b></p>
<p><b>NvM_GetVersionInfo </b></p>
<p><b>Prototype </b></p>
<p>void NvM_GetVersionInfo ( Std_VersionInfoType* versioninfo ) </p>
<p><b>Parameter </b></p>
<p>versioninfo </p>
<p>Pointer to the address where the version info shall be written to. </p>
<p><b>Return code </b></p>
<p>void </p>
<p>-- </p>
<p><b>Functional Description </b></p>
<p>The request writes the version info (Vendor ID, module ID, SW major version, SW minor version, SW patch </p>
<p>version) to the given pointer. </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>This service is synchronous. </p>
<p><b>&gt; </b></p>
<p>This service is re-entrant. </p>
<p><b>&gt; </b></p>
<p>This service is available if the pre-compile switch <b>Use version info API </b>is enabled. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 5.07.01 </p>
<p>53 </p>
<p>based on template version 3.01 </p>
<p>Expected Caller Context </p>
<p><b>&gt; </b></p>
<p>This service is expected to be called in application context. </p>
<p>Table 6-7  </p>
<p>NvM_GetVersionInfo </p>
<p><b>6.4.7 </b></p>
<p><b>NvM_SetRamBlockStatus </b></p>
<p><b>Prototype </b></p>
<p>Std_ReturnType NvM_SetRamBlockStatus ( NvM_BlockIdType BlockId,  </p>
<p>                                       boolean BlockChanged )  </p>
<p><b>Parameter </b></p>
<p>BlockId </p>
<p>The block identifier. </p>
<p>BlockChanged </p>
<p>Sets the new status of the RAM block: </p>
<p>TRUE: Validates the RAM block and marks it as changed. If the block has a </p>
<p>CRC and the option NVM_CALC_RAM_BLOCK_CRC is TRUE the CRC </p>
<p>calculation is initiated. </p>
<p>FALSE: Mark the block as unchanged </p>
<p><b>Return code </b></p>
<p>E_OK </p>
<p>Request has been accepted. </p>
<p>E_NOT_OK </p>
<p>Request has not been accepted, e.g. Det error occurred. </p>
<p><b>Functional Description </b></p>
<p>The request sets a block’s status to valid/changed respectively to unchanged. Setting a block to changed </p>
<p>marks it for writing it during </p>
<p>NvM_WriteAll()</p>
<p>. </p>
<p>If the block shall be set to <b>changed</b>, it has a CRC and the option </p>
<p>NVM_CALC_RAM_BLOCK_CRC</p>
<p> is </p>
<p>TRUE</p>
<p> the </p>
<p>CRC calculation of the RAM block is initiated. </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>Though this service is defined to operate synchronously, the CRC re-calculation will be </p>
<p>performed asynchronously. However, there is no restriction on accessing RAM block data, or </p>
<p>on calling other services. Consistency of data and CRC is ensured by WriteBlock/WriteAll, </p>
<p>which will unconditionally recalculate the CRC before writing. Requesting CRC re-calculation, </p>
<p>using </p>
<p>NvM_SetRamBlockStatus</p>
<p> again, will be recognized in a save way, the calculation </p>
<p>will be re-queued, if necessary.</p>
<p>. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>This service is synchronous. </p>
<p><b>&gt; </b></p>
<p>This service is re-entrant. </p>
<p><b>&gt; </b></p>
<p>This service is always available. </p>
<p><b>&gt; </b></p>
<p>The NVRAM Manager shall have been initialized before this request is called. </p>
<p>Expected Caller Context </p>
<p><b>&gt; </b></p>
<p>This service is expected to be called in application context. </p>
<p>Table 6-8  </p>
<p>NvM_SetRamBlockStatus </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 5.07.01 </p>
<p>54 </p>
<p>based on template version 3.01 </p>
<p><b>6.4.8 </b></p>
<p><b>NvM_SetBlockLockStatus </b></p>
<p><b>Prototype </b></p>
<p>void NvM_SetBlockLockStatus( NvM_BlockIdType BlockId,  </p>
<p>                             boolean BlockLocked ) </p>
<p><b>Parameter </b></p>
<p>BlockId </p>
<p>The Block identifier. </p>
<p>BlockLocked </p>
<p>This parameter is responsible for setting the lock protection status of a </p>
<p>selected NVRAM block: </p>
<p>TRUE</p>
<p>: Lock shall be enabled  </p>
<p>FALSE</p>
<p>: Lock shall be disabled </p>
<p><b>Return code </b></p>
<p>- </p>
<p> </p>
<p><b>Functional Description </b></p>
<p>Service for setting/resetting the lock of a NV block.  </p>
<p>If locked, the NV contents associated to the NVRAM block identified by BlockId, will not be modified by any </p>
<p>subsequent write request, i.e. the Block will be skipped during </p>
<p>NvM_WriteAll</p>
<p>; other requests, namely </p>
<p>NvM_WriteBlock</p>
<p>, </p>
<p>NvM_InvalidateNvBlock</p>
<p>, </p>
<p>NvM_EraseNvBlock</p>
<p>, will be rejected without error </p>
<p>notification to Det or Dem; i.e. they just return </p>
<p>E_NOT_OK</p>
<p>.  </p>
<p>During processing of </p>
<p>NvM_ReadAll</p>
<p>, a locked NVRAM block shall be loaded from NV memory, regardless </p>
<p>of RAM block’s state (see 4.4.10). After that the lock is disabled again. </p>
<p>If a block gets locked with </p>
<p>NvM_SetBlockLockStatus</p>
<p>, only the original NVRAM block is locked, </p>
<p>regardless which BlockId was passed - original or DCM (see chapter 4.4.17) </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Expert Knowledge </b></p>
<p>It is allowed to use this service for an already pending block. However, setting a lock </p>
<p>affects only subsequent requests; an already pending write will be processed. </p>
<p>This is a deviation from AUTOSAR, which prohibits this request for a pending block.  </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>This service is synchronous. </p>
<p><b>&gt; </b></p>
<p>This service is re-entrant. </p>
<p><b>&gt; </b></p>
<p>This service is always available independent on API configuration class. </p>
<p><b>&gt; </b></p>
<p>The NVRAM Manager shall have been initialized before this request is called. The protection </p>
<p>cannot be released for a write once block that has already been written. </p>
<p><b>&gt; </b></p>
<p>The service is only usable by BSW components; it is not accessible via RTE. </p>
<p> </p>
<p>Expected Caller Context </p>
<p><b>&gt; </b></p>
<p>This service is expected to be called by DCM. </p>
<p>Table 6-9  </p>
<p>NvM_SetBlockLockStatus </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 5.07.01 </p>
<p>55 </p>
<p>based on template version 3.01 </p>
<p><b>6.4.9 </b></p>
<p><b>NvM_MainFunction </b></p>
<p><b>Prototype </b></p>
<p>void NvM_MainFunction ( void ) </p>
<p><b>Parameter </b></p>
<p>-- </p>
<p>-- </p>
<p><b>Return code </b></p>
<p>void </p>
<p>-- </p>
<p><b>Functional Description </b></p>
<p>This function has to be called cyclically. It is the entry point of the NVRAM Manager. In here the processing </p>
<p>of the asynchronous jobs (read/write/erase/invalidate/CRC calculation…) is handled. </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>This service is synchronous. </p>
<p><b>&gt; </b></p>
<p>This service is non re-entrant. </p>
<p><b>&gt; </b></p>
<p>This service is always available. </p>
<p><b>&gt; </b></p>
<p>The NVRAM Manager shall have been initialized before this request is called. </p>
<p>Expected Caller Context </p>
<p><b>&gt; </b></p>
<p>This service is expected to be called in application context. </p>
<p>Table 6-10  </p>
<p>NvM_MainFunction </p>
<p><b>6.4.10 </b></p>
<p><b>NvM_ReadBlock </b></p>
<p><b>Prototype </b></p>
<p>Std_ReturnType NvM_ReadBlock ( NvM_BlockIdType BlockId,  </p>
<p>                               void* NvM_DstPtr ) </p>
<p><b>Parameter </b></p>
<p>BlockId </p>
<p>The Block identifier. </p>
<p>NvM_DstPtr </p>
<p>Pointer where the data of a non-permanent RAM block shall be written to. If </p>
<p>the block is permanent </p>
<p>NULL_PTR</p>
<p> shall be passed. </p>
<p><b>Return code </b></p>
<p>E_OK </p>
<p>Request has been accepted. </p>
<p>E_NOT_OK </p>
<p>Request has not been accepted, e.g. because of a list overflow. </p>
<p><b>Functional Description </b></p>
<p>Request to copy the data of the NV block to its corresponding RAM block. This function queues the read </p>
<p>request and returns the acceptance result synchronously.  </p>
<p>The NVM can notify the application by callback when the service is finished.  </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 5.07.01 </p>
<p>56 </p>
<p>based on template version 3.01 </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>This service is asynchronous. </p>
<p><b>&gt; </b></p>
<p>This service is re-entrant. </p>
<p><b>&gt; </b></p>
<p>This service is available if API configuration class 2 or 3 is configured.  </p>
<p><b>&gt; </b></p>
<p>The NVRAM Manager shall have been initialized before this request is called. In development </p>
<p>mode the service will not accept the call if the block is already queued (either for this or for a </p>
<p>different service). </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>Usage of Explicit Synchronization, does not permit NvM’s clients to issue new requests for a </p>
<p>pending block.</p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p>Expected Caller Context </p>
<p><b>&gt; </b></p>
<p>This service is expected to be called in application context. </p>
<p>Table 6-11  </p>
<p>NvM_ReadBlock </p>
<p><b>6.4.11 </b></p>
<p><b>NvM_WriteBlock </b></p>
<p><b>Prototype </b></p>
<p>Std_ReturnType NvM_WriteBlock ( NvM_BlockIdType BlockId,  </p>
<p>                                const void* NvM_SrcPtr ) </p>
<p><b>Parameter </b></p>
<p>BlockId </p>
<p>The Block identifier. </p>
<p>NvM_SrcPtr </p>
<p>Pointer where the data of a non-permanent RAM block shall be read from. If </p>
<p>the block is permanent, </p>
<p>NULL_PTR</p>
<p> shall be passed. </p>
<p><b>Return code </b></p>
<p>E_OK </p>
<p>Request has been accepted. </p>
<p>E_NOT_OK </p>
<p>Request has not been accepted, e.g. list overflow. </p>
<p><b>Functional Description </b></p>
<p>Request for copying data from the RAM block to its corresponding NV block. This function queues the write </p>
<p>request and returns the acceptance result synchronously.  </p>
<p>If the block has a CRC, the RAM block CRC will be recalculated before the data and the CRC are written to </p>
<p>the NV memory, even if the service </p>
<p>NvM_SetRamBlockStatus</p>
<p> was called before and the configuration </p>
<p>was set that within this service, the CRC calculation should be done. </p>
<p>If writing the data to NV memory fails, the NVM will retry writing. The number of write retries is a </p>
<p>configuration option. </p>
<p>The NVM can notify the application by callback when the service is finished.  </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 5.07.01 </p>
<p>57 </p>
<p>based on template version 3.01 </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>This service is asynchronous. </p>
<p><b>&gt; </b></p>
<p>This service is re-entrant. </p>
<p><b>&gt; </b></p>
<p>This service is available if API configuration class 2 or 3 is configured.  </p>
<p><b>&gt; </b></p>
<p>The NVRAM Manager shall have been initialized before this request is called. In development </p>
<p>mode the service will not accept the call if the block is already queued (either for this or for a </p>
<p>different service). If the block’s write protection is activated it can’t be written. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>Usage of Explicit Synchronization, does not permit NvM’s clients to issue new requests for a </p>
<p>pending block.</p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p>Expected Caller Context </p>
<p><b>&gt; </b></p>
<p>This service is expected to be called in application context. </p>
<p>Table 6-12  </p>
<p>NvM_WriteBlock </p>
<p><b>6.4.12 </b></p>
<p><b>NvM_RestoreBlockDefaults </b></p>
<p><b>Prototype </b></p>
<p>Std_ReturnType NvM_RestoreBlockDefaults ( NvM_BlockIdType BlockId,  </p>
<p>                                          void* NvM_DstPtr ) </p>
<p><b>Parameter </b></p>
<p>BlockId </p>
<p>The Block identifier. </p>
<p>NvM_DstPtr </p>
<p>Pointer where the data of a non-permanent RAM block shall be written to. If </p>
<p>the block is permanent, </p>
<p>NULL_PTR</p>
<p> shall be passed. </p>
<p><b>Return code </b></p>
<p>E_OK </p>
<p>Request has been accepted. </p>
<p>E_NOT_OK </p>
<p>Request has not been accepted, e.g. list overflow. </p>
<p><b>Functional Description </b></p>
<p>Request to copy the ROM block default data to its corresponding RAM block. The selected block needs </p>
<p>either ROM defaults or an initialization callback.  </p>
<p>This function queues the restore request and returns the acceptance result synchronously.  </p>
<p>The NVM can notify the application by callback when the service is finished.  </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 5.07.01 </p>
<p>58 </p>
<p>based on template version 3.01 </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>This service is asynchronous. </p>
<p><b>&gt; </b></p>
<p>This service is re-entrant. </p>
<p><b>&gt; </b></p>
<p>This service is available if API configuration class 2 or 3 is configured.  </p>
<p><b>&gt; </b></p>
<p>The NVRAM Manager shall have been initialized before this request is called. In development </p>
<p>mode the service will not accept the call if the block is already queued (either for this or for a </p>
<p>different service). This function is not intended for reading ROM sets of a dataset ROM block. </p>
<p>Use </p>
<p>NvM_ReadBlock</p>
<p> instead for these blocks. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>Usage of Explicit Synchronization, does not permit NvM’s clients to issue new requests for a </p>
<p>pending block.</p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p>Expected Caller Context </p>
<p><b>&gt; </b></p>
<p>This service is expected to be called in application context. </p>
<p>Table 6-13  </p>
<p>NvM_RestoreBlockDefaults </p>
<p><b>6.4.13 </b></p>
<p><b>NvM_EraseNvBlock </b></p>
<p><b>Prototype </b></p>
<p>Std_ReturnType NvM_EraseNvBlock ( NvM_BlockIdType BlockId ) </p>
<p><b>Parameter </b></p>
<p>BlockId </p>
<p>The Block identifier. </p>
<p><b>Return code </b></p>
<p>E_OK </p>
<p>Request has been accepted. </p>
<p>E_NOT_OK </p>
<p>Request has not been accepted, e.g. list overflow. </p>
<p><b>Functional Description </b></p>
<p>Request to erase a specified NV block. This function queues the erase request and returns the acceptance </p>
<p>result synchronously. </p>
<p>The NVM can notify the application by callback when the service is finished. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 5.07.01 </p>
<p>59 </p>
<p>based on template version 3.01 </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>This service is asynchronous. </p>
<p><b>&gt; </b></p>
<p>This service is re-entrant. </p>
<p><b>&gt; </b></p>
<p>This service is available if API configuration class 3 is configured.  </p>
<p><b>&gt; </b></p>
<p>The NVRAM Manager shall have been initialized before this request is called. In development </p>
<p>mode the service will not accept the call if the block is already queued (either for this or for a </p>
<p>different service). If the block’s write protection is activated it also can’t be erased. </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution</b> </p>
<p>Pay attention that only high priority jobs (priority 0) can be erased! </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>Usage of Explicit Synchronization, does not permit NvM’s clients to issue new requests for a </p>
<p>pending block.</p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p>Expected Caller Context </p>
<p><b>&gt; </b></p>
<p>This service is expected to be called in application context. </p>
<p>Table 6-14  </p>
<p>NvM_EraseNvBlock </p>
<p><b>6.4.14 </b></p>
<p><b>NvM_InvalidateNvBlock </b></p>
<p><b>Prototype </b></p>
<p>Std_ReturnType NvM_InvalidateNvBlock ( NvM_BlockIdType BlockId ) </p>
<p><b>Parameter </b></p>
<p>BlockId </p>
<p>The Block identifier. </p>
<p><b>Return code </b></p>
<p>E_OK </p>
<p>Request has been accepted. </p>
<p>E_NOT_OK </p>
<p>Request has not been accepted, e.g. list overflow. </p>
<p><b>Functional Description </b></p>
<p>Request to invalidate a specified NV block. This function queues the invalidate request and returns the </p>
<p>acceptance result synchronously.  </p>
<p>The NVM can notify the application by callback when the service is finished. </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>This service is asynchronous. </p>
<p><b>&gt; </b></p>
<p>This service is re-entrant. </p>
<p><b>&gt; </b></p>
<p>This service is available if API configuration class 3 is configured.  </p>
<p><b>&gt; </b></p>
<p>The NVRAM Manager shall have been initialized before this request is called. In development </p>
<p>mode the service will not accept the call if the block is already queued (either for this or for a </p>
<p>different service). If the block’s write protection is activated it also can’t be invalidated. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>Usage of Explicit Synchronization, does not permit NvM’s clients to issue new requests for a </p>
<p>pending block.</p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 5.07.01 </p>
<p>60 </p>
<p>based on template version 3.01 </p>
<p>Expected Caller Context </p>
<p><b>&gt; </b></p>
<p>This service is expected to be called in application context. </p>
<p>Table 6-15  </p>
<p>NvM_InvalidateNvBlock </p>
<p><b>6.4.15 </b></p>
<p><b>NvM_ReadAll </b></p>
<p><b>Prototype </b></p>
<p>void NvM_ReadAll ( void ) </p>
<p><b>Parameter </b></p>
<p>-- </p>
<p>-- </p>
<p><b>Return code </b></p>
<p>void </p>
<p>-- </p>
<p><b>Functional Description </b></p>
<p>Request to (re)load all RAM blocks that have the option </p>
<p>NVM_SELECT_BLOCK_FOR_READALL</p>
<p> </p>
<p>selected. The function queues the request that will be processed asynchronously in </p>
<p>NvM_MainFunction</p>
<p>. </p>
<p>Before reloading a block’s NV data, it first checks if the RAM block data is still valid. This can only </p>
<p>be assured if the block has a checksum. In case of valid RAM data, the NV data will not be </p>
<p>reloaded. </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution</b> </p>
<p>Non-permanent blocks and dataset blocks are also skipped during a ReadAll job.</p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p>The first block that is read from NV memory is the configuration ID (block 1). The value is </p>
<p>compared to the compiled configuration ID. The result of this check affects the further processing </p>
<p>of the ReadAll job, depending on the setting of <b>Dynamic Configuration Handling</b>: If disabled, all </p>
<p>NVRAM blocks will be processed as described above, regardless of the result of </p>
<p>reading/checking the configuration ID (match/mismatch/block invalid/integrity error/read failure). </p>
<p>If <b>Dynamic Configuration Handling </b>is enabled, the NVM loads all NVRAM blocks as described </p>
<p>above, only if it detected a configuration ID match. Otherwise (including failures) those blocks </p>
<p>having option <b>Resistant to Changed Software </b>set will be loaded as if the configuration ID </p>
<p>matched. The NVRAM blocks having this option cleared will be restored with ROM defaults, if </p>
<p>available, and if <b>Select for ReadAll </b>was configured. </p>
<p>When the last block is reloaded the NVM can notify the application by callback (configurable multi </p>
<p>block callback).</p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 5.07.01 </p>
<p>61 </p>
<p>based on template version 3.01 </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>This service is a multi block request. </p>
<p><b>&gt; </b></p>
<p>This service is asynchronous. </p>
<p><b>&gt; </b></p>
<p>This service is non re-entrant. </p>
<p><b>&gt; </b></p>
<p>This service is always available. </p>
<p><b>&gt; </b></p>
<p>The NVRAM Manager shall have been initialized before this request is called. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>Usage of Explicit Synchronization, does not permit NvM’s clients to issue new </p>
<p>requests for a pending block. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p>Expected Caller Context </p>
<p><b>&gt; </b></p>
<p>This function is intended only to be called by the ECU State Manager during startup. </p>
<p>Table 6-16  </p>
<p>NvM_ReadAll </p>
<p><b>6.4.16 </b></p>
<p><b>NvM_WriteAll </b></p>
<p><b>Prototype </b></p>
<p>void NvM_WriteAll ( void ) </p>
<p><b>Parameter </b></p>
<p>-- </p>
<p>-- </p>
<p><b>Return code </b></p>
<p>void </p>
<p>-- </p>
<p><b>Functional Description </b></p>
<p>Request to write all blocks with changed RAM data that have the option </p>
<p>NVM_SELECT_BLOCK_FOR_WRITEALL</p>
<p> selected to the NV memory. The function will queue the WriteAll job </p>
<p>that will be processed asynchronously. </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>Non-permanent and dataset blocks will not be written during </p>
<p>NvM_WriteAll()</p>
<p>. </p>
<p><b> </b></p>
<p><b> </b></p>
<p>When the last block is written the NVM can notify the application by callback (configurable multiblock </p>
<p>callback). </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>It is not recommended to make any assumption on the order in which blocks will be </p>
<p>processed. </p>
<p>It is only ensured that the ConfigID block (ID1) is the final block being processed, in </p>
<p>order to “commit” a Configuration Update and any related activity. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 5.07.01 </p>
<p>62 </p>
<p>based on template version 3.01 </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>This service is a multi block request. </p>
<p><b>&gt; </b></p>
<p>This service is asynchronous. </p>
<p><b>&gt; </b></p>
<p>This service is non re-entrant. </p>
<p><b>&gt; </b></p>
<p>This service is always available. </p>
<p><b>&gt; </b></p>
<p>The NVRAM Manager shall have been initialized before this request is called. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>Usage of Explicit Synchronization, does not permit NvM’s clients to issue new requests for a </p>
<p>pending block.</p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p>Expected Caller Context </p>
<p><b>&gt; </b></p>
<p>This function is intended only to be called by the ECU State Manager during shutdown. </p>
<p>Table 6-17  </p>
<p>NvM_WriteAll </p>
<p><b>6.4.17 </b></p>
<p><b>NvM_CancelWriteAll </b></p>
<p><b>Prototype </b></p>
<p>void NvM_CancelWriteAll ( void ) </p>
<p><b>Parameter </b></p>
<p>-- </p>
<p>-- </p>
<p><b>Return code </b></p>
<p>void </p>
<p>-- </p>
<p><b>Functional Description </b></p>
<p>Request to cancel a running </p>
<p>NvM_WriteAll()</p>
<p> request. This call en-queues the request that will be </p>
<p>processed asynchronously. </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>This service is asynchronous. </p>
<p><b>&gt; </b></p>
<p>This service is non re-entrant. </p>
<p><b>&gt; </b></p>
<p>This service is always available. </p>
<p><b>&gt; </b></p>
<p>The NVRAM Manager shall have been initialized before this request is called. </p>
<p>Expected Caller Context </p>
<p><b>&gt; </b></p>
<p>This service is expected to be called in application context. </p>
<p>Table 6-18  </p>
<p>NvM_CancelWriteAll </p>
<p><b>6.4.18 </b></p>
<p><b>NvM_KillWriteAll </b></p>
<p><b>Prototype </b></p>
<p>void NvM_KillWriteAll ( void ) </p>
<p><b>Parameter </b></p>
<p>-- </p>
<p>-- </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 5.07.01 </p>
<p>63 </p>
<p>based on template version 3.01 </p>
<p><b>Return code </b></p>
<p>void </p>
<p>-- </p>
<p><b>Functional Description </b></p>
<p>Request to cancel a running </p>
<p>NvM_WriteAll()</p>
<p> request destructively. To keep required wake-up response </p>
<p>times in an ECU the ECUM has the possibility to time-out a non-destructive </p>
<p>NvM_CancelWriteAll()</p>
<p> </p>
<p>request. </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>This service is synchronous. </p>
<p><b>&gt; </b></p>
<p>This service is non re-entrant. </p>
<p><b>&gt; </b></p>
<p>This service is available if the pre-compile switch <b>NvmKillWriteAllApi </b>(only in Generic Editor </p>
<p>in container <b>Nvm_30_CommonVendorParams</b>) is enabled independent on API configuration </p>
<p>class. </p>
<p><b>&gt; </b></p>
<p>The NVRAM Manager shall have been initialized before this request is called. </p>
<p>Expected Caller Context </p>
<p><b>&gt; </b></p>
<p>This service is expected to be called by ECUM </p>
<p>Table 6-19  </p>
<p>NvM_KilllWriteAll </p>
<p><b>6.4.19 </b></p>
<p><b>NvM_CancelJobs </b></p>
<p><b>Prototype </b></p>
<p>Std_ReturnType NvM_CancelJobs ( NvM_BlockIdType BlockId) </p>
<p><b>Parameter </b></p>
<p>BlockId </p>
<p>The Block identifier. </p>
<p><b>Return code </b></p>
<p>E_OK </p>
<p>Request has been accepted. </p>
<p>E_NOT_OK </p>
<p>Request has not been accepted, e.g. because of a list overflow. </p>
<p><b>Functional Description </b></p>
<p>Request to cancel pending job for a NV Block.  </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>This service is asynchronous. </p>
<p><b>&gt; </b></p>
<p>This service is re-entrant. </p>
<p><b>&gt; </b></p>
<p>This service is available if API configuration class 2 or 3 is configured.  </p>
<p><b>&gt; </b></p>
<p>The NVRAM Manager shall have been initialized before this request is called.  </p>
<p><b>&gt; </b></p>
<p>Was Cancellation successful Block result is set to </p>
<p>NVM_REQ_CANCELED.</p>
<p> </p>
<p>Expected Caller Context </p>
<p><b>&gt; </b></p>
<p>This service is expected to be called in application context. </p>
<p>Table 6-20  </p>
<p>NvM_CancelJobs </p>
<p><b>6.4.20 </b></p>
<p><b>NvM_RepairRedundantBlocks </b></p>
<p><b>Prototype </b></p>
<p>void NvM_RepairRedundantBlocks (void) </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 5.07.01 </p>
<p>64 </p>
<p>based on template version 3.01 </p>
<p><b>Parameter </b></p>
<p>- </p>
<p>- </p>
<p><b>Return code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>Request to check the redundancy within NV RAM for all configured redundant blocks. Write </p>
<p>protection or lock state does not matter – NvM do not change the data, it always overwrites </p>
<p>blocks with data from NV RAM. </p>
<p> </p>
<p>If the NvM recognizes a lost redundancy, it will try to restore it via overwriting the defect block with </p>
<p>data from valid block. </p>
<p> </p>
<p>Nothing to repair: </p>
<p>- </p>
<p>Both sub-blocks are readable </p>
<p>- </p>
<p>Both sub-blocks’ Crcs match the recalculates Crc </p>
<p> </p>
<p>Repairable blocks: </p>
<p>- </p>
<p>One sub-block isn’t readable, another is </p>
<p>- </p>
<p>One sub-block’s Crc doesn’t match the recalculated one, another sub-block’s Crc does </p>
<p>- </p>
<p>Both sub-blocks’ Crcs match the data, but their do not match each other (first block is </p>
<p>valid) </p>
<p> </p>
<p>Non-repairable blocks: </p>
<p>- </p>
<p>Both sub-blocks aren’t readable </p>
<p>- </p>
<p>Block sub-blocks’ Crc does not match the recalculated Crc </p>
<p> </p>
<p>NvM will report the error NVM_E_LOSS_OF_REDUNDANCY in case block isn’t stored in NV </p>
<p>RAM redundantly and the NvM could not restore the redundancy. </p>
<p> </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>This service is asynchronous </p>
<p><b>&gt; </b></p>
<p>This service is re-entrant </p>
<p><b>&gt; </b></p>
<p>This service is suspendable via all single and multi block requests – it will resume after the </p>
<p>requests are done </p>
<p><b>&gt; </b></p>
<p>This service can be enabled or disabled via configuration </p>
<p><b>&gt; </b></p>
<p>The NVRAM Manager shall have been initialized before this request is called </p>
<p>Call context </p>
<p><b>&gt; </b></p>
<p>This service is expected to be called in application context. </p>
<p>Table 6-21  </p>
<p>NvM_RepairRedundantBlocks </p>
<p><b>6.5 </b></p>
<p><b>Services used by NVM </b></p>
<p>In the following table services provided by other components, which are used by the NVM </p>
<p>are listed. For details about prototype and functionality refer to the documentation of the </p>
<p>providing component. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 5.07.01 </p>
<p>65 </p>
<p>based on template version 3.01 </p>
<p><b>Component </b></p>
<p><b>API </b></p>
<p>DET </p>
<p>Det_ReportError </p>
<p>DEM </p>
<p>Dem_SetEventStatus </p>
<p>MEMIF </p>
<p>MemIf_Read </p>
<p>MEMIF </p>
<p>MemIf_InvalidateBlock </p>
<p>MEMIF </p>
<p>MemIf_GetJobResult </p>
<p>MEMIF </p>
<p>MemIf_Write </p>
<p>MEMIF </p>
<p>MemIf_EraseImmediateBlock </p>
<p>MEMIF </p>
<p>MemIf_GetStatus </p>
<p>MEMIF </p>
<p>MemIf_Cancel </p>
<p>MEMIF </p>
<p>MemIf_SetMode </p>
<p>CRC </p>
<p>Crc_CalculateCRC16 </p>
<p>CRC </p>
<p>Crc_CalculateCRC32 </p>
<p>EA </p>
<p>Used by MEMIF </p>
<p>FEE </p>
<p>Used by MEMIF </p>
<p>Table 6-22  </p>
<p>Services used by the NVM </p>
<p><b>6.6 </b></p>
<p><b>Callback Functions </b></p>
<p>This  chapter  describes  the  callback  functions  that  are  implemented  by  the  NVM  and  can  be </p>
<p>invoked by other modules. The prototypes of the callback functions are provided in the header file </p>
<p>NvM_Cbk.h</p>
<p> by the NVM. </p>
<p><b>6.6.1 </b></p>
<p><b>NvM_JobEndNotification </b></p>
<p><b>Prototype </b></p>
<p>void NvM_JobEndNotification ( void ) </p>
<p><b>Parameter </b></p>
<p>- </p>
<p>- </p>
<p><b>Return code </b></p>
<p>void </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>Function to be used by the underlying memory abstraction to signal end of job without error. </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>This service is synchronous. </p>
<p><b>&gt; </b></p>
<p>This service is non re-entrant. </p>
<p>Expected Caller Context </p>
<p></p>
<p> </p>
<p>The callback function </p>
<p>NvM_JobEndNotification</p>
<p> is intended to be used by the underlying </p>
<p>memory abstraction (Fee/Ea) to signal end of job without error. </p>
<p>Table 6-23  </p>
<p>NvM_JobEndNotification </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 5.07.01 </p>
<p>66 </p>
<p>based on template version 3.01 </p>
<p><b>6.6.2 </b></p>
<p><b>NvM_JobErrorNotification </b></p>
<p><b>Prototype </b></p>
<p>void NvM_JobErrorNotification ( void ) </p>
<p><b>Parameter </b></p>
<p>- </p>
<p>- </p>
<p><b>Return code </b></p>
<p>void </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>Function to be used by the underlying memory abstraction to signal end of job with error. </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>This service is synchronous. </p>
<p><b>&gt; </b></p>
<p>This service is non re-entrant. </p>
<p>Expected Caller Context </p>
<p><b>&gt; </b></p>
<p>The callback function </p>
<p>NvM_JobErrorNotification</p>
<p> is intended to be used by the </p>
<p>underlying memory abstraction (Fee/Ea) to signal end of job with error. </p>
<p>Table 6-24  </p>
<p>NvM_JobErrorNotification </p>
<p><b>6.7 </b></p>
<p><b>Configurable Interfaces </b></p>
<p>At its configurable interfaces the NVM defines notifications that can be mapped to callback </p>
<p>functions  provided by  other modules. The mapping  is not  statically  defined by  the  BSW </p>
<p>module but can be performed at configuration time. The function prototypes that can be </p>
<p>used  for  the  configuration  have  to  match  the  signatures  described  in  the  following  sub-</p>
<p>chapters. </p>
<p><b>6.7.1 </b></p>
<p><b> SingleBlockCallbackFunction </b></p>
<p><b>Prototype </b></p>
<p>Std_ReturnType &lt;SingleBlockCallbackFunction</p>
<p>&gt;</p>
<p> ( </p>
<p>NvM_ServiceIdType ServiceId,                                           </p>
<p>NvM_RequestResultType JobResult ) </p>
<p><b>Parameter </b></p>
<p>ServiceId </p>
<p>The service identifier (see chapter 6.2) of the completed request. </p>
<p>NvM_ServiceIdType</p>
<p> is of type </p>
<p>uint8</p>
<p>. </p>
<p>JobResult </p>
<p>Result of the single block job. </p>
<p><b>Return code </b></p>
<p>E_OK </p>
<p>Callback function has been processed successfully </p>
<p>E_NOT_OK </p>
<p>Callback function has not been processed successfully. </p>
<p><b>Functional Description </b></p>
<p>Callback routine to notify the upper layer that an asynchronous single block request has been finished. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 5.07.01 </p>
<p>67 </p>
<p>based on template version 3.01 </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>This service is synchronous. </p>
<p><b>&gt; </b></p>
<p>This service is non re-entrant. </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>This description is limited to embedded code; it does not describe RUNNABLES </p>
<p>implementing a callback’s behavior in an SWC, but it describes the prototype to be </p>
<p>implemented/generated be the RTE or by a BSW component. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p>Call Context </p>
<p><b>&gt; </b></p>
<p>Called from </p>
<p>NvM_MainFunction</p>
<p> </p>
<p><b>&gt; </b></p>
<p>Asynchronous block processing completed (except </p>
<p>NvM_WriteAll</p>
<p>, for </p>
<p>NvM_ReadAll</p>
<p> it is </p>
<p>configurable) </p>
<p>Table 6-25  </p>
<p>SingleBlockCallbackFunction </p>
<p><b>6.7.2 </b></p>
<p><b>MultiBlockCallbackFunction  </b></p>
<p><b>Prototype </b></p>
<p>void &lt;MultiBlockCallbackFunction&gt; ( NvM_ServiceIdType ServiceId,                                  </p>
<p>                                  NvM_RequestResultType JobResult ) </p>
<p><b>Parameter </b></p>
<p>ServiceId </p>
<p>The service identifier (see chapter 6.2) of the completed request. </p>
<p>NvM_ServiceIdType</p>
<p> is of type </p>
<p>uint8</p>
<p>. </p>
<p>JobResult </p>
<p>Result of the multi block job. </p>
<p><b>Return code </b></p>
<p>void </p>
<p>-- </p>
<p><b>Functional Description </b></p>
<p>Common callback routine to notify the upper layer that an asynchronous multi block request has been </p>
<p>finished.  </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>This service is synchronous. </p>
<p><b>&gt; </b></p>
<p>This service is non re-entrant. </p>
<p>Call Context </p>
<p><b>&gt; </b></p>
<p>Called from </p>
<p>NvM_MainFunction</p>
<p>. </p>
<p><b>&gt; </b></p>
<p>Called upon completion of </p>
<p>NvM_ReadAll</p>
<p> and </p>
<p>NvM_WriteAll</p>
<p>, respectively </p>
<p>Table 6-26 </p>
<p>MultiBlockCallbackFunction </p>
<p><b>6.7.3 </b></p>
<p><b>InitBlockCallbackFunction </b></p>
<p><b>Prototype </b></p>
<p>Std_ReturnType &lt;InitBlockCallbackFunction&gt; ( void ) </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 5.07.01 </p>
<p>68 </p>
<p>based on template version 3.01 </p>
<p><b>Parameter </b></p>
<p>-- </p>
<p>-- </p>
<p><b>Return code </b></p>
<p>Std_ReturnType </p>
<p>NVM always returns </p>
<p>E_OK</p>
<p>. </p>
<p><b>Functional Description </b></p>
<p>Callback routine which shall be called by the NVM module to copy default data to a RAM block if </p>
<p>a ROM block is configured. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>During calling init block callback related block is still busy. No request for it shall be </p>
<p>issued as long as block is busy. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>This service is synchronous. </p>
<p><b>&gt; </b></p>
<p>This service is non re-entrant </p>
<p>Call Context </p>
<p><b>&gt; </b></p>
<p>Called from </p>
<p>NvM_MainFunction</p>
<p> </p>
<p><b>&gt; </b></p>
<p>Called during processing of </p>
<p>NvM_ReadAll</p>
<p>, if application shall copy default values into the </p>
<p>corresponding RAM block. </p>
<p>Table 6-27 </p>
<p>InitBlockCallbackFunction </p>
<p><b>6.7.4 </b></p>
<p><b>Callback function for RAM to NvM copy </b></p>
<p><b>Prototype </b></p>
<p>Std_ReturnType &lt;NvM_WriteRamBlockToNvm&gt; ( void* NvMBuffer ) </p>
<p><b>Parameter </b></p>
<p>NvMBuffer </p>
<p>Internal RAM mirror where Ram block data shall be written to </p>
<p><b>Return code </b></p>
<p>E_OK </p>
<p>Callback function has been processed successfully </p>
<p>E_NOT_OK </p>
<p>Callback function has not been processed successfully. </p>
<p><b>Functional Description </b></p>
<p>Block specific callback routine which shall be called in order to let the application copy data from </p>
<p>RAM block to internal NvM RAM mirror. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>During calling NvM_WriteRamBlockToNvM callback related block is still busy. No </p>
<p>request for it shall be issued as long as block is busy. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>This service is synchronous. </p>
<p><b>&gt; </b></p>
<p>This service is non re-entrant </p>
<p>Call Context </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 5.07.01 </p>
<p>69 </p>
<p>based on template version 3.01 </p>
<p><b>&gt; </b></p>
<p>Called from </p>
<p>NvM_MainFunction</p>
<p> </p>
<p><b>&gt; </b></p>
<p>Called during processing of NvM write requests, if application shall copy RAM block data into </p>
<p>the internal RAM mirror. </p>
<p>Table 6-28 </p>
<p>Callback function for RAM to NvM copy </p>
<p><b>6.7.5 </b></p>
<p><b>Callback function for NvM to RAM copy </b></p>
<p><b>Prototype </b></p>
<p>Std_ReturnType &lt;NvM_ReadRamBlockFromNvm&gt; ( const void* NvMBuffer ) </p>
<p><b>Parameter </b></p>
<p>NvMBuffer </p>
<p>Internal RAM mirror where Ram block data can be read from </p>
<p><b>Return code </b></p>
<p>E_OK </p>
<p>Callback function has been processed successfully </p>
<p>E_NOT_OK </p>
<p>Callback function has not been processed successfully. </p>
<p><b>Functional Description </b></p>
<p>Block specific callback routine which shall be called in order to let the application copy data from </p>
<p>NvM module’s mirror to RAM block. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>During calling NvM_ReadRamBlockFromNvM callback related block is still busy. No </p>
<p>request for it shall be issued as long as block is busy. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>This service is synchronous. </p>
<p><b>&gt; </b></p>
<p>This service is non re-entrant </p>
<p>Call Context </p>
<p><b>&gt; </b></p>
<p>Called from </p>
<p>NvM_MainFunction</p>
<p> </p>
<p><b>&gt; </b></p>
<p>Called during processing of NvM read requests, if application can copy data from internal RAM </p>
<p>mirror to RAM block. </p>
<p>Table 6-29 </p>
<p>Callback function for NvM to RAM copy </p>
<p><b>6.8 </b></p>
<p><b>Service Ports </b></p>
<p>Via Service Ports the software components (SWC) have the possibility to execute services </p>
<p>of </p>
<p>the </p>
<p>NVM </p>
<p>with </p>
<p>an </p>
<p>abstract </p>
<p>RTE </p>
<p>interface. </p>
<p>Hence, </p>
<p>the </p>
<p>software </p>
<p>components </p>
<p>are </p>
<p>independent from the underlying basic software stack. </p>
<p><b>6.8.1 </b></p>
<p><b>Client Server Interface </b></p>
<p>A  client  server  interface  is  related  to  a  Provide  Port  (Pport)  at  the  server  side  and  a </p>
<p>Require Port (Rport) at client side. </p>
<p>Configuration dependent naming details are described in the chapters 7.1.3 and 7.1.4. </p>
<p><b>6.8.1.1 </b></p>
<p><b>Provide Ports on NVM side </b></p>
<p>At  the Pports of  the NVM  the API functions  described  in  6.4 are  available  as  Runnable </p>
<p>Entities.  The  Runnable  Entities  are  invoked  via  Operations.  The  mapping  from  a  SWC </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 5.07.01 </p>
<p>70 </p>
<p>based on template version 3.01 </p>
<p>client call to an Operation is performed by the RTE. In this mapping the RTE adds Port </p>
<p>Defined Argument Values to the client call of the SWC, if configured. </p>
<p>The following subchapters present the Pports defined for the NVM and their Operations, </p>
<p>the API functions related to those Operations and the Port Defined Argument Values to be </p>
<p>added by the RTE: </p>
<p><b>6.8.1.1.1 </b></p>
<p><b>Padmin_&lt;BlockName&gt; </b></p>
<p>A port of type <b>Padmin </b>is a Pport of one NVRAM block, which is configured to use Service </p>
<p>Ports. </p>
<p>If the SWC setting <b>Long Service Port Names </b>is enabled, the name of the service ports is </p>
<p>Padmin_&lt;BlockName&gt;; </p>
<p>if </p>
<p><b>Long </b></p>
<p><b>Service </b></p>
<p><b>Port </b></p>
<p><b>Names </b></p>
<p>is </p>
<p>disabled, </p>
<p>the </p>
<p>name </p>
<p>is </p>
<p>Padmin_&lt;BlockId&gt;. </p>
<p>Available if API Config Class = 3 </p>
<p><b>Operation </b></p>
<p><b>API Function </b></p>
<p><b>Port Defined Argument Values </b></p>
<p>SetBlockProtection </p>
<p>NvM_SetBlockProtection() </p>
<p>NvM_BlockIdType</p>
<p>4</p>
<p> 1..n </p>
<p>Table 6-30 </p>
<p>Operations of Port Prototype Padmin_&lt;BlockName&gt; </p>
<p><b>6.8.1.1.2 </b></p>
<p><b>PS_&lt;BlockName&gt; </b></p>
<p>A port of type <b>PS </b>is a Pport of one NVRAM block, which is configured to use Service Ports. </p>
<p>If the SWC setting <b>Long Service Port Names </b>is enabled, the name of the service ports is </p>
<p>PS_&lt;BlockName&gt;; if <b>Long Service Port Names </b>is disabled, the name is PS_&lt;BlockId&gt;. </p>
<p><b>Operation </b></p>
<p><b>API Function </b></p>
<p><b>Port Defined Argument Values </b></p>
<p>GetErrorStatus</p>
<p> 1</p>
<p> </p>
<p>NvM_GetErrorStatus() </p>
<p>NvM_BlockIdType</p>
<p>4</p>
<p> 1..n </p>
<p>SetRamBlockStatus</p>
<p>1</p>
<p> </p>
<p>NvM_SetRamBlockStatus() </p>
<p>NvM_BlockIdType</p>
<p>4</p>
<p> 1..n </p>
<p>SetDataIndex</p>
<p>2,5</p>
<p> </p>
<p>NvM_SetDataIndex() </p>
<p>NvM_BlockIdType</p>
<p>4</p>
<p> 1..n </p>
<p>GetDataIndex</p>
<p>2,5</p>
<p> </p>
<p>NvM_GetDataIndex() </p>
<p>NvM_BlockIdType</p>
<p>4</p>
<p> 1..n </p>
<p>ReadBlock</p>
<p>2</p>
<p> </p>
<p>NvM_ReadBlock() </p>
<p>NvM_BlockIdType</p>
<p>4</p>
<p> 1..n </p>
<p>WriteBlock</p>
<p>2</p>
<p> </p>
<p>NvM_WriteBlock() </p>
<p>NvM_BlockIdType</p>
<p>4</p>
<p> 1..n </p>
<p>RestoreBlockDefaults</p>
<p>2, 6</p>
<p> </p>
<p>NvM_RestoreBlockDefaults() </p>
<p>NvM_BlockIdType</p>
<p>4</p>
<p> 1..n </p>
<p>EraseBlock</p>
<p>3</p>
<p> </p>
<p>NvM_EraseNvBlock() </p>
<p>NvM_BlockIdType</p>
<p>4</p>
<p> 1..n </p>
<p>InvalidateNvBlock</p>
<p>3</p>
<p> </p>
<p>NvM_InvalidateNvBlock() </p>
<p>NvM_BlockIdType</p>
<p>4</p>
<p> 1..n </p>
<p>Table 6-31 </p>
<p>Operations of Port Prototype PS_&lt;BlockName&gt; </p>
<p>1. </p>
<p>Always available </p>
<p>2. </p>
<p>Available if API Config Class &gt;= 2 </p>
<p>3. </p>
<p>Available if API Config Class = 3 </p>
<p>4. </p>
<p>Is derived from the block’s position in the configuration </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 5.07.01 </p>
<p>71 </p>
<p>based on template version 3.01 </p>
<p>5. </p>
<p>Only available for blocks of Management Type Dataset </p>
<p>6. </p>
<p>Only available for blocks with Rom defaults configured </p>
<p><b>6.8.1.2 </b></p>
<p><b>Require Ports </b></p>
<p>NVM invokes callbacks using Rports. These Operations have to be provided by the SWCs </p>
<p>by  means  of  Runnable  Entities  using  Pports.  These  Runnable  Entities  implement  the </p>
<p>callback functions expected by the NVM. </p>
<p>The following subchapters present the Require Ports defined for the NVM, the Operations </p>
<p>that are called from the NVM and the related Notifications, which are described in chapter </p>
<p>6.7. </p>
<p><b>6.8.1.2.1 </b></p>
<p><b>NvM_RpNotifyFinished_Id&lt;BlockName&gt; </b></p>
<p>A  port  of  type <b> NvM_RpNotifyFinished_Id </b> is  a  Rport  of  one  NVRAM  block,  which  is </p>
<p>configured to use Service Ports. </p>
<p>If the SWC setting <b>Long Service Port Names </b>is enabled, the name of the service ports is </p>
<p>NvM_RpNotifyFinished_Id&lt;BlockName&gt;;  if <b> Long  Service  Port  Names </b> is  disabled,  the </p>
<p>name is NvM_RpNotifyFinished_Id&lt;BlockId&gt;. </p>
<p>Available in all API Config Classes but <b>Use Callbacks </b>must be enabled. </p>
<p><b>Operation </b></p>
<p><b>Notification </b></p>
<p>JobFinished </p>
<p>SingleBlockCallbackFunction </p>
<p>Table 6-32 </p>
<p>Operation of Port prototype NvM_RpNotifyFinished_Id&lt;BlockName&gt; </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 5.07.01 </p>
<p>72 </p>
<p>based on template version 3.01 </p>
<p><b>7 </b></p>
<p><b>Configuration </b></p>
<p><b>7.1 </b></p>
<p><b>Software Component Template </b></p>
<p><b>7.1.1 </b></p>
<p><b>Generation </b></p>
<p>The definition of the Provide Ports is described in an XML file. This file describes the NVM </p>
<p>as a software component with ports to which other applications can connect. This XML file </p>
<p>is </p>
<p>always </p>
<p>saved </p>
<p>consistent </p>
<p>to </p>
<p>the </p>
<p>current </p>
<p>ECUC </p>
<p>file </p>
<p>when </p>
<p>the </p>
<p>project </p>
<p>in </p>
<p>DaVinci </p>
<p>Configurator is saved. The target directory for SW-C files can be set in the Dpa file. For </p>
<p>more information see documentation of DaVinci Configurator. </p>
<p><b>7.1.2 </b></p>
<p><b>Import into DaVinci Developer </b></p>
<p>For further processing the generated software component template file has to be imported </p>
<p>into DaVinci Developer. This can be done while a DaVinci-project is open by clicking <b>File </b>| </p>
<p><b>Import XML File...</b>. Choose the correct file for the import. </p>
<p> </p>
<p>Figure 7-1 </p>
<p>Import a new software component into DaVinci Developer </p>
<p>After  importing  the  NVM  as  software  component  there  is  a  new  component  type  in  the </p>
<p>library view available. After double clicking the component NVM, all configured ports are </p>
<p>presented. </p>
<p>The  DaVinci  tool  suite  lets  you  design  the  complete  architecture  of  a  car,  consisting  of </p>
<p>several ECUs, each with its own NVM. Therefore it is desirable to import several NVM SW-</p>
<p>C descriptions, each containing the description of an NVM to be mapped  to a particular </p>
<p>ECU. Using the ‘Service Component Name Parameter’ you can give your configurations </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 5.07.01 </p>
<p>73 </p>
<p>based on template version 3.01 </p>
<p>meaningful  unique  names.  All  elements  of  the  SW-C  description  are  unique  in  this </p>
<p>particular  configuration  and  are  prefixed  with  this  parameter’s  value.  However,  most </p>
<p>elements  are  common  to  all  SW-C  descriptions,  or  are  at  least  unique  to  the  used </p>
<p>configuration (which is also expressed by the elements’ names) so that some elements are </p>
<p>contained in each different SW-C description. During import, DaVinci will warn you about </p>
<p>these doubled elements. You can ignore them (overwrite the existing elements); they are </p>
<p>identical. </p>
<p><b>7.1.3 </b></p>
<p><b>Dependencies on Configuration of NVM Attributes </b></p>
<p>The configuration of the NVM attributes (described in chapter 7.1.5) highly influences the </p>
<p>resulting SW-C Description.  So, the value of the parameter <b> Service Component Name </b></p>
<p>influences the names of several elements in the description, especially the  name of the </p>
<p><b>Service  Component</b>.  It  is  also  the  prefix  for  several  other  names  that  belong  to  this </p>
<p>particular NVM configuration (and the resulting service component). </p>
<p>There  is  a  couple  of  different  port  interfaces  that  will  be  generated,  depending  on  the </p>
<p>particular configuration. Each generated interface that results from a specific configuration </p>
<p>has a unique name, i.e. in different SW-C descriptions port interfaces with the same name </p>
<p>are compatible; they provide the same operations, each with the same arguments of same </p>
<p>type. </p>
<p><b>7.1.3.1 </b></p>
<p><b>Naming of Service Port Interfaces </b></p>
<p>The  Service </p>
<p>Port  Interface  provides  the  prototypes  of </p>
<p>the  elementary  block </p>
<p>related </p>
<p>services  of  the  NVM,  such  as  read  data  from  NV  memory,  write  data  to  NV  memory.  It </p>
<p>generally contains the string <b>Service</b>. </p>
<p>As described above, port interfaces resulting from different configurations, have different </p>
<p>names. These names are given according to this scheme: </p>
<p><b>&gt; </b> Each Interface is prefixed by <b>NvM </b></p>
<p><b>&gt;</b></p>
<p><b>  Set Ram Block Status Api </b></p>
<p>If enabled, the interface name contains the string ‘SRBS’, and it contains the operation </p>
<p>SetRamBlockStatus.</p>
<p> </p>
<p><b>&gt;  API Configuration Class </b></p>
<p>The interface name contains a short string that denotes the API configuration class it </p>
<p>belongs to: <b>AC1</b>, <b>AC2 </b>or <b>AC3</b>. The operations the interface describes in that </p>
<p>configuration class are described in Chapter 6.8.1.1. </p>
<p><b>&gt;</b></p>
<p><b>  Availability of ROM default data </b></p>
<p>The interface contains the operation RestoreBlockDefaults; it contains the string <b>Defs</b>. </p>
<p>This interface will be used by all P-Port-Prototypes belonging to a NVRAM block that </p>
<p>was configured with ROM default data.</p>
<p> </p>
<p><b>&gt;  Block Management Type DATASET </b></p>
<p>The interface provides the operations GetDataIndex and SetDataIndex. Its name </p>
<p>contains <b>DS</b>. This interface will be used by all NVRAM blocks of Management Type </p>
<p><b>DATASET </b></p>
<p>The first two possibilities are common within one SW-C Description. Only one combination </p>
<p>of  them  will  occur.  Unless <b> API  Configuration  Class  1 </b> was  chosen,  Port  Interfaces </p>
<p>describing any combination of the latter two possibilities may be generated. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 5.07.01 </p>
<p>74 </p>
<p>based on template version 3.01 </p>
<p><b>7.1.4 </b></p>
<p><b>Service Port Prototypes </b></p>
<p>For each active NVRAM block (including the configuration ID block) that was configured </p>
<p>with <b> Use  Service  Ports </b> port, prototypes  will  be  generated. The port  interfaces  they  are </p>
<p>based on can differ. The interfaces depend on the block’s configuration, and hence on the </p>
<p>operations that are necessary for current block. </p>
<p><b>7.1.4.1 </b></p>
<p><b>Port Prototype Naming </b></p>
<p>The short name uniquely identifying the prototype is based on the numeric block ID (which, </p>
<p>in  turn,  is  derived  from  the  block’s  position  in  the  configuration)  and  the  port  interface </p>
<p><b>class </b>it corresponds to. </p>
<p>Each </p>
<p>prototype </p>
<p>is </p>
<p>prefixed </p>
<p>by </p>
<p>the </p>
<p>String </p>
<p><b>NvM_</b>; </p>
<p>the </p>
<p>next </p>
<p>substring </p>
<p>describes </p>
<p>the </p>
<p>corresponding  port  interface,  and  whether  it  is  a  Provide  Port  (‘Pp’)  or  a  Require  Port </p>
<p>(‘Rp’): </p>
<p><b>&gt;  Padmin </b></p>
<p>Linked with port interface <b>NvMAdministration </b>(only in <b>API Configuration Class 3</b>) </p>
<p><b>&gt;</b></p>
<p><b>  PS </b></p>
<p>Linked with Port Interface ‘NvMService_AC{1|2|3}[_SRBS][_Defs][_DS]’. The actual </p>
<p>interface depends on the possibilities described above.</p>
<p> </p>
<p><b>&gt;  NvM_RpNotifyFinished </b></p>
<p>Linked with Port Interface NvMNotifyJobFinished that describes the interface used by </p>
<p>the NVM for <b>single block job end notification </b></p>
<p>If SWC setting <b>Long Service Port Names </b>is disabled, each port prototype’s name is post </p>
<p>fixed by <b>_Id{BlockId}</b>. If SWC setting <b>Long Service Port Names </b>is enabled, each port </p>
<p>prototype’s name is post fixed by ‘_{BlockName}’.  </p>
<p>Additionally  each  port  prototype  contains  a  long  name  as  well  as  a  description,  which </p>
<p>describe  it  in  a  better,  human  readable  form.  They  contain  the  logical  block  name,  as </p>
<p>configured, instead of the block ID, and the used port interface’s short name. </p>
<p><b>7.1.5 </b></p>
<p><b>Modelling SWC’s callback functions </b></p>
<p>According to AUTOSAR, the prototype of a SingleBlockCallbackFunction (Chapter 6.7.1), </p>
<p>differs from that of a RUNNABLE implementing SWC’s behavior of that callback. Therefore </p>
<p>the prototype describes the RTE function called by NVM. </p>
<p>The prototype of the RUNNABLE, which is actually called by RTE, must match model, i.e. </p>
<p>the  return  type  must  match  the  information  given  in  callback’s  interface  description </p>
<p>(“Application  Errors”).  The  correct  modelling  would  be  “no  Application  Errors”,  which </p>
<p>requires a RUNNABLE implementation without return type: </p>
<p><b>void </b>&lt;init_cbk_runnable_name&gt;(void) </p>
<p><b>void </b>&lt;jobend_cbk_runnable_name&gt;( NvM_ServiceIdType ServiceId,                                           </p>
<p>NvM_RequestResultType JobResult) </p>
<p>However,  DaVinci  Developer  since  Version  3.8  along  with  MICROSAR </p>
<p>RTE  version </p>
<p>4.04.00 and later enable NVM to support another different (actually incompatible) function </p>
<p>prototype:  </p>
<p><b>Std_ReturnType </b>&lt;init_cbk_runnable_name&gt;(void) </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 5.07.01 </p>
<p>75 </p>
<p>based on template version 3.01 </p>
<p><b>Std_ReturnType </b>&lt;jobend_cbk_runnable_name&gt;( NvM_ServiceIdType </p>
<p>ServiceId,                                           </p>
<p>NvM_RequestResultType JobResult) </p>
<p> </p>
<p>Both implementations require slightly different Interface definitions; they may be adapted </p>
<p>using </p>
<p>DaVinci </p>
<p>Developer. </p>
<p>From </p>
<p>a </p>
<p>modeling </p>
<p>point </p>
<p>of </p>
<p>view, </p>
<p>the </p>
<p>runnable </p>
<p>must </p>
<p>be </p>
<p>implemented according to the Interface associated with the related Pport-Prototype. </p>
<p> </p>
<p>Figure 7-2 A  </p>
<p>“Single Block Job End Notification” with return type Std_ReturnType </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 5.07.01 </p>
<p>76 </p>
<p>based on template version 3.01 </p>
<p> </p>
<p>Figure 7-3 A  </p>
<p>“Single Block Job End Notification” with return type void. </p>
<p>NVM itself provides interfaces as described by Figure 7-3. To make SWCs independent of </p>
<p>this definition, they may associate their PPort prototype to their own interface definitions, </p>
<p>according to their (planned) RUNNABLEs’ implementations. Of course, the interface must </p>
<p>be compatible according to AUTOSAR’s rules; which limits possible interface definitions to </p>
<p>exactly one of both mentioned here. </p>
<p><b>7.2 </b></p>
<p><b>Configuration of NVM Attributes </b></p>
<p>The NVM attributes can be configured using the DaVinci Configurator. The outputs of the </p>
<p>configuration and generation process are the configuration source files.  </p>
<p>The description of each used parameter is set in the NvM</p>
<p> </p>
<p>bswmd file. </p>
<p>Only additional information is given in this chapter. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 5.07.01 </p>
<p>77 </p>
<p>based on template version 3.01 </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>Because </p>
<p>sizeof</p>
<p>-operator cannot be used during configuration in production code </p>
<p>because sizes also affect lower layers, the exact sizes of your NVRAM blocks, and </p>
<p>hence your data structures must be known at configuration time. Therefore you are </p>
<p>required to determine these values by yourself. This leads to some significant pitfalls: </p>
<p><b>&gt; </b></p>
<p>The sizes of basic data types are platform dependent. To handle this problem, you </p>
<p>should use only AUTOSAR data types as defined in </p>
<p>Std_Types.h </p>
<p>(respectively </p>
<p>Platform_Types.h</p>
<p>). They are defined to have the same size on all platforms. The </p>
<p>enumeration type’s size also depends on your platform, the compiler and its options. </p>
<p>Be aware of the size the compiler actually chooses. Usually an </p>
<p>enum</p>
<p> equals to an </p>
<p>int</p>
<p> by default, but you can force it to be the smallest possible type (e.g. </p>
<p>char</p>
<p>). </p>
<p><b>&gt; </b></p>
<p>Be aware of the composition of bit fields. It can be affected by compiler switches. </p>
<p><b>&gt; </b></p>
<p>The compiler may rearrange members of structures to save memory. The best </p>
<p>solution would be to arrange members according to their type manually. The </p>
<p>compiler may add unused padding bytes to increase accessibility to the members of </p>
<p>a structure. According to the previous fact, you should order your structure’s </p>
<p>members. Doing so, you should be aware of aligned start addresses for larger </p>
<p>integral data types (e.g. </p>
<p>uint16</p>
<p> or </p>
<p>uint32</p>
<p>) according to the CPU’s requirements </p>
<p>for accessing them. </p>
<p><b>&gt; </b></p>
<p>As stated above, some compiler switches influence the sizes of data types. Keep in </p>
<p>mind that changing these ones may result in changed sizes of your data blocks, </p>
<p>leading to a reconfiguration of NVM. </p>
<p>A good way to determine the blocks’ sizes is to extract the required information from </p>
<p>the linker file or from the generated object. </p>
<p><b> </b></p>
<p><b> </b></p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 5.07.01 </p>
<p>78 </p>
<p>based on template version 3.01 </p>
<p><b>8 </b></p>
<p><b>AUTOSAR Standard Compliance </b></p>
<p><b>8.1 </b></p>
<p><b>Deviations </b></p>
<p><b>&gt; </b> In contrast to AUTOSAR most configuration parameters are link-time parameters. </p>
<p><b>&gt; </b> Saving RAM CRC of current block is configuration dependent. Either it is saved behind </p>
<p>the block’s data or it is saved internally by NVM in an own variable. </p>
<p><b>&gt; </b> Unified handling of ROM defaults among all block management types is processed. </p>
<p>Rom defaults handling of blocks of type dataset is just like the handling of blocks of the </p>
<p>other management types. </p>
<p><b>&gt; </b> NVM is able to provide the Config Id’s RAM block on its own. </p>
<p><b>&gt; </b></p>
<p>NvM_WriteAll()</p>
<p> does not write unchanged data, even if this would repair (redundant) </p>
<p>NV data. </p>
<p><b>&gt; </b> Attempts to write to a locked block (</p>
<p>NvM_SetBlockLockStatus</p>
<p>) are explicitly not </p>
<p>treated as Development Error; error NVM_E_BLOCK_LOCKED is not defined. </p>
<p><b>&gt; </b></p>
<p>NvM_SetBlockLockStatus</p>
<p> is allowed for pending Blocks; no related Development </p>
<p>Error Check will be performed. </p>
<p><b>&gt; </b> Block CRC type CRC8 is not supported. </p>
<p><b>&gt; </b> Write retries can only be globally configured, rather than individually per NVRAM Block </p>
<p><b>&gt; </b> Calls to Explicit Synchronization callbacks (see chapter 4.4.18) cannot be limited by </p>
<p>configuration. Rather those functions are expected to succeed within few attempts. </p>
<p><b>8.2 </b></p>
<p><b>Additions/ Extensions </b></p>
<p><b>8.2.1 </b></p>
<p><b>Parameter Checking </b></p>
<p>The  internal parameter checks  of  the API functions  can be en-/disabled  separately. The </p>
<p>AUTOSAR standard requires en-/disabling of the complete parameter checking only. For </p>
<p>details see chapter 4.5.1.1. </p>
<p><b>8.2.2 </b></p>
<p><b>Concurrent access to NV data </b></p>
<p>NVM provides for DCM possibility to access NV data concurrently with NVM application. </p>
<p>(see chapter 4.4.17) </p>
<p><b>8.2.3 </b></p>
<p><b>RAM-/ROM Block Size checks </b></p>
<p>NVM can be configured to check all RAM and ROM blocks’ lengths against corresponding </p>
<p>NV Block lengths, using </p>
<p>sizeof</p>
<p> operator; see chapter 4.5.3. </p>
<p><b>8.2.4 </b></p>
<p><b>Calculated CRC value does not depend on number of calculation steps </b></p>
<p>Due to the specified CRC32 algorithm, and missing further requirements on NVM’s CRC </p>
<p>calculation,  a  calculated  CRC32  value  depends on  the  number of  necessary  calculation </p>
<p>steps  (defined by  block  length  and parameter <b> CRC  Bytes  per  Cycle</b>).  Unless  the  CRC </p>
<p>can be calculated with one step (i.e. the block is small enough), the CRC32 value will not </p>
<p>match the value resulting from calling the CRC32 library function once for the whole block. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 5.07.01 </p>
<p>79 </p>
<p>based on template version 3.01 </p>
<p>The reason is the negation of the result, as specified for CRC32 (which in turn belongs to </p>
<p>standard/widely used <b>Ethernet CRC</b>). This behavior introduces some drawbacks on NVM, </p>
<p>especially:  </p>
<p><b>&gt; </b> Changing parameter <b>CRC Bytes per Cycle </b>(for run-time optimization), in an existing </p>
<p>(already flashed) project. Data blocks with CRC32 could not be read after the update. </p>
<p><b>&gt; </b> CRC32 values cannot be verified outside NVM (e.g. for testing purposes), without </p>
<p>knowing the configuration – each single step would have to be reproduced. </p>
<p><b>&gt; </b> Valid data blocks along with their CRC32 cannot be pre-defined using standard CRC </p>
<p>algorithms. </p>
<p>NVM circumvents these restrictions by reverting the final negation of each single CRC32 </p>
<p>calculation step, except the last one. This (quite simple) measure guarantees that the CRC </p>
<p>value does NOT depend on the number of calculation steps, as it is originally guaranteed </p>
<p>for CRC16 (since it will not be inverted by the CRC library). </p>
<p><b>8.3 </b></p>
<p><b>Limitations </b></p>
<p>There are no limitations. </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 5.07.01 </p>
<p>80 </p>
<p>based on template version 3.01 </p>
<p><b>9 </b></p>
<p><b>Glossary and Abbreviations </b></p>
<p><b>9.1 </b></p>
<p><b>Glossary </b></p>
<p><b>Term </b></p>
<p><b>Description </b></p>
<p>DaVinci Configurator </p>
<p>Pro </p>
<p>Configuration and generation tool for MICROSAR. </p>
<p>DCM </p>
<p>Diagnostic Communication Manager </p>
<p>GCE </p>
<p>Generic Configuration Editor – generic tool for editing AUTOSAR </p>
<p>configuration files. </p>
<p>In DaVinci Configurator, the view can be switch to <b>Generic Editor</b>. </p>
<p>Per Instance Memory </p>
<p>(PIM) </p>
<p>Memory (RAM) to be used by an instance of an Softwar Component, </p>
<p>provide by RTE. It may also be used as permanent or tempary RAM </p>
<p>block. </p>
<p>Such a memory need is usually modeled using a tool like DaVinci </p>
<p>Developer. </p>
<p>Primary NV Block </p>
<p>The first NV block of an NVRAM Block of type Redundant. During reads, </p>
<p>this block will always be tried first. During writes it will be preferred, </p>
<p>unless only secondary is defective. </p>
<p>Secondary NV Block </p>
<p>The second NV block of an NVRAM Block of type Redundant. During </p>
<p>reads and this block will be accessed second; if primary is defective. </p>
<p>Table 9-1  </p>
<p>Glossary </p>
<p><b>9.2 </b></p>
<p><b>Abbreviations </b></p>
<p><b>Abbreviation </b></p>
<p><b>Description </b></p>
<p>API </p>
<p>Application Programming Interface </p>
<p> </p>
<p>AUTOSAR </p>
<p>Automotive Open System Architecture </p>
<p>BSW </p>
<p>Basis Software </p>
<p>CRC </p>
<p>Cyclic Redundancy Check </p>
<p>DEM </p>
<p>Diagnostic Event Manager </p>
<p>DET </p>
<p>Development Error Tracer </p>
<p>DPA </p>
<p>DaVinci Project Assistant </p>
<p>EA </p>
<p>EEPROM Abstraction Module </p>
<p>ECU </p>
<p>Electronic Control Unit </p>
<p>ECUC </p>
<p>ECU Configuration </p>
<p>ECUM </p>
<p>ECU State Manager </p>
<p>EEP </p>
<p>EEPROM Driver </p>
<p>EEPROM </p>
<p>Electrically Erasable Programmable Read Only Memory </p>
<p>FEE </p>
<p>Flash EEPROM Emulation Module </p>
<p>FIFO </p>
<p>First In First Out </p>
<p>FLS </p>
<p>Flash Driver </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 5.07.01 </p>
<p>81 </p>
<p>based on template version 3.01 </p>
<p>GCE </p>
<p>Generic Configuration Editor </p>
<p>HIS </p>
<p>Hersteller Initiative Software </p>
<p>ISR </p>
<p>Interrupt Service Routine </p>
<p>MemHwA </p>
<p>Memory Hardware Abstraction Layer </p>
<p>MEMIF </p>
<p>Memory Abstraction Interface Module </p>
<p>MICROSAR </p>
<p>Microcontroller Open System Architecture (the Vector AUTOSAR </p>
<p>solution) </p>
<p>NVM </p>
<p>NVRAM Manager </p>
<p>NV, NVRAM </p>
<p>Non Volatile Random Access Memory </p>
<p>OS </p>
<p>Operating System </p>
<p>PPort </p>
<p>Provide Port </p>
<p>RAM </p>
<p>Random Access Memory </p>
<p>ROM </p>
<p>Read Only Memory </p>
<p>RPort </p>
<p>Require Port </p>
<p>RTE </p>
<p>Runtime Environment </p>
<p>SRS </p>
<p>Software Requirement Specification </p>
<p>SWC </p>
<p>Software Component </p>
<p>SWS </p>
<p>Software Specification </p>
<p>Table 9-2  </p>
<p>Abbreviations </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR NVM </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 5.07.01 </p>
<p>82 </p>
<p>based on template version 3.01 </p>
<p><b>10  Contact </b></p>
<p>Visit our website for more information on </p>
<p> </p>
<p><b>&gt; </b>  News </p>
<p><b>&gt; </b> Products </p>
<p><b>&gt; </b> Demo software </p>
<p><b>&gt; </b> Support </p>
<p><b>&gt; </b> Training data </p>
<p><b>&gt; </b> Addresses </p>
<p> </p>
<p><b>www.vector.com </b></p>
<p> </p>
</body>
</html>
{% endraw %}