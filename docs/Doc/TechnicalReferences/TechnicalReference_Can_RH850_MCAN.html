---
layout: default
title: TechnicalReference_Can_RH850_MCAN
nav_order: 23
parent: Doc
---
{% raw %}
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
     "http://www.w3.org/TR/html4/transitional.dtd">
<html>
<head>

  <meta http-equiv="content-type" content="text/html; charset=utf-8"/>
  <title></title>
  <meta name="generator" content="LibreOffice 24.2.7.2 (Linux)"/>
  <meta name="created" content="00:00:00"/>
  <meta name="changed" content="00:00:00"/>
</head>
<body>
<h1></h1>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p><b>MICROSAR CAN Driver </b></p>
<p>Technical Reference    </p>
<p> </p>
<p>Renesas RH850/P1x-C  MCAN </p>
<p>Version 3.00.01 </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>Authors </p>
<p>P. Herrmann </p>
<p>Status </p>
<p>Released </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference    MICROSAR CAN Driver </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 3.00.01 </p>
<p>2 </p>
<p><b>1 </b></p>
<p><b>Document Information </b></p>
<p><b>1.1 </b></p>
<p><b>History </b></p>
<p><b>Author </b></p>
<p><b>Date </b></p>
<p><b>Version </b></p>
<p><b>Remarks </b></p>
<p>P. Herrmann </p>
<p>2017-02-22 </p>
<p>1.00.00 </p>
<p>Creation based on SPC58xx description </p>
<p>P. Herrmann </p>
<p>G.Pflügel </p>
<p>2017-04-25 </p>
<p>1.01.00 </p>
<p>Added latest MCAN Bosch Errata (#16, #17, #18) </p>
<p>Added MCAN independent Errata for Aurix Plus </p>
<p>G.Pflügel </p>
<p>2017-07-26 </p>
<p>2.00.00 </p>
<p>Restructure of history </p>
<p>P. Herrmann </p>
<p>2017-08-03 </p>
<p>2.01.00 </p>
<p>Updated SPC574Kxx derivative decription for new </p>
<p>cut 2.4 hardware revision. </p>
<p>Enhanced description in chapter  </p>
<p>- 4.8.3 “Hardware Loop Check / Timeout </p>
<p>Monitoring” </p>
<p>- 4.10 “Hardware Specific” </p>
<p>G.Pflügel </p>
<p>2017-08-21 </p>
<p>2.02.00 </p>
<p>- Platform SAM V71 and Traveo merged together </p>
<p>and renamed to platform Arm32Mcan </p>
<p>- Platform Telemaco and compiler ARM added to </p>
<p>platform Arm32Mcan  </p>
<p>P. Herrmann </p>
<p>2017-09-18 </p>
<p>2.03.00 </p>
<p>Enhanced ch. 4.8.1 “Dev. Error Reporting” </p>
<p>P. Herrmann </p>
<p>2017-10-05 </p>
<p>2.04.00 </p>
<p>Added Silent Mode </p>
<p>P. Herrmann </p>
<p>2017-11-21 </p>
<p>2.05.00 </p>
<p>Template update, enhanced Silent Mode </p>
<p>description </p>
<p>P. Herrmann </p>
<p>2018-01-15 </p>
<p>2.06.00 </p>
<p>Dynamic MCAN Revision detection </p>
<p>M. Huse </p>
<p>2018-02-27 </p>
<p>2.07.00 </p>
<p>Extended Ram Check </p>
<p>P. Herrmann </p>
<p>2018-03-02 </p>
<p>2.08.00 </p>
<p>Telemaco3P STA1385 Cut2.1 </p>
<p>G.Pflügel </p>
<p>2018-03-28 </p>
<p>2.09.00 </p>
<p>Tricore TC38x and TC39x Step_B added </p>
<p>M. Huse </p>
<p>2018-04-04 </p>
<p>2.10.00 </p>
<p>BCM89103 added </p>
<p>M. Huse </p>
<p>2018-04-11 </p>
<p>2.11.00 </p>
<p>Updated API description   </p>
<p>C. Huo </p>
<p>2018-04-12 </p>
<p>2.12.00 </p>
<p>TDA3x added </p>
<p>M. Huse </p>
<p>2018-04-19 </p>
<p>3.00.00 </p>
<p>Updated document for multi driver compatibility </p>
<p>M. Huse </p>
<p>2018-05-07 </p>
<p>3.00.01 </p>
<p>Updated ISR section for multi driver compatibility. </p>
<p>Table 1-1  </p>
<p>Document History </p>
<p><b>1.2 </b></p>
<p><b>Reference Documents </b></p>
<p><b>No. </b></p>
<p><b>Title </b></p>
<p><b>Version </b></p>
<p>[1] </p>
<p> </p>
<p>AUTOSAR_SWS_CAN_DRIVER.pdf </p>
<p>2.4.6 +  </p>
<p>3.0.0 + </p>
<p>4.0.0 </p>
<p>[2] </p>
<p> </p>
<p>AUTOSAR_BasicSoftwareModules.pdf </p>
<p>V1.0.0 </p>
<p>[3] </p>
<p> </p>
<p>AUTOSAR_SWS BSW Scheduler </p>
<p>V1.1.0 </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference    MICROSAR CAN Driver </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 3.00.01 </p>
<p>3 </p>
<p>[4] </p>
<p> </p>
<p>AUTOSAR_SWS_CAN_Interface.pdf </p>
<p>3.2.7 +  </p>
<p>4.0.0 + </p>
<p>5.0.0 </p>
<p>[5] </p>
<p> </p>
<p>AN-ISC-8-1118 MICROSAR BSW Compatibility Check </p>
<p>V1.0.0 </p>
<p>[6] </p>
<p> </p>
<p>M_CAN Controller Area Network Errata Sheet  </p>
<p>REL2015 0701 </p>
<p>[7] </p>
<p> </p>
<p>Appl. Note AN-ISC-8-1190 CAN Self Diag   </p>
<p>1.1.0 </p>
<p>Table 1-2  </p>
<p>Reference Documents </p>
<p><b>1.3 </b></p>
<p><b>Scope of the Document </b></p>
<p>This document describes the functionality, API and configuration of the MICROSAR CAN </p>
<p>Driver as specified in [1]. The CAN Driver is a hardware abstraction layer with a </p>
<p>standardized interface to the CAN Interface layer. </p>
<p> </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>We have configured the programs in accordance with your specifications in the </p>
<p>questionnaire. Whereas the programs do support other configurations than the one </p>
<p>specified in your questionnaire, Vector’s release of the programs delivered to your </p>
<p>company is expressly restricted to the configuration you have specified in the </p>
<p>questionnaire. </p>
<p><b> </b></p>
<p><b> </b></p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference    MICROSAR CAN Driver </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 3.00.01 </p>
<p>4 </p>
<p><b>Content </b></p>
<p><b>1</b></p>
<p> </p>
<p><b>Document Information ................................................................................................. 2</b></p>
<p> </p>
<p>1.1</p>
<p> </p>
<p>History ............................................................................................................... 2</p>
<p> </p>
<p>1.2</p>
<p> </p>
<p>Reference Documents ....................................................................................... 2</p>
<p> </p>
<p>1.3</p>
<p> </p>
<p>Scope of the Document...................................................................................... 3</p>
<p> </p>
<p><b>2</b></p>
<p> </p>
<p><b>Hardware Overview .................................................................................................... 10</b></p>
<p> </p>
<p><b>3</b></p>
<p> </p>
<p><b>Introduction................................................................................................................. 11</b></p>
<p> </p>
<p>3.1</p>
<p> </p>
<p>Architecture Overview ...................................................................................... 11</p>
<p> </p>
<p><b>4</b></p>
<p> </p>
<p><b>Functional Description ............................................................................................... 14</b></p>
<p> </p>
<p>4.1</p>
<p> </p>
<p>Features .......................................................................................................... 14</p>
<p> </p>
<p>4.2</p>
<p> </p>
<p>Initialization ...................................................................................................... 19</p>
<p> </p>
<p>4.3</p>
<p> </p>
<p>Communication ................................................................................................ 19</p>
<p> </p>
<p>4.3.1</p>
<p> </p>
<p>Mailbox Layout ................................................................................. 20</p>
<p> </p>
<p>4.3.2</p>
<p> </p>
<p>Mailbox Processing Order ................................................................ 21</p>
<p> </p>
<p>4.3.3</p>
<p> </p>
<p>Acceptance Filter for BasicCAN ....................................................... 21</p>
<p> </p>
<p>4.3.4</p>
<p> </p>
<p>Remote Frames ............................................................................... 22</p>
<p> </p>
<p>4.4</p>
<p> </p>
<p>States / Modes ................................................................................................. 22</p>
<p> </p>
<p>4.4.1</p>
<p> </p>
<p>Start Mode (Normal Running Mode) ................................................. 22</p>
<p> </p>
<p>4.4.2</p>
<p> </p>
<p>Stop Mode ....................................................................................... 22</p>
<p> </p>
<p>4.4.3</p>
<p> </p>
<p>Power Down Mode ........................................................................... 22</p>
<p> </p>
<p>4.4.4</p>
<p> </p>
<p>Bus Off ............................................................................................. 23</p>
<p> </p>
<p>4.4.5</p>
<p> </p>
<p>Silent Mode ...................................................................................... 23</p>
<p> </p>
<p>4.4.6</p>
<p> </p>
<p>Dynamic MCAN detection ................................................................ 24</p>
<p> </p>
<p>4.5</p>
<p> </p>
<p>Re-Initialization ................................................................................................ 25</p>
<p> </p>
<p>4.6</p>
<p> </p>
<p>CAN Interrupt Locking ...................................................................................... 25</p>
<p> </p>
<p>4.7</p>
<p> </p>
<p>Main Functions ................................................................................................ 25</p>
<p> </p>
<p>4.8</p>
<p> </p>
<p>Error Handling .................................................................................................. 26</p>
<p> </p>
<p>4.8.1</p>
<p> </p>
<p>Development Error Reporting ........................................................... 26</p>
<p> </p>
<p>4.8.2</p>
<p> </p>
<p>Production Code Error Reporting ..................................................... 28</p>
<p> </p>
<p>4.8.3</p>
<p> </p>
<p>Hardware Loop Check / Timeout Monitoring .................................... 28</p>
<p> </p>
<p>4.8.4</p>
<p> </p>
<p>CAN RAM Check ............................................................................. 32</p>
<p> </p>
<p>4.8.5</p>
<p> </p>
<p>Extended RAM Check ...................................................................... 32</p>
<p> </p>
<p>4.9</p>
<p> </p>
<p>Common CAN .................................................................................................. 33</p>
<p> </p>
<p>4.10</p>
<p> </p>
<p>Hardware Specific ............................................................................................ 33</p>
<p> </p>
<p>4.10.1</p>
<p> </p>
<p>Error Interrupt................................................................................... 34</p>
<p> </p>
<p>4.10.2</p>
<p> </p>
<p>Not supported .................................................................................. 34</p>
<p> </p>
<p><b>5</b></p>
<p> </p>
<p><b>Integration ................................................................................................................... 35</b></p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference    MICROSAR CAN Driver </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 3.00.01 </p>
<p>5 </p>
<p>5.1</p>
<p> </p>
<p>Scope of Delivery ............................................................................................. 35</p>
<p> </p>
<p>5.1.1</p>
<p> </p>
<p>Static Files ....................................................................................... 35</p>
<p> </p>
<p>5.1.2</p>
<p> </p>
<p>Dynamic Files .................................................................................. 35</p>
<p> </p>
<p>5.2</p>
<p> </p>
<p>Include Structure .............................................................................................. 36</p>
<p> </p>
<p>5.3</p>
<p> </p>
<p>Critical Sections ............................................................................................... 36</p>
<p> </p>
<p>5.4</p>
<p> </p>
<p>Compiler Abstraction and Memory Mapping ..................................................... 38</p>
<p> </p>
<p><b>6</b></p>
<p> </p>
<p><b>Hardware Specific Hints ............................................................................................. 41</b></p>
<p> </p>
<p>6.1</p>
<p> </p>
<p>Usage of interrupt functions ............................................................................. 41</p>
<p> </p>
<p>6.2</p>
<p> </p>
<p>MCAN Errata ................................................................................................... 41</p>
<p> </p>
<p>6.3</p>
<p> </p>
<p>Platform Errata ................................................................................................. 44</p>
<p> </p>
<p><b>7</b></p>
<p> </p>
<p><b>API Description ........................................................................................................... 45</b></p>
<p> </p>
<p>7.1</p>
<p> </p>
<p>Interrupt Service Routines provided by CAN .................................................... 45</p>
<p> </p>
<p>7.1.1</p>
<p> </p>
<p>OSEK (OS) ...................................................................................... 45</p>
<p> </p>
<p>7.1.2</p>
<p> </p>
<p>AutoSar (OS) ................................................................................... 45</p>
<p> </p>
<p>7.1.3</p>
<p> </p>
<p>None (OS) ........................................................................................ 45</p>
<p> </p>
<p>7.1.4</p>
<p> </p>
<p>Type of Interrupt Function ................................................................ 46</p>
<p> </p>
<p>7.1.5</p>
<p> </p>
<p>CAN ISR API .................................................................................... 46</p>
<p> </p>
<p>7.2</p>
<p> </p>
<p>Services provided by CAN ............................................................................... 46</p>
<p> </p>
<p>7.2.1</p>
<p> </p>
<p>Can_InitMemory ............................................................................... 46</p>
<p> </p>
<p>7.2.2</p>
<p> </p>
<p>Can_Init ........................................................................................... 47</p>
<p> </p>
<p>7.2.3</p>
<p> </p>
<p>Can_InitController ............................................................................ 48</p>
<p> </p>
<p>7.2.4</p>
<p> </p>
<p>Can_InitController ............................................................................ 48</p>
<p> </p>
<p>7.2.5</p>
<p> </p>
<p>Can_ChangeBaudrate ..................................................................... 49</p>
<p> </p>
<p>7.2.6</p>
<p> </p>
<p>Can_CheckBaudrate ........................................................................ 50</p>
<p> </p>
<p>7.2.7</p>
<p> </p>
<p>Can_SetBaudrate ............................................................................ 50</p>
<p> </p>
<p>7.2.8</p>
<p> </p>
<p>Can_InitStruct .................................................................................. 51</p>
<p> </p>
<p>7.2.9</p>
<p> </p>
<p>Can_GetVersionInfo ......................................................................... 52</p>
<p> </p>
<p>7.2.10</p>
<p> </p>
<p>Can_GetStatus ................................................................................ 52</p>
<p> </p>
<p>7.2.11</p>
<p> </p>
<p>Can_SetControllerMode ................................................................... 54</p>
<p> </p>
<p>7.2.12</p>
<p> </p>
<p>Can_ResetBusOffStart ..................................................................... 54</p>
<p> </p>
<p>7.2.13</p>
<p> </p>
<p>Can_ResetBusOffEnd ...................................................................... 55</p>
<p> </p>
<p>7.2.14</p>
<p> </p>
<p>Can_Write ........................................................................................ 55</p>
<p> </p>
<p>7.2.15</p>
<p> </p>
<p>Can_CancelTx ................................................................................. 56</p>
<p> </p>
<p>7.2.16</p>
<p> </p>
<p>Can_SetMirrorMode ......................................................................... 57</p>
<p> </p>
<p>7.2.17</p>
<p> </p>
<p>Can_SetSilentMode ......................................................................... 57</p>
<p> </p>
<p>7.2.18</p>
<p> </p>
<p>Can_CheckWakeup ......................................................................... 58</p>
<p> </p>
<p>7.2.19</p>
<p> </p>
<p>Can_DisableControllerInterrupts ...................................................... 58</p>
<p> </p>
<p>7.2.20</p>
<p> </p>
<p>Can_EnableControllerInterrupts ....................................................... 59</p>
<p> </p>
<p>7.2.21</p>
<p> </p>
<p>Can_MainFunction_Write ................................................................. 60</p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference    MICROSAR CAN Driver </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 3.00.01 </p>
<p>6 </p>
<p>7.2.22</p>
<p> </p>
<p>Can_MainFunction_Read ................................................................ 60</p>
<p> </p>
<p>7.2.23</p>
<p> </p>
<p>Can_MainFunction_BusOff .............................................................. 61</p>
<p> </p>
<p>7.2.24</p>
<p> </p>
<p>Can_MainFunction_Wakeup ............................................................ 61</p>
<p> </p>
<p>7.2.25</p>
<p> </p>
<p>Can_MainFunction_Mode ................................................................ 62</p>
<p> </p>
<p>7.2.26</p>
<p> </p>
<p>Can_RamCheckExecute .................................................................. 62</p>
<p> </p>
<p>7.2.27</p>
<p> </p>
<p>Can_RamCheckEnableMailbox ....................................................... 63</p>
<p> </p>
<p>7.2.28</p>
<p> </p>
<p>Can_RamCheckEnableController .................................................... 63</p>
<p> </p>
<p>7.2.29</p>
<p> </p>
<p>Appl_GenericPrecopy ...................................................................... 64</p>
<p> </p>
<p>7.2.30</p>
<p> </p>
<p>Appl_GenericConfirmation ............................................................... 65</p>
<p> </p>
<p>7.2.31</p>
<p> </p>
<p>Appl_GenericConfirmation ............................................................... 66</p>
<p> </p>
<p>7.2.32</p>
<p> </p>
<p>Appl_GenericPreTransmit ................................................................ 66</p>
<p> </p>
<p>7.2.33</p>
<p> </p>
<p>ApplCanTimerStart ........................................................................... 67</p>
<p> </p>
<p>7.2.34</p>
<p> </p>
<p>ApplCanTimerLoop .......................................................................... 68</p>
<p> </p>
<p>7.2.35</p>
<p> </p>
<p>ApplCanTimerEnd ............................................................................ 68</p>
<p> </p>
<p>7.2.36</p>
<p> </p>
<p>ApplCanInterruptDisable .................................................................. 69</p>
<p> </p>
<p>7.2.37</p>
<p> </p>
<p>ApplCanInterruptRestore ................................................................. 70</p>
<p> </p>
<p>7.2.38</p>
<p> </p>
<p>Appl_CanOverrun ............................................................................ 70</p>
<p> </p>
<p>7.2.39</p>
<p> </p>
<p>Appl_CanFullCanOverrun ................................................................ 71</p>
<p> </p>
<p>7.2.40</p>
<p> </p>
<p>Appl_CanCorruptMailbox ................................................................. 72</p>
<p> </p>
<p>7.2.41</p>
<p> </p>
<p>Appl_CanRamCheckFailed .............................................................. 72</p>
<p> </p>
<p>7.2.42</p>
<p> </p>
<p>ApplCanInitPostProcessing .............................................................. 73</p>
<p> </p>
<p>7.3</p>
<p> </p>
<p>Services used by CAN ..................................................................................... 74</p>
<p> </p>
<p><b>8</b></p>
<p> </p>
<p><b>Configuration .............................................................................................................. 76</b></p>
<p> </p>
<p>8.1</p>
<p> </p>
<p>Pre-Compile Parameters .................................................................................. 76</p>
<p> </p>
<p>8.2</p>
<p> </p>
<p>Link-Time Parameters ...................................................................................... 77</p>
<p> </p>
<p>8.3</p>
<p> </p>
<p>Post-Build Parameters ..................................................................................... 77</p>
<p> </p>
<p>8.4</p>
<p> </p>
<p>Configuration with GENy .................................................................................. 78</p>
<p> </p>
<p>8.4.1</p>
<p> </p>
<p>Platform Settings .............................................................................. 78</p>
<p> </p>
<p>8.4.2</p>
<p> </p>
<p>Component Settings......................................................................... 80</p>
<p> </p>
<p>8.4.3</p>
<p> </p>
<p>Individual Polling Settings ................................................................ 85</p>
<p> </p>
<p>8.4.4</p>
<p> </p>
<p>Common CAN settings ..................................................................... 86</p>
<p> </p>
<p>8.4.5</p>
<p> </p>
<p>Controller (Channel) Settings ........................................................... 86</p>
<p> </p>
<p>8.5</p>
<p> </p>
<p>Configuration with da DaVinci Configurator ...................................................... 95</p>
<p> </p>
<p><b>9</b></p>
<p> </p>
<p><b>AUTOSAR Standard Compliance............................................................................... 96</b></p>
<p> </p>
<p>9.1</p>
<p> </p>
<p>Limitations / Restrictions .................................................................................. 96</p>
<p> </p>
<p>9.2</p>
<p> </p>
<p>Hardware Limitations ....................................................................................... 96</p>
<p> </p>
<p>9.2.1</p>
<p> </p>
<p>Tx side ............................................................................................. 96</p>
<p> </p>
<p>9.2.2</p>
<p> </p>
<p>Rx side ............................................................................................. 96</p>
<p> </p>
<p>9.2.3</p>
<p> </p>
<p>Used resources ................................................................................ 96</p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference    MICROSAR CAN Driver </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 3.00.01 </p>
<p>7 </p>
<p>9.2.4</p>
<p> </p>
<p>Initialization of the CAN Message RAM ............................................ 97</p>
<p> </p>
<p>9.2.5</p>
<p> </p>
<p>Multiple configuration ....................................................................... 97</p>
<p> </p>
<p>9.3</p>
<p> </p>
<p>Vector Extensions .......................................................................................... 100</p>
<p> </p>
<p><b>10</b></p>
<p> </p>
<p><b>Glossary and Abbreviations .................................................................................... 101</b></p>
<p> </p>
<p>10.1</p>
<p> </p>
<p>Glossary ........................................................................................................ 101</p>
<p> </p>
<p>10.2</p>
<p> </p>
<p>Abbreviations ................................................................................................. 101</p>
<p> </p>
<p><b>11</b></p>
<p> </p>
<p><b>Contact ...................................................................................................................... 102</b></p>
<p> </p>
<p>  </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference    MICROSAR CAN Driver </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 3.00.01 </p>
<p>8 </p>
<p><b>Illustrations </b></p>
<p>Figure 3-1</p>
<p> </p>
<p>AUTOSAR architecture ............................................................................. 12</p>
<p> </p>
<p>Figure 3-2</p>
<p> </p>
<p>Interfaces to adjacent modules of the CAN ............................................... 13</p>
<p> </p>
<p>Figure 4-1</p>
<p> </p>
<p>Bus Monitoring Mode. ............................................................................... 24</p>
<p> </p>
<p>Figure 5-1</p>
<p> </p>
<p>Include Structure (AUTOSAR) .................................................................. 36</p>
<p> </p>
<p>Figure 7-1</p>
<p> </p>
<p>Select OS Type ......................................................................................... 45</p>
<p> </p>
<p>Figure 8-1</p>
<p> </p>
<p>Platform Settings ...................................................................................... 78</p>
<p> </p>
<p>Figure 8-2</p>
<p> </p>
<p>Controller Settings .................................................................................... 87</p>
<p> </p>
<p>Figure 8-3</p>
<p> </p>
<p>Init Structure Dialog .................................................................................. 88</p>
<p> </p>
<p>Figure 8-4</p>
<p> </p>
<p>Init Structure description ........................................................................... 89</p>
<p> </p>
<p>Figure 8-5</p>
<p> </p>
<p>Hardware description ................................................................................ 89</p>
<p> </p>
<p>Figure 8-6</p>
<p> </p>
<p>Setup Filter Dialog .................................................................................... 90</p>
<p> </p>
<p>Figure 8-7</p>
<p> </p>
<p>Baud Rate Dialog ..................................................................................... 92</p>
<p> </p>
<p>Figure 8-8</p>
<p> </p>
<p>CAN-FD Baud Rate Dialog ....................................................................... 93</p>
<p> </p>
<p>Figure 9-1</p>
<p> </p>
<p>Correct Identity Mapping example ............................................................ 98</p>
<p> </p>
<p>Figure 9-2</p>
<p> </p>
<p>Correct CAN Message RAM allocation example ....................................... 98</p>
<p> </p>
<p>Figure 9-3</p>
<p> </p>
<p>Faulty Identity Mapping example .............................................................. 99</p>
<p> </p>
<p>Figure 9-4</p>
<p> </p>
<p>Faulty CAN Message RAM allocation example ......................................... 99</p>
<p> </p>
<p> </p>
<p><b>Tables </b></p>
<p>Table 1-1 </p>
<p> </p>
<p>Document History ....................................................................................... 2</p>
<p> </p>
<p>Table 1-2 </p>
<p> </p>
<p>Reference Documents ................................................................................ 3</p>
<p> </p>
<p>Table 2-1 </p>
<p> </p>
<p>Supported Hardware Overview ................................................................. 10</p>
<p> </p>
<p>Table 4-1 </p>
<p> </p>
<p>Supported features ................................................................................... 19</p>
<p> </p>
<p>Table 4-2 </p>
<p> </p>
<p>Errors reported to DET ............................................................................. 26</p>
<p> </p>
<p>Table 4-3</p>
<p> </p>
<p>API from which the Errors are reported ..................................................... 27</p>
<p> </p>
<p>Table 4-4 </p>
<p> </p>
<p>Errors reported to DEM ............................................................................. 28</p>
<p> </p>
<p>Table 4-5 </p>
<p> </p>
<p>Hardware Loop Check (critical) ................................................................. 29</p>
<p> </p>
<p>Table 4-6 </p>
<p> </p>
<p>Hardware Loop Check (uncritical) ............................................................. 30</p>
<p> </p>
<p>Table 4-7 </p>
<p> </p>
<p>Hardware Loop Check (synchronous mode transition) .............................. 31</p>
<p> </p>
<p>Table 5-1 </p>
<p> </p>
<p>Static files ................................................................................................. 35</p>
<p> </p>
<p>Table 5-2 </p>
<p> </p>
<p>Generated files ......................................................................................... 35</p>
<p> </p>
<p>Table 5-3 </p>
<p> </p>
<p>Critical Section Codes .............................................................................. 38</p>
<p> </p>
<p>Table 5-4 </p>
<p> </p>
<p>Compiler abstraction and memory mapping .............................................. 39</p>
<p> </p>
<p>Table 6-1 </p>
<p> </p>
<p>MCAN Errata ............................................................................................ 44</p>
<p> </p>
<p>Table 7-1 </p>
<p> </p>
<p>MCAN CanIsr_&lt;x&gt;.................................................................................... 46</p>
<p> </p>
<p>Table 7-2 </p>
<p> </p>
<p>Can_InitMemory ....................................................................................... 47</p>
<p> </p>
<p>Table 7-3 </p>
<p> </p>
<p>Can_Init .................................................................................................... 48</p>
<p> </p>
<p>Table 7-4 </p>
<p> </p>
<p>Can_InitController ..................................................................................... 48</p>
<p> </p>
<p>Table 7-5 </p>
<p> </p>
<p>Can_InitController ..................................................................................... 49</p>
<p> </p>
<p>Table 7-6 </p>
<p> </p>
<p>Can_ChangeBaudrate .............................................................................. 50</p>
<p> </p>
<p>Table 7-7 </p>
<p> </p>
<p>Can_CheckBaudrate ................................................................................ 50</p>
<p> </p>
<p>Table 7-8 </p>
<p> </p>
<p>Can_SetBaudrate ..................................................................................... 51</p>
<p> </p>
<p>Table 7-9 </p>
<p> </p>
<p>Can_InitStruct ........................................................................................... 52</p>
<p> </p>
<p>Table 7-10 </p>
<p> </p>
<p>Can_GetVersionInfo ................................................................................. 52</p>
<p> </p>
<p>Table 7-11 </p>
<p> </p>
<p>Can_GetStatus ......................................................................................... 53</p>
<p> </p>
<p>Table 7-12 </p>
<p> </p>
<p>Can_SetControllerMode ........................................................................... 54</p>
<p> </p>
<p>Table 7-13 </p>
<p> </p>
<p>Can_ResetBusOffStart ............................................................................. 55</p>
<p> </p>
<p>Table 7-14 </p>
<p> </p>
<p>Can_ResetBusOffEnd .............................................................................. 55</p>
<p> </p>
<p>Table 7-15 </p>
<p> </p>
<p>Can_Write................................................................................................. 56</p>
<p> </p>
<p>Table 7-16 </p>
<p> </p>
<p>Can_CancelTx .......................................................................................... 57</p>
<p> </p>
<p>Table 7-17 </p>
<p> </p>
<p>Can_SetMirrorMode ................................................................................. 57</p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference    MICROSAR CAN Driver </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 3.00.01 </p>
<p>9 </p>
<p>Table 7-18 </p>
<p> </p>
<p>Can_SetSilentMode .................................................................................. 58</p>
<p> </p>
<p>Table 7-19 </p>
<p> </p>
<p>Can_CheckWakeup .................................................................................. 58</p>
<p> </p>
<p>Table 7-20 </p>
<p> </p>
<p>Can_DisableControllerInterrupts ............................................................... 59</p>
<p> </p>
<p>Table 7-21 </p>
<p> </p>
<p>Can_EnableControllerInterrupts................................................................ 59</p>
<p> </p>
<p>Table 7-22 </p>
<p> </p>
<p>Can_MainFunction_Write ......................................................................... 60</p>
<p> </p>
<p>Table 7-23 </p>
<p> </p>
<p>Can_MainFunction_Read ......................................................................... 61</p>
<p> </p>
<p>Table 7-24 </p>
<p> </p>
<p>Can_MainFunction_BusOff ....................................................................... 61</p>
<p> </p>
<p>Table 7-25 </p>
<p> </p>
<p>Can_MainFunction_Wakeup ..................................................................... 62</p>
<p> </p>
<p>Table 7-26 </p>
<p> </p>
<p>Can_MainFunction_Mode ......................................................................... 62</p>
<p> </p>
<p>Table 7-27 </p>
<p> </p>
<p>Can_RamCheckExecute .......................................................................... 63</p>
<p> </p>
<p>Table 7-28 </p>
<p> </p>
<p>Can_RamCheckEnableMailbox ................................................................ 63</p>
<p> </p>
<p>Table 7-29 </p>
<p> </p>
<p>Can_RamCheckEnableController ............................................................. 64</p>
<p> </p>
<p>Table 7-30 </p>
<p> </p>
<p>Appl_GenericPrecopy ............................................................................... 65</p>
<p> </p>
<p>Table 7-31 </p>
<p> </p>
<p>Appl_GenericConfirmation ........................................................................ 65</p>
<p> </p>
<p>Table 7-32 </p>
<p> </p>
<p>Appl_GenericConfirmation ........................................................................ 66</p>
<p> </p>
<p>Table 7-33 </p>
<p> </p>
<p>Appl_GenericPreTransmit ......................................................................... 67</p>
<p> </p>
<p>Table 7-34 </p>
<p> </p>
<p>ApplCanTimerStart ................................................................................... 67</p>
<p> </p>
<p>Table 7-35 </p>
<p> </p>
<p>ApplCanTimerLoop ................................................................................... 68</p>
<p> </p>
<p>Table 7-36 </p>
<p> </p>
<p>ApplCanTimerEnd .................................................................................... 69</p>
<p> </p>
<p>Table 7-37 </p>
<p> </p>
<p>ApplCanInterruptDisable ........................................................................... 70</p>
<p> </p>
<p>Table 7-38 </p>
<p> </p>
<p>ApplCanInterruptRestore .......................................................................... 70</p>
<p> </p>
<p>Table 7-39 </p>
<p> </p>
<p>Appl_CanOverrun ..................................................................................... 71</p>
<p> </p>
<p>Table 7-40 </p>
<p> </p>
<p>Appl_CanFullCanOverrun ......................................................................... 71</p>
<p> </p>
<p>Table 7-41 </p>
<p> </p>
<p>Appl_CanCorruptMailbox .......................................................................... 72</p>
<p> </p>
<p>Table 7-42 </p>
<p> </p>
<p>Appl_CanRamCheckFailed ....................................................................... 73</p>
<p> </p>
<p>Table 7-43 </p>
<p> </p>
<p>ApplCanInitPostProcessing ...................................................................... 74</p>
<p> </p>
<p>Table 7-44 </p>
<p> </p>
<p>Services used by the CAN ........................................................................ 75</p>
<p> </p>
<p>Table 8-1 </p>
<p> </p>
<p>Filter Parameter Description ..................................................................... 91</p>
<p> </p>
<p>Table 8-2 </p>
<p> </p>
<p>Baud Rate Parameter Description ............................................................ 92</p>
<p> </p>
<p>Table 8-3 </p>
<p> </p>
<p>CAN-FD Baud Rate Parameter Description .............................................. 94</p>
<p> </p>
<p>Table 10-1 </p>
<p> </p>
<p>Glossary ................................................................................................. 101</p>
<p> </p>
<p>Table 10-2 </p>
<p> </p>
<p>Abbreviations .......................................................................................... 101</p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference    MICROSAR CAN Driver </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 3.00.01 </p>
<p>10 </p>
<p><b>2 </b></p>
<p><b>Hardware Overview </b></p>
<p>The  following  table  summarizes  information  about  the  CAN  Driver.  It  gives  you  detailed </p>
<p>information </p>
<p>about </p>
<p>the </p>
<p>derivatives </p>
<p>and </p>
<p>compilers.  As </p>
<p>very </p>
<p>important </p>
<p>information </p>
<p>the </p>
<p>documentations of the hardware manufacturers are listed. The CAN Driver is based upon </p>
<p>these documents in the given version. </p>
<p> </p>
<p><b>Derivative </b></p>
<p><b>Compiler </b></p>
<p><b>Hardware Manufacturer </b></p>
<p><b>Document </b></p>
<p><b>Version </b></p>
<p>R7F701325 </p>
<p>R7F701327 </p>
<p>R7F701328 </p>
<p>R7F701329 </p>
<p>R7F701370A </p>
<p>R7F701370B </p>
<p>R7F701371 </p>
<p>R7F701372 </p>
<p>R7F701372A </p>
<p>R7F701373 </p>
<p>R7F701373A </p>
<p>R7F701374 </p>
<p>R7F701374A </p>
<p>GHS  </p>
<p>RH850/P1x-C Group </p>
<p>RH850/P1x-C Group </p>
<p>RH850/P1x-C Group </p>
<p>Rev. 0.60, Sep. 2014 </p>
<p>Nov, 2014 Rev. 0.10 </p>
<p>Jan, 2016 Rev.1.00 </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>Table 2-1  </p>
<p>Supported Hardware Overview  </p>
<p><b>Derivative: </b>This can be a single information or a list of derivatives, the CAN Driver can be used on. </p>
<p><b>Compiler: </b>List of Compilers the CAN Driver is working with </p>
<p><b>Hardware Manufacturer Document Name: </b>List of hardware documentation the CAN Driver is based on.  </p>
<p><b>Version: </b>To be able to reference to this hardware documentation its version is very important. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference    MICROSAR CAN Driver </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 3.00.01 </p>
<p>11 </p>
<p><b>3 </b></p>
<p><b>Introduction </b></p>
<p>This  document  describes  the  functionality, API  and  configuration  of  the AUTOSAR  BSW </p>
<p>module CAN as specified in [1].  </p>
<p>Since each hardware platform has its own behavior based on the CAN specifications, the </p>
<p>main goal of the CAN Driver is to give a standardized interface to support communication </p>
<p>over the CAN bus for each platform in the same way. The CAN Driver works closely </p>
<p>together with the higher layer CAN interface. </p>
<p> </p>
<p><b>Supported AUTOSAR </b></p>
<p><b>Release*: </b></p>
<p>3 and 4 </p>
<p><b>Supported Configuration </b></p>
<p><b>Variants: </b></p>
<p>Pre-Compile, </p>
<p>Link-Time, </p>
<p>Post-Build Loadable, </p>
<p>Post-Build Selectable (MICROSAR Identity Manager) </p>
<p><b> </b></p>
<p> </p>
<p><b>Vendor ID: </b></p>
<p>CAN_VENDOR_ID </p>
<p>30 decimal </p>
<p>(= Vector-</p>
<p>Informatik, </p>
<p>according to HIS) </p>
<p><b>Module ID: </b></p>
<p>CAN_MODULE_ID   </p>
<p>80 decimal </p>
<p>(according to ref. </p>
<p>[2]) </p>
<p><b>AR Version: </b></p>
<p>CAN_AR_RELEASE_MAJOR_VERSION </p>
<p>CAN_AR_RELEASE_MINOR_VERSION </p>
<p>CAN_AR_RELEASE_REVISION_VERSION </p>
<p>AUTOSAR </p>
<p>Release version               </p>
<p>BCD coded </p>
<p><b>SW Version: </b></p>
<p>CAN_SW_MAJOR_VERSION </p>
<p>CAN_SW_MINOR_VERSION </p>
<p>CAN_SW_PATCH_VERSION </p>
<p>MICROSAR CAN </p>
<p>mudule version               </p>
<p>BCD coded </p>
<p>* For the precise AUTOSAR Release 3.x (and 4.x) please see the release specific documentation.  </p>
<p> </p>
<p> </p>
<p> </p>
<p><b>3.1 </b></p>
<p><b>Architecture Overview </b></p>
<p>The following figure shows where the CAN is located in the AUTOSAR architecture. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference    MICROSAR CAN Driver </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 3.00.01 </p>
<p>12 </p>
<p> </p>
<p> </p>
<p>Figure 3-1 AUTOSAR architecture </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference    MICROSAR CAN Driver </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 3.00.01 </p>
<p>13 </p>
<p>The next figure shows the interfaces to adjacent modules of the CAN. These interfaces are </p>
<p>described in chapter 7.  </p>
<p> </p>
<p> </p>
<p>Figure 3-2 </p>
<p>Interfaces to adjacent modules of the CAN</p>
<p> </p>
<p> </p>
<p>CAN Driver</p>
<p>CAN Interface</p>
<p>... CAN X</p>
<p>EcuM</p>
<p>DET</p>
<p>DEM</p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference    MICROSAR CAN Driver </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 3.00.01 </p>
<p>14 </p>
<p><b>4 </b></p>
<p><b>Functional Description </b></p>
<p><b>4.1 </b></p>
<p><b>Features </b></p>
<p>The features listed in this chapter cover the complete functionality specified in [1]. </p>
<p>The &quot;supported&quot; and &quot;not supported&quot; features are presented in the following table.  </p>
<p>For further information of not supported features also see chapter 9. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference    MICROSAR CAN Driver </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 3.00.01 </p>
<p>15 </p>
<p><b>Feature Naming </b></p>
<p><b>Short Description </b></p>
<p><b>GENy </b></p>
<p><b>CFG5 </b></p>
<p><b>Initialization </b></p>
<p><b> </b></p>
<p> </p>
<p> </p>
<p>   Driver </p>
<p>General driver initialization function </p>
<p>Can_Init() </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p>   Controller </p>
<p>Controller specific initialization function </p>
<p>Can_InitController(). </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p><b>Communication </b></p>
<p><b> </b></p>
<p> </p>
<p> </p>
<p>   Transmission </p>
<p>Transmitting CAN frames. </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p>   Transmit confirmation </p>
<p>Callback for successful Transmission. </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p>   Reception </p>
<p>Receiving CAN frames. </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p>   Receive indication </p>
<p>Callback for receiving Frame. </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p><b>Controller Modes </b></p>
<p><b> </b></p>
<p> </p>
<p> </p>
<p>   Sleep Mode </p>
<p>Controller supports Sleep Mode (power </p>
<p>saving). </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p>   Wakeup over CAN </p>
<p>Controller supports wakeup over CAN. </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p>   Stop Mode </p>
<p>Controller supports Stop Mode (passive to </p>
<p>CAN bus). </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p>   Bus Off detection </p>
<p>Callback for Bus Off event. </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p>   </p>
<p>Silent Mode </p>
<p>Support Silent Mode where the controller </p>
<p>only listens passive. </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p><b>Polling Modes </b></p>
<p><b> </b></p>
<p> </p>
<p> </p>
<p>   Tx confirmation </p>
<p>Support Polling Mode for Transmit </p>
<p>confirmation. </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p>   Reception </p>
<p>Support Polling Mode for Reception. </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p>   Wakeup </p>
<p>Support Polling Mode for Wakeup event. </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p>   Bus Off </p>
<p>Support Polling Mode for Bus Off event. </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p>   Mode </p>
<p>MICROSAR4x only: Support Polling Mode </p>
<p>for mode transition. </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p><b>Mailbox objects </b></p>
<p><b> </b></p>
<p> </p>
<p> </p>
<p>   Tx BasicCAN </p>
<p>Standard mailbox to send CAN frames </p>
<p>(Used by CAN Interface data queue). </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference    MICROSAR CAN Driver </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 3.00.01 </p>
<p>16 </p>
<p>   Multiplexed Tx </p>
<p>Using 3 mailboxes for Tx BasicCAN </p>
<p>mailbox (external priority inversion </p>
<p>avoided). </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p>   Tx FullCAN </p>
<p>Separate mailbox for special Tx message </p>
<p>used. </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p>     Maximum amount </p>
<p>Available amount of mailboxes. </p>
<p>32 </p>
<p>32 </p>
<p>   Rx FullCAN </p>
<p>Separate mailbox for special Rx message </p>
<p>used. </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p>     Maximum amount </p>
<p>Available amount of mailboxes. </p>
<p>64 </p>
<p>64 </p>
<p>   Rx BasicCAN </p>
<p>Standard mailbox to receive CAN frames </p>
<p>(FIFO-0/1 supported). </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p>      Maximum amount </p>
<p>Available amount of BasicCAN objects. </p>
<p>By default there is one FIFO(0) supported </p>
<p>with a max. amount of 64 entries. In case </p>
<p>of “Multiple BasicCAN” (see below) </p>
<p>support an additional second FIFO(1) with </p>
<p>64 entries is supported. </p>
<p>1 (64) </p>
<p>2(128) </p>
<p>1 (64) </p>
<p>2(128) </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p> </p>
<p><b>Others </b></p>
<p><b> </b></p>
<p> </p>
<p> </p>
<p>   DEM </p>
<p>Support Diagnostic Event Manager (error </p>
<p>notification). </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p>   DET </p>
<p>Support Development Error Detection </p>
<p>(error notification). </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p>   Version API </p>
<p>API to read out component version. </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p>   Maximum supported </p>
<p>Controllers </p>
<p>Maximum amount of supported Controllers </p>
<p>(hardware channels). </p>
<p>8  </p>
<p> </p>
<p>8  </p>
<p> </p>
<p>   Cancellation of Tx objects </p>
<p>Support of Tx Cancellation (out of </p>
<p>hardware). Avoid internal priority inversion. </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p>    Identical ID cancellation </p>
<p>Tx Cancellation also for identical IDs. </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p>   Standard ID types </p>
<p>Standard Identifier supported (Tx and Rx). </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p>   Extended ID types </p>
<p>Extended Identifier supported (Tx and Rx). </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference    MICROSAR CAN Driver </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 3.00.01 </p>
<p>17 </p>
<p>   Mixed ID types </p>
<p>Standard and Extended Identifier </p>
<p>supported (Tx and Rx). </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p>   CAN FD Mode1 </p>
<p>FD frames with baudrate switch supported </p>
<p>(Tx and Rx). </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p>   CAN FD Mode2 </p>
<p>FD frames up to 64 data bytes supported </p>
<p>(Tx and Rx). </p>
<p></p>
<p> </p>
<p></p>
<p>**** </p>
<p>   Hardware Loop Check </p>
<p>   (Timeout monitoring) </p>
<p>To avoid possible endless loops (occur by </p>
<p>hardware issue). </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p><b>AutoSar extensions </b></p>
<p><b> </b></p>
<p> </p>
<p> </p>
<p>   Individual Polling </p>
<p>Support individual Polling Mode </p>
<p>(selectable for each mailbox separate). </p>
<p></p>
<p>* </p>
<p></p>
<p>* </p>
<p>   Multiple Rx Basic CAN </p>
<p>Support Multiple BasicCAN objects.  </p>
<p>This gives the possibility to use </p>
<p>additionally Fifo-1 with 64 additional </p>
<p>elements. By optimizing the   acceptance </p>
<p>filtering overruns can be avoided . </p>
<p></p>
<p>* </p>
<p></p>
<p>* </p>
<p>   Multiple Tx Basic CAN </p>
<p>Support Multiple Tx BasicCAN objects. </p>
<p>Used to send different Tx groups over </p>
<p>separate mailboxes with different buffering </p>
<p>behavior (see Can Interface). </p>
<p></p>
<p>* </p>
<p></p>
<p>* </p>
<p>   Rx Queue </p>
<p>Support Rx Queue. This offers the </p>
<p>possibility to buffer received data in </p>
<p>interrupt context but handle it later </p>
<p>asynchronous in the polling task. </p>
<p></p>
<p>* </p>
<p></p>
<p>* </p>
<p>   Secure Rx Buffer used </p>
<p>Special hardware buffer used to save </p>
<p>received data temporarily.  </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p>   Hardware Loop Check by </p>
<p>Application </p>
<p>Hardware Loop Check can be defined to </p>
<p>be done by application (special API </p>
<p>available) </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p>   Configurable “Nested CAN </p>
<p>Interrupts” </p>
<p>Nested CAN interrupts allowed and can be </p>
<p>also switched to none-nested. </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p>   Report CAN_E_TIMEOUT </p>
<p>DEM   as DET </p>
<p>Report CAN_E_TIMEOUT (Hardware </p>
<p>Loop Check / Timeout monitoring) to DET </p>
<p>instead of DEM. </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p>   Support Mixed ID </p>
<p>Force CAN Driver to handle Mixed ID </p>
<p>(standard and extended ID) at pre-</p>
<p>compile-time to expand the ID type later </p>
<p>on. </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference    MICROSAR CAN Driver </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 3.00.01 </p>
<p>18 </p>
<p>   Optimize for one controller </p>
<p>Activate this for 1 controller systems when </p>
<p>you never will expand to multi-controller. </p>
<p>So that the CAN Driver works more </p>
<p>efficient  </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p>   Dynamic FullCAN Tx ID </p>
<p>(***) </p>
<p>Always write FullCAN Tx ID within </p>
<p>Can_Write() API function. Deactivate this </p>
<p>to optimize code when you do not use </p>
<p>FullCAN Tx objects dynamically. </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p>   Size of Hw HandleType </p>
<p>Support 8-bit or 16-bit Hardware Handles </p>
<p>depending on the hardware usage. </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p>   Generic PreCopy </p>
<p>Support a callback function for receiving </p>
<p>any CAN message (following callbacks </p>
<p>could be suppressed) </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p>   Generic Confirmation </p>
<p>Support a callback function for successful </p>
<p>transmission of any CAN message </p>
<p>(following callbacks could be suppressed) </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p>   Get Hardware Status </p>
<p>Support a API to get hardware status </p>
<p>Information (see Can_GetStatus()) </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p>   Interrupt Category </p>
<p>selection </p>
<p>Support Category 1 or Category 2 </p>
<p>Interrupt Service Routines for OS  </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p>   Common CAN </p>
<p>Support merge of 2 controllers in </p>
<p>hardware to get more Rx FullCAN objects </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p>   Overrun Notification </p>
<p>Support DET or Application notification </p>
<p>caused by overrun (overwrite) of an Rx </p>
<p>message. </p>
<p>Please note that ‘Overrun’ is supported for </p>
<p>BasicCAN objects but is not available for </p>
<p>FullCAN objects.  </p>
<p>While not processed  a Message ID Filter </p>
<p>Element referencing a specific FullCAN </p>
<p>object will not match, causing the </p>
<p>acceptance filtering to continue. </p>
<p>Subsequent Message ID Filter Elements </p>
<p>may cause the received message to be </p>
<p>stored into  </p>
<p>- another FullCAN object, or </p>
<p>- a BasicCAN object, or </p>
<p>- the message may be rejected, </p>
<p>depending on the filter configuration. </p>
<p> </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p>   RAM check </p>
<p>Support CAN mailbox RAM check </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference    MICROSAR CAN Driver </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 3.00.01 </p>
<p>19 </p>
<p>   Extended RAM Check </p>
<p>Support extended RAM check. Handling of </p>
<p>individual deactivated mailboxes and </p>
<p>controllers. </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p>   Multiple ECU </p>
<p>configurations (***) </p>
<p>The feature Multiple ECU is usually used </p>
<p>for nodes that exist more than once in a </p>
<p>car. At power up the application decides </p>
<p>which node should be realized. </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p>   Generic PreTransmit </p>
<p> </p>
<p>Support a callback function with pointer to </p>
<p>Data, right before this data will be written </p>
<p>in Hardware mailbox buffer to send. (Use </p>
<p>this to change data or cancel </p>
<p>transmission) </p>
<p></p>
<p> </p>
<p></p>
<p> </p>
<p>Table 4-1  </p>
<p>Supported features </p>
<p></p>
<p> </p>
<p>Feature is supported</p>
<p> </p>
<p></p>
<p> </p>
<p>Feature is not supported </p>
<p>*     HighEnd Licence only </p>
<p>**    Project specific (may not be available) </p>
<p>***  Not supported or cannot be configured for AutoSar version 4 </p>
<p>**** Only available for MicroSar4 </p>
<p> </p>
<p> </p>
<p><b>4.2 </b></p>
<p><b>Initialization </b></p>
<p>Can_Init()</p>
<p>  has  to  be  called  to  initialize  the  CAN  Driver  at  power  on  and  sets  controller </p>
<p>independent init values. This function has to be called before </p>
<p>Can_InitController()</p>
<p>. </p>
<p>MicroSar3 only: Use </p>
<p>Can_InitStruct()</p>
<p> to change the used baud rate and filter settings like given </p>
<p>in the Initialization structure from the Tool. The used default set by </p>
<p>Can_InitMemory</p>
<p> is the first </p>
<p>structure. This API has to be called before </p>
<p>Can_InitController()</p>
<p> but after </p>
<p>Can_InitMemory()</p>
<p>. </p>
<p>MICROSAR401 only: baud rate settings given by Can_InitController parameter. </p>
<p>Can_InitController()</p>
<p>  initializes  the  controller,  given  as  parameter,  and  can  also  be  used  to </p>
<p>reinitialize. After this call the controller stays in Stop Mode until the CAN Interface changes to </p>
<p>Start Mode. </p>
<p>Can_InitMemory()</p>
<p> is an additional service function to reinitialize the memory to bring the driver </p>
<p>back  to  a pre-power-on  state  (not  initialized). Afterwards </p>
<p>Can_Init()</p>
<p>  and </p>
<p>Can_InitController()</p>
<p> </p>
<p>have to be called again. It is recommended to use this function before calling </p>
<p>Can_Init()</p>
<p> to </p>
<p>secure that no startup-code specific pre-initialized variables affect the driver startup behavior. </p>
<p><b>4.3 </b></p>
<p><b>Communication </b></p>
<p>Can_Write() is used to send a message over the mailbox object given as &quot;Hth&quot;. The data, DLC and </p>
<p>ID is copied into the hardware mailbox object and a send request is set. After sending the message </p>
<p>the CAN Interface CanIf_TxConfirmation() function is called. Right before the data is copied into the </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference    MICROSAR CAN Driver </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 3.00.01 </p>
<p>20 </p>
<p>mailbox  buffer  the  ID,  DLC  and  data  may  be  changed  by </p>
<p>Appl_GenericPreTransmit()</p>
<p> </p>
<p>callback. </p>
<p>When  “Generic  Confirmation“  is  activated  the  callback Appl_GenericConfirmation()    will  be  called </p>
<p>before CanIf_TxConfirmation() and the call to this can be suppressed by Appl_GenericConfirmation()  </p>
<p>return value. </p>
<p>For Tx  messages  the  ID  will  be  copied.  (Exception:  feature  “Dynamic  FullCAN Tx  ID”  is </p>
<p>deactivated, then the FullCAN Tx messages will be only set while initialization) </p>
<p>If the mailbox is currently sending the status busy will be returned. Then the message may be queued </p>
<p>in the CAN interface (if feature is active). </p>
<p>If  cancellation  in  hardware  is  supported  the  lowest  priority  ID  inside  currently  sending  object  is </p>
<p>canceled, and therefore re-queued in the CAN Interface. </p>
<p>Appl_GenericPreCopy() (if activated) is called and depend on return value also CanIf_RxIndication() </p>
<p>as a CAN Interface callback, is called when a message is received. The receive information like ID, </p>
<p>DLC and data are given as parameter. </p>
<p>When  Rx  Queue  is  activated  the  received  messages  (polling  or  interrupt  context)  will  be queued </p>
<p>(same queue over all channels). The Rx Queue will be read by calling Can_Mainfunction_Read () and </p>
<p>the Rx Indication (like CanIf_RxIndication()) will be called out of this context. Rx Queue is used for </p>
<p>Interrupt systems to keep Interrupt latency time short. </p>
<p> </p>
<p><b>4.3.1 </b></p>
<p><b>Mailbox Layout </b></p>
<p>The generation tool supports a flexible allocation of message buffers. In the following tables </p>
<p>the possible mailbox layout is shown (the range for each mailbox type depends on the used </p>
<p>mailboxes). </p>
<p> </p>
<p><b>Hardware </b></p>
<p><b>object </b></p>
<p><b>number </b></p>
<p><b>Hardware </b></p>
<p><b>object type </b></p>
<p><b>Amount of </b></p>
<p><b>hardware </b></p>
<p><b>objects </b></p>
<p><b>Description </b></p>
<p>0 … N </p>
<p><b>Tx FullCAN </b></p>
<p>0 … 31 max.  </p>
<p>(0 … 29 in </p>
<p>case of </p>
<p>multiplexed </p>
<p>transmission) </p>
<p>These objects are used to transmit specific message IDs. </p>
<p>The user must define statically in the generation tool </p>
<p>which CAN message IDs are located in Tx FullCAN </p>
<p>objects. The generation tool assigns the message IDs to </p>
<p>the FullCAN hardware objects. </p>
<p>(N+1)  </p>
<p>… M </p>
<p><b>Tx BasicCAN </b></p>
<p>1 or 3          <b>(</b>3 </p>
<p>in case of </p>
<p>multiplexed </p>
<p>transmission) </p>
<p>All other CAN message IDs are transmitted via the Tx </p>
<p>Basic object. If the transmit message object is busy, the </p>
<p>transmit requests are stored in the CAN Interface queue </p>
<p>(if activated). </p>
<p>(M+1) </p>
<p> … O </p>
<p><b>Unused </b></p>
<p>0 … 95 </p>
<p>These objects are not used. It depends on the </p>
<p>configuration of receive and transmit objects how many </p>
<p>unused objects are available. </p>
<p>O…P </p>
<p><b>Rx FullCAN </b></p>
<p>0 … 64 </p>
<p>These objects are used to receive specific CAN </p>
<p>messages. The user defines statically (Generation Tool) </p>
<p>that a CAN message should be received in a FullCAN </p>
<p>message object. The Generation Tool distributes the </p>
<p>messages to the FullCAN objects. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference    MICROSAR CAN Driver </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 3.00.01 </p>
<p>21 </p>
<p>96 </p>
<p>  </p>
<p> </p>
<p><b>Rx </b></p>
<p><b>BasicCAN </b></p>
<p>FIFO-0 with </p>
<p>max. 64 </p>
<p>entries </p>
<p>All CAN message IDs, depending on the acceptance filter </p>
<p>match, are received via the Rx BasicCAN message object </p>
<p>through Rx FIFO 0. </p>
<p>Each Rx Basic message object consists of 64 message </p>
<p>buffers.  </p>
<p>128 acceptance filters are available for standard IDs and </p>
<p>64   acceptance filters are available for extended IDs.  </p>
<p>In case of mixed ID Mode 128+64 = 192 filters are </p>
<p>available. </p>
<p>Please note that this maximum amount of filters is also </p>
<p>used for FIFO-1 if available. </p>
<p>97 </p>
<p><b>Rx </b></p>
<p><b>BasicCAN </b></p>
<p>FIFO-1 with </p>
<p>max. 64 </p>
<p>entries </p>
<p>All CAN message IDs, depending on the acceptance filter </p>
<p>match,  are received via the Rx BasicCAN message </p>
<p>objects through Rx FIFO 1. </p>
<p>Each Rx Basic message object consists of 64 message </p>
<p>buffers.  </p>
<p>128 acceptance filters are available for standard IDs and </p>
<p>64   acceptance filters are available for extended IDs.  </p>
<p>In case of mixed ID Mode 128+64 = 192 filters are </p>
<p>available. </p>
<p>Please note that this maximum amount of filters is also </p>
<p>used for FIFO-0.  </p>
<p> </p>
<p>The “CanObjectId” (ECUc parameter) numbering is done in following order: Tx FullCAN, Tx </p>
<p>BasicCAN, Unused, Rx FullCAN, Rx BasicCAN (like shown above). “CanObjectId’s” for next </p>
<p>controller begin at end of last controller. Gaps in “CanObjectId” for unused mailboxes may </p>
<p>occur. </p>
<p><b>4.3.2 </b></p>
<p><b>Mailbox Processing Order </b></p>
<p>The hardware mailbox will be processed in following order:  </p>
<p><b>Object Type </b></p>
<p><b>Order / priority to send or receive </b></p>
<p>Tx FullCAN </p>
<p>Object ID Low to High </p>
<p>Tx BasicCAN </p>
<p>Object ID Low to High </p>
<p>Rx FullCAN </p>
<p>Object ID Low to High </p>
<p>Rx BasicCAN </p>
<p>FIFO </p>
<p> </p>
<p>In Case of Interrupt, Rx FullCANs will be processed before Rx BasicCANs. </p>
<p>In Case of Polling, Rx FullCANs will be processed before Rx BasicCANs. </p>
<p>The order between Rx and Tx mailboxes depends on the call order of the polling tasks or the </p>
<p>interrupt context and cannot be guaranteed. </p>
<p>The Rx Queue will work like a FIFO filled with the above mentioned method. </p>
<p> </p>
<p><b>4.3.3 </b></p>
<p><b>Acceptance Filter for BasicCAN  </b></p>
<p>For  each  CAN  channel  a  maximum  amount  of  128  filters  for  standard  and  64  filters  for </p>
<p>extended </p>
<p>ID </p>
<p>configurations </p>
<p>is </p>
<p>available.  Thus </p>
<p>192 </p>
<p>filters </p>
<p>are </p>
<p>available </p>
<p>for </p>
<p>mixed </p>
<p>ID </p>
<p>configurations. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference    MICROSAR CAN Driver </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 3.00.01 </p>
<p>22 </p>
<p>For acceptance filtering each list of filters is executed from element #0 until the first matching </p>
<p>element. Acceptance filtering stops at the first matching element. Each filter element decides </p>
<p>if the received message is stored within FIFO-0 (or FIFO-1 if available). </p>
<p>If no message should be received, select the “Multiple Basic CAN” feature and set the amount </p>
<p>to 0. Otherwise the filter should be set to “close”. Use feature “Rx BasicCAN Support” to </p>
<p>deactivate unused code (for optimization). </p>
<p> </p>
<p><b>4.3.4 </b></p>
<p><b>Remote Frames </b></p>
<p>The CAN Driver initializes the CAN controller not to receive remote frames. Therefore no </p>
<p>additional  action  is  required  during  runtime  by  the  CAN  Driver  for  remote  frame  filtering. </p>
<p>Remote frames will not have any influence on communication because they are not received </p>
<p>by the CAN hardware. </p>
<p><b>4.4 </b></p>
<p><b>States / Modes </b></p>
<p>You  can  change  the  CAN  cell  mode  via  Can_SetControllerMode().  The  last  requested </p>
<p>transition will be executed. The upper layer has to take care about valid transitions. </p>
<p>The following mode changes are supported: </p>
<p><b>CAN_T_START </b></p>
<p><b>CAN_T_STOP </b></p>
<p> </p>
<p>MICROSAR4 only: Notification of mode change may occur asynchronous by notification </p>
<p>CanIf_ControllerModeIndication().</p>
<p> </p>
<p> </p>
<p><b>4.4.1 </b></p>
<p><b>Start Mode (Normal Running Mode) </b></p>
<p>This is the mode where communication is possible. This mode has to be set after Initialization </p>
<p>because Controller is first in Stop Mode. </p>
<p> </p>
<p>The Bit Stream Processor synchronizes itself to the data transfer on the CAN bus by waiting </p>
<p>for the occurrence of a sequence of 11 consecutive recessive bits (= Bus_Idle) before it can </p>
<p>take part in bus activities and start the message transfer. </p>
<p> </p>
<p><b>4.4.2 </b></p>
<p><b>Stop Mode </b></p>
<p>If Stop Mode is requested, either by software or by going BusOff, then the CAN module is </p>
<p>switched into INIT mode. In this mode message transfer from and to the CAN bus is stopped, </p>
<p>the status of the CAN bus transmit output is recessive (HIGH).  </p>
<p>Going to Stop Mode does not change any configuration register.  </p>
<p> </p>
<p><b>4.4.3 </b></p>
<p><b>Power Down Mode </b></p>
<p>The CAN controller does not support a Sleep/Wakeup Mode, nevertheless power saving is </p>
<p>possible with the “Power Down” Mode via a Clock Stop Request (CSR).  </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference    MICROSAR CAN Driver </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 3.00.01 </p>
<p>23 </p>
<p>After requesting Clock Stop all pending transmissions have to be completed then the CAN </p>
<p>Controller waits until bus idle state is detected. Then the CAN Controller sets Initialization to </p>
<p>one to prevent any further CAN transfers. Now the CAN Controller acknowledges that it is </p>
<p>ready  for power down  by  setting  Clock  Stop Acknowledge. At  this  point  of  time  the  CAN </p>
<p>Controller clock inputs may be switched off.  </p>
<p>To leave Power Down Mode, the application has to turn on the CAN Controller clocks before </p>
<p>resetting Clock Stop Request. The CAN Controller will acknowledge this by resetting Clock </p>
<p>Stop Acknowledge. Afterwards  the  CAN communication  can be  restarted  by  resetting  the </p>
<p>initialization mode. </p>
<p>The application is, if configured, requested to turn off the clocks for CAN and Host controllers. </p>
<p>When the Clock Stop Request  returns, then it is assumed that the clocks are off. </p>
<p>In the same way the application is requested to turn on the CAN clocks during power up </p>
<p>before  the  CAN  starts  communication.  When  the  Clock  Start  Request  returns,  then  it  is </p>
<p>assumed that the clocks are on. </p>
<p>Please note that the user callback function that will be called in case of a clock stop request </p>
<p>acknowledge must be defined via a user-configuration file (see example below). </p>
<p> </p>
<p> </p>
<p>Example for a user – configuration file entry defining the Clock Start/Stop callback functions: </p>
<p> </p>
<p>#define ApplCanClockStop(CanChannel)    ApplCanClockStopAcknowledged(CanChannel) </p>
<p>/* will be called when the application is allowed to turn off the clocks for CAN and Host */ </p>
<p>#define ApplCanClockStart(CanChannel)   ApplCanClockStartRequested(CanChannel) </p>
<p>/* will be called when the application must turn on the clocks for CAN and Host before communication is </p>
<p>started */ </p>
<p> </p>
<p>The parameter “</p>
<p>CanChannel</p>
<p>” is either of type “void” in case of a single channel configuration </p>
<p>or it contains the number of the CAN channel in case of a multi channel configuration. </p>
<p> </p>
<p><b>4.4.4 </b></p>
<p><b>Bus Off </b></p>
<p>CanIf_ControllerBusOff()</p>
<p> is called when the controller detects a Bus Off event. The </p>
<p>mode is automatically changed to Stop Mode. The upper layers have to care about returning </p>
<p>to normal running mode by calling Start Mode. </p>
<p> </p>
<p><b>4.4.5 </b></p>
<p><b>Silent Mode </b></p>
<p>Support API (</p>
<p>Can_SetSilentMode()</p>
<p>) to switch into ‘SilentMode’ where the controller </p>
<p>does not take part on BUS communication (no ACK) but can listen for messages. </p>
<p>Please refer also to ISO 11898 bus monitoring.</p>
<p> </p>
<p> </p>
<p>The MCAN describes this mode as Bus Monitoring Mode: </p>
<p>In Bus Monitoring Mode (see ISO 11898-1:2015, 10.14 Bus monitoring), the M_CAN is able </p>
<p>to receive valid data frames and valid remote frames, but cannot start a transmission. In this </p>
<p>mode,  it  sends  only  recessive  bits  on  the CAN  bus.  If  the  M_CAN  is required  to  send  a </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference    MICROSAR CAN Driver </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 3.00.01 </p>
<p>24 </p>
<p>dominant bit (ACK bit, overload ﬂag, active error ﬂag), the bit is rerouted internally so that the </p>
<p>M_CAN monitors this dominant bit, although the CAN bus may remain in recessive state. In </p>
<p>Bus Monitoring Mode register TXBRP is held in reset state. </p>
<p>The Bus Monitoring Mode can be used to analyze the trafﬁc on a CAN bus without affecting </p>
<p>it by the transmission of dominant bits.  </p>
<p>In case of an error condition or overload condition no dominant bits are sent, instead the </p>
<p>MCAN  waits  for  the  occurrence  of  bus  idle  condition  to  resynchronize  itself  to  the  CAN </p>
<p>communication. The error counters (ECR.REC, ECR.TEC) are frozen while  Error Logging </p>
<p>(ECR.CEL) is active. This can be used in applications that adapt themselves to different CAN </p>
<p>bit rates. </p>
<p> </p>
<p> </p>
<p>Figure 4-1 Bus Monitoring Mode. </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>With activated “Silent Mode” do not use any other API than </p>
<p>Can_SetSilentMode(“CAN_SILENT_INACTIVE”), </p>
<p>Can_SetControllerMode(“START” or “STOP”) or  </p>
<p>Can_ChangeBaudrate() or Can_SetBaudrate(). </p>
<p>Especially do NOT request any transmission. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p> </p>
<p><b>4.4.6 </b></p>
<p><b>Dynamic MCAN detection </b></p>
<p>In the case of several platform hardware versions with different MCAN Revisions are used, </p>
<p>the integrated MCAN Revision can be detected during runtime by the CAN Driver. If so, the </p>
<p>CAN Driver adapts itself to the underlying MCAN Revision. </p>
<p>To enable this mode the preprocessor switch “</p>
<p>C_ENABLE_DYNAMIC_MCAN_REVISION</p>
<p>” must be </p>
<p>defined via a user configuration file. </p>
<p>Adaptations  which  do  not  need  additional  data  are  accomplished  internally  now. </p>
<p>For </p>
<p>adaptations </p>
<p>which </p>
<p>need </p>
<p>additional </p>
<p>data </p>
<p>the </p>
<p>user </p>
<p>callback </p>
<p>function </p>
<p>“</p>
<p>ApplCanInitPostProcessing()</p>
<p>” has to be enabled in addition. This callback function is called </p>
<p>during initialization time of the MCAN and thus allows to overwrite MCAN registers with values </p>
<p>which are MCAN Revision dependent (see ch. 7.2.42). </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference    MICROSAR CAN Driver </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 3.00.01 </p>
<p>25 </p>
<p> </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>Please note that the dynamic MCAN detection only works upwards.  </p>
<p>This means that the configuration is always based on MCAN Revision 3.0.x. </p>
<p>The effective underlying MCAN Revision may be either 3.0.x or 3.2.x. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p> </p>
<p><b>4.5 </b></p>
<p><b>Re-Initialization </b></p>
<p>A call to </p>
<p>Can_InitController()</p>
<p> cause a re-initialization of a dedicated CAN controller. </p>
<p>Pending messages may be processed before the transition will be finished. A re-initialization </p>
<p>is only possible out of Stop Mode and does not change to another mode. </p>
<p>After re-initialization all CAN communication relevant registers are set to initial conditions. </p>
<p> </p>
<p><b>4.6 </b></p>
<p><b>CAN Interrupt Locking </b></p>
<p>Can_DisableControllerInterrupts()</p>
<p> and </p>
<p>Can_EnableControllerInterrupts()</p>
<p>   are used to disable and enable the controller </p>
<p>specific Interrupt, Rx, Tx, Wakeup and BusOff (/ Status) together. These functions can be </p>
<p>called nested. </p>
<p><b>4.7 </b></p>
<p><b>Main Functions </b></p>
<p>Can_MainFunction_Write()</p>
<p>, </p>
<p>Can_MainFunction_Read()</p>
<p>, </p>
<p>Can_MainFunction_BusOff()</p>
<p> and </p>
<p>Can_MainFunction_Wakeup()</p>
<p> are called by </p>
<p>upper layers to poll the events if the specific Polling Mode is activated. Otherwise these </p>
<p>functions return without any action and the events will be handled in interrupt context. </p>
<p>When individual polling is activated only mailboxes that are configured as to be polled will </p>
<p>be polled in the main functions “</p>
<p>Can_MainFunction_Write()</p>
<p>” and </p>
<p>“</p>
<p>Can_MainFunction_Read()</p>
<p>”, all others are handled in interrupt context. </p>
<p>If the Rx Queue feature is activated then the queue is filled in interrupt or polling context, </p>
<p>like configured. But the processing (indications) will be done in </p>
<p>“</p>
<p>Can_MainFunction_Read()</p>
<p>” context. </p>
<p>MICROSAR4 only: Can_MainFunction_Mode() can be called by upper layers to poll </p>
<p>asynchronous mode transition notifications. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference    MICROSAR CAN Driver </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 3.00.01 </p>
<p>26 </p>
<p><b>4.8 </b></p>
<p><b>Error Handling </b></p>
<p><b>4.8.1 </b></p>
<p><b>Development Error Reporting </b></p>
<p>Development errors are reported to DET using the service </p>
<p>Det_ReportError()</p>
<p>, if the pre-</p>
<p>compile parameter CAN_DEV_ERROR_DETECT == STD_ON. </p>
<p>The tables below, shows the API ID and Error ID given as parameter for calling the DET. </p>
<p>Instance ID is always 0 because no multiple Instances are supported. </p>
<p> </p>
<p><b>Errors reported to DET: </b></p>
<p><b>Error ID </b></p>
<p><b>Short Description </b></p>
<p>CAN_E_PARAM_POINTER </p>
<p>API gets an illegal pointer as parameter. </p>
<p>CAN_E_PARAM_HANDLE </p>
<p>API gets an illegal handle as parameter </p>
<p>CAN_E_PARAM_DLC </p>
<p>API gets an illegal DLC as parameter </p>
<p>CAN_E_PARAM_CONTROLLER </p>
<p>API gets an illegal controller as parameter </p>
<p>CAN_E_UNINIT </p>
<p>Driver API is used but not initialized </p>
<p>CAN_E_TRANSITION </p>
<p>Transition for mode change is illegal </p>
<p>CAN_E_DATALOST </p>
<p>(value: 0x07, AutoSar extension) </p>
<p>Rx overrun (overwrite) detected </p>
<p>CAN_E_PARAM_BAUDRATE </p>
<p>(value: 0x08, AutoSar extension) </p>
<p>Selected Baudrate is not valid </p>
<p>CAN_E_RXQUEUE </p>
<p>(value: 0x10, AutoSar extension) </p>
<p>Rx Queue overrun  </p>
<p>(Last received message is lost and will not be received.  </p>
<p>Avoid this by increasing the queue size) </p>
<p>CAN_E_TIMEOUT_DET </p>
<p>(value: 0x11, AutoSar extension) </p>
<p>Same as CAN_E_TIMEOUT for DEM but this is notified to DET </p>
<p>due to switch “CAN_DEV_TIMEOUT_DETECT” is set to </p>
<p>STD_ON (see configuration options) </p>
<p>CAN_E_GENDATA               </p>
<p>(value:0x12, AutoSar extension) </p>
<p>Standardized issue for inconsistent generated data </p>
<p> </p>
<p>kCanErrorMcanRevision                   </p>
<p>(value:0xA2, AutoSar extension) </p>
<p> </p>
<p> </p>
<p>The configured Mcan Revision is not equal to the Mcan </p>
<p>Revision read directly from the underlying hardware during </p>
<p>startup. </p>
<p>kCanErrorMcanMessageRAMOverflow        </p>
<p>(value:0xA3, AutoSar extension) </p>
<p>The address used for a Message RAM access is behind the </p>
<p>end address of the available Message RAM. </p>
<p>Table 4-2  </p>
<p>Errors reported to DET </p>
<p><b>API from which the errors are reported to DET: </b></p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference    MICROSAR CAN Driver </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 3.00.01 </p>
<p>27 </p>
<p><b>API ID </b></p>
<p><b>Functions using that ID </b></p>
<p>CAN_VERSION_ID </p>
<p>Can_GetVersionInfo() </p>
<p>CAN_INIT_ID </p>
<p>Can_Init() </p>
<p>CAN_INITCTR_ID </p>
<p>Can_InitController() </p>
<p>CAN_SETCTR_ID </p>
<p>Can_SetControllerMode() </p>
<p>CAN_DIINT_ID </p>
<p>Can_DisableControllerInterrupts() </p>
<p>CAN_ENINT_ID </p>
<p>Can_EnableControllerInterrupts() </p>
<p>CAN_WRITE_ID </p>
<p>Can_Write(), Can_CancelTx() </p>
<p>CAN_TXCNF_ID </p>
<p>CanHL_TxConfirmation() </p>
<p>CAN_RXINDI_ID </p>
<p>CanBasicCanMsgReceived(), CanFullCanMsgReceived() </p>
<p>CAN_CTRBUSOFF_ID </p>
<p>CanHL_ErrorHandling() </p>
<p>CAN_CKWAKEUP_ID </p>
<p>CanHL_WakeUpHandling(), Can_Cbk_CheckWakeup() </p>
<p>CAN_MAINFCT_WRITE_ID </p>
<p>Can_MainFunction_Write() </p>
<p>CAN_MAINFCT_READ_ID </p>
<p>Can_MainFunction_Read() </p>
<p>CAN_MAINFCT_BO_ID </p>
<p>Can_MainFunction_BusOff() </p>
<p>CAN_MAINFCT_WU_ID </p>
<p>Can_MainFunction_Wakeup() </p>
<p>CAN_MAINFCT_MODE_ID </p>
<p>Can_MainFunction_Mode() </p>
<p>CAN_CHANGE_BR_ID </p>
<p>Can_ChangeBaudrate() </p>
<p>CAN_CHECK_BR_ID </p>
<p>Can_CheckBaudrate() </p>
<p>CAN_SET_BR_ID </p>
<p>Can_SetBaudrate() </p>
<p>CAN_HW_ACCESS_ID </p>
<p>(value: 0x20, AUTOSAR extension) </p>
<p>Used when hardware is accessed (call context may vary) </p>
<p>Table 4-3 </p>
<p>API from which the Errors are reported </p>
<p><b>4.8.1.1 </b></p>
<p><b>Parameter Checking </b></p>
<p>AUTOSAR requires that API functions check the validity of their parameters (Refer to [1]). </p>
<p>These  checks  are  for  development  error  reporting  and  can  be  enabled  and  disabled </p>
<p>separately. Refer to the configuration chapter where the enabling/disabling of the checks is </p>
<p>described. Enabling/disabling of single checks is an addition to the AUTOSAR standard which </p>
<p>requires </p>
<p>enable/disable </p>
<p>the </p>
<p>complete </p>
<p>parameter </p>
<p>checking </p>
<p>via </p>
<p>the </p>
<p>parameter </p>
<p>CAN_DEV_ERROR_DETECT</p>
<p>. </p>
<p> </p>
<p><b>4.8.1.2 </b></p>
<p><b>Overrun/Overwrite Notification </b></p>
<p> As AUTOSAR extension the overrun detection may be activated by configuration tool. The </p>
<p>notification can be configured to issue a DET call (MICROSAR 4.x) or an Application call </p>
<p>(<i>Appl_CanOverrun</i>()). </p>
<p> </p>
<p>Please note that ‘Overrun’ is supported for BasicCAN objects but is not available for FullCAN </p>
<p>objects.  </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference    MICROSAR CAN Driver </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 3.00.01 </p>
<p>28 </p>
<p>While the received message is still in the Rx buffer contained (New Data flag is set) for a </p>
<p>specific FullCAN object a Message ID Filter Element referencing this specific object will not </p>
<p>match, causing the acceptance filtering to continue. Following Message ID Filter Elements </p>
<p>may cause the received message to be stored into another Rx Buffer, or into an Rx FIFO, or </p>
<p>the message may be rejected, depending on filter configuration. </p>
<p> </p>
<p><b>4.8.2 </b></p>
<p><b>Production Code Error Reporting </b></p>
<p>Production </p>
<p>code </p>
<p>related </p>
<p>errors </p>
<p>are </p>
<p>reported </p>
<p>to </p>
<p>DEM </p>
<p>using </p>
<p>the </p>
<p>service </p>
<p>Dem_ReportErrorStatus()</p>
<p>,  if  the  pre-compile  parameter </p>
<p>CAN_PROD_ERROR_DETECT </p>
<p>== STD_ON</p>
<p>. </p>
<p>The table below shows the Event ID and Event Status given as parameter for calling the </p>
<p>DEM. This callout may occur in the context of different API calls (see Chapter “Hardware </p>
<p>Loop Check / Timeout Monitoring”). </p>
<p><b>Event ID </b></p>
<p><b>Event Status </b></p>
<p><b>Short Description </b></p>
<p> </p>
<p>CAN_E_TIMEOUT </p>
<p> </p>
<p> </p>
<p>DEM_EVENT_STATUS_FAILED </p>
<p> </p>
<p>Timeout in “Hardware Loop Check” occurred, </p>
<p>hardware has to be checked or timeout is too </p>
<p>short. </p>
<p> </p>
<p> </p>
<p> </p>
<p>Table 4-4  </p>
<p>Errors reported to DEM </p>
<p> </p>
<p><b>4.8.3 </b></p>
<p><b>Hardware Loop Check / Timeout Monitoring </b></p>
<p>The feature “Hardware Loop Check” is used to break endless loops caused by hardware </p>
<p>issue. This feature is configurable see Chapter 7 and also Timeout Duration description. </p>
<p>Since AUTOSAR4 a synchronous part of mode transitions will be also limited by this timeout </p>
<p>mechanism which is no issue but a timing limit. The following asynchronous part of mode </p>
<p>transition is handled without Hardware Loop Check. </p>
<p>The  Hardware  Loop  Check  will  be  handled  by  CAN  driver  internal  except  when  setting </p>
<p>“</p>
<p>Hardware Loop Check by Application</p>
<p>” is activated. </p>
<p>Nevertheless,  refer  to  “short  description”  below  (there  may  be  activities  that  should  be </p>
<p>initiated  by  the  application  like  a  reset  of  the  CAN  controller  or  some  special  mode </p>
<p>transitions). If so, the “</p>
<p>Hardware Loop Check by Application</p>
<p>” is recommended to be used to handle </p>
<p>the concerned loop explicitly. </p>
<p> </p>
<p><b>4.8.3.1 </b></p>
<p><b>Critical Loops </b></p>
<p>A loop exception has to be handled by application like described below. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference    MICROSAR CAN Driver </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 3.00.01 </p>
<p>29 </p>
<p><b>Loop Name / </b></p>
<p><b>source </b></p>
<p><b>Short Description </b></p>
<p>kCanLoopInit</p>
<p> </p>
<p>This channel dependent loop is called in Can_InitController </p>
<p>and is processed as long as the CAN cell does not enter </p>
<p>resp. leave the configuration mode.  </p>
<p>While entering the configuration mode, message transfer from </p>
<p>and to the CAN bus is stopped, the status of the CAN bus </p>
<p>transmit output is recessive.  </p>
<p>There is a delay from writing to a command register until </p>
<p>the update of the related status register bits due to clock </p>
<p>domain crossing (Host and CAN clock). Therefore the </p>
<p>programmer has to assure that the previous value written to </p>
<p>INIT has been accepted. </p>
<p>If the loop cancels, try to reinitialize the controller </p>
<p>again or reset the hardware. </p>
<p> </p>
<p> </p>
<p>Table 4-5  </p>
<p>Hardware Loop Check (critical) </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference    MICROSAR CAN Driver </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 3.00.01 </p>
<p>30 </p>
<p><b>4.8.3.2 </b></p>
<p><b>Uncritical Loops </b></p>
<p>No additional application handling needed after loop break. </p>
<p><b>Loop Name / </b></p>
<p><b>source </b></p>
<p><b>Short Description </b></p>
<p>kCanLoopSleep</p>
<p> </p>
<p>When Clock Stop is requested then all pending transfer </p>
<p>requests are completed first.  </p>
<p>When the CAN bus reached idle then Clock Stop will be </p>
<p>acknowledged. </p>
<p>(See also „kCanLoopClockStop“ below, but only used for </p>
<p>Bosch Erratum #7)</p>
<p> </p>
<p>kCanLoopClockSto</p>
<p>p </p>
<p>When Clock Stop is requested then all pending transfer </p>
<p>requests are completed first.  </p>
<p>When the CAN bus reached idle then Clock Stop will be </p>
<p>acknowledged. </p>
<p>(Please see also ch. 4.4.3 </p>
<p>Power Down Mode</p>
<p>) </p>
<p>kCanLoopRxFifo </p>
<p>This channel dependent loop is called in CanInterruptRx  </p>
<p>and is processed  until the Rx FIFO becomes empty. The loop </p>
<p>is delayed if the controller receives  a burst of messages. </p>
<p>The maximum expected duration is the time needed until   </p>
<p>all  messages  in  the  reception  FIFO  are  confirmed.   </p>
<p> </p>
<p>If the loop cancels then, in case of an interrupt driven </p>
<p>configuration, the remaining messages in the Fifo(s) will be </p>
<p>read not till the next Rx interrupt appears. </p>
<p>In case of a polling configuration the polling will continue </p>
<p>as usual with the next task cycle. </p>
<p>Table 4-6  </p>
<p>Hardware Loop Check (uncritical) </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference    MICROSAR CAN Driver </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 3.00.01 </p>
<p>31 </p>
<p><b>4.8.3.3 </b></p>
<p><b>Loops used for synchronous mode transitions </b></p>
<p>AUTOSAR4:  Driver  handle  the  mode  transition  in  asynchronous  way  afterwards,  so  no </p>
<p>additional handling is necessary. </p>
<p>AUTOSAR3: Higher layer has to handle this (see below). </p>
<p><b>Loop Name / </b></p>
<p><b>source </b></p>
<p><b>Short Description </b></p>
<p>kCanLoopStart</p>
<p> </p>
<p>MICROSAR3: </p>
<p>- Used while transition in mode ‘START’. </p>
<p>- Call context: Can_SetControllerMode() </p>
<p>- There is a delay from writing to a command register until </p>
<p>the update of the related status register bits due to clock </p>
<p>domain crossing (Host and CAN clock). Therefore the </p>
<p>programmer has to assure that the previous value written to </p>
<p>INIT has been accepted. </p>
<p>- If the loop cancels try to recall Can_SetControllerMode(). </p>
<p>  </p>
<p>MICROSAR4: </p>
<p>Used for short time mode transition blocking (short </p>
<p>synchronous timeout). Same value for kCanLoopStart, </p>
<p>kCanLoopStop, kCanLoopSleep and kCanLoopWakeup.  </p>
<p>No Issue when timeout occurs.</p>
<p> </p>
<p>kCanLoopStop</p>
<p> </p>
<p>MICROSAR3: </p>
<p>- Used while transition in mode ‘STOP’. </p>
<p>- Call context: Can_SetControllerMode() </p>
<p>- There is a delay from writing to a command register until </p>
<p>the update of the related status register bits due to clock </p>
<p>domain crossing (Host and CAN clock). Therefore the </p>
<p>programmer has to assure that the previous value written to </p>
<p>INIT has been accepted. </p>
<p>- If the loop cancels try to recall Can_SetControllerMode(). </p>
<p> </p>
<p>MICROSAR4: </p>
<p>Used for short time mode transition blocking (short </p>
<p>synchronous timeout). Same value for kCanLoopStart, </p>
<p>kCanLoopStop, kCanLoopSleep and kCanLoopWakeup.  </p>
<p>No Issue when timeout occurs.</p>
<p> </p>
<p>Table 4-7  </p>
<p>Hardware Loop Check (synchronous mode transition) </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference    MICROSAR CAN Driver </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 3.00.01 </p>
<p>32 </p>
<p><b>4.8.4 </b></p>
<p><b>CAN RAM Check </b></p>
<p>The CAN Driver supports a check of the CAN controller’s mailboxes. The CAN controller </p>
<p>RAM </p>
<p>check </p>
<p>is </p>
<p>called </p>
<p>internally </p>
<p>every </p>
<p>time </p>
<p>a </p>
<p>power </p>
<p>on </p>
<p>is </p>
<p>executed </p>
<p>within </p>
<p>function </p>
<p>Can_InitController(), or a Bus-Wakeup event happen. The CAN Driver verifies that no used </p>
<p>mailboxes are corrupt. A mailbox is considered corrupt if a predefined pattern is written to the </p>
<p>appropriate mailbox registers and the read operation does not return the expected pattern. If </p>
<p>a corrupt mailbox is found the function Appl_CanCorruptMailbox() is called. This function tells </p>
<p>the application which mailbox is corrupt.  </p>
<p>After </p>
<p>the </p>
<p>check </p>
<p>of </p>
<p>all </p>
<p>mailboxes </p>
<p>the </p>
<p>CAN </p>
<p>Driver </p>
<p>calls </p>
<p>the </p>
<p>call </p>
<p>back </p>
<p>function </p>
<p>Appl_CanRamCheckFailed() if at least one corrupt mailbox was found. The application must </p>
<p>decide if the CAN Driver disables communication or not by means of the call back function’s </p>
<p>return value. If the application has decided to disable the communication there is no possibility </p>
<p>to enable the communication again until the next call to Can_Init(). </p>
<p>The CAN RAM check functionality itself can be activated via Generation Tool. </p>
<p> </p>
<p><b>4.8.5 </b></p>
<p><b>Extended RAM Check </b></p>
<p>The CAN Driver supports a check for all accessible CAN Controller’s control registers and </p>
<p>mailbox registers. The extended RAM check will be executed during power on initialization </p>
<p>and by direct call. Mailboxes will be deactivated when pattern check fails or configured values </p>
<p>are corrupt. The CAN Controller will be deactivated when at least one mailbox is corrupt or </p>
<p>one or more controller register failed the pattern check or configured values are corrupt.  </p>
<p>Mailbox and controller stay deactivated until  explicitly re-activated. The application is fully </p>
<p>responsible to handle this (see Application Note [7] for further information). </p>
<p> </p>
<p>API to execute extended RAM check: </p>
<p>Can_RamCheckExecute()</p>
<p> </p>
<p> </p>
<p>Callouts to notify corrupt mailboxes or controllers: </p>
<p>CanIf_RamCheckCorruptController(),CanIf_RamCheckCorruptMailbox() </p>
<p> </p>
<p>API to re-activate the mailbox or controller again: </p>
<p>Can_RamCheckEnableMailbox(),Can_RamCheckEnableController()</p>
<p> </p>
<p> </p>
<p>Please note that only the registers that have both read and write functionality are checked. </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference    MICROSAR CAN Driver </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 3.00.01 </p>
<p>33 </p>
<p><b>4.9 </b></p>
<p><b>Common CAN </b></p>
<p>Common  CAN  connect  2  hardware  CAN  channels  to  one  logical  controller.  This  allows </p>
<p>configuring more FullCAN mailboxes. The second hardware channel is used for Rx FullCAN </p>
<p>mailboxes. </p>
<p>The  filter  mask  of  the  BasicCAN  should  exclude  the  message  received  by  the  FullCAN </p>
<p>messages of the second CAN Controller. This means each message ID must be received on </p>
<p>one CAN hardware channel only. The filter optimization takes care about this when common </p>
<p>CAN is activated. </p>
<p>For configuration of Common CAN specific settings in generation tool see chapter 7.6.2. </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>Only one Transceiver (Driver) has to be used for this two Common CAN hardware </p>
<p>channels (connect TX and RX lines). </p>
<p>Reason: Upper layers only know one Controller for this 2 hardware channel Common </p>
<p>CAN and therefore only one Transceiver can be handled. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>4.10 </b></p>
<p><b>Hardware Specific </b></p>
<p>For a correct operation the driver expects all of its registers and the MCAN Message RAM to </p>
<p>be accessible in “User Mode”. Please check the Hardware Reference Manual (see chapter </p>
<p>2) for the appropriate measures to be taken like register and memory protection mechanisms. </p>
<p>For a correct operation the driver also expects the correct configuration of interrupt control </p>
<p>registers and correct transceiver configuration.  </p>
<p>If the application code applies the VStdlib delivered by Vector and it intends to enable/disable </p>
<p>the  global  interrupt  using  different,  then  it  has  configure  the  “lock  level”  within  GENy </p>
<p>accordingly: </p>
<p> </p>
<p>Please note that furthermore the dedicated processor core has to be selected accordingly.  </p>
<p>By default core – 0 is used. If you decide to take another core, then you have to overwrite the </p>
<p>pre-processor macro by using a user-configuration file. </p>
<p>Example (appropriate for SPC58xx derivatives): </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference    MICROSAR CAN Driver </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 3.00.01 </p>
<p>34 </p>
<p>#define PPC_INTC_CPR  (*(volatile uint32*)  0xFC040000  - with INTC_0 used, </p>
<p>#define PPC_INTC_CPR  (*(volatile uint32*)  0xF4044000  - with INTC_1 used, </p>
<p> </p>
<p>Additionally the clock supply has to be provided and finally it is necessary to configure the </p>
<p>port pins correctly to get CAN communication.  </p>
<p> </p>
<p> </p>
<p><b>Please note </b></p>
<p>This configuration work is not part of the CAN Driver. </p>
<p> </p>
<p> </p>
<p><b>4.10.1 </b></p>
<p><b>Error Interrupt </b></p>
<p>The MCAN error interrupt source is used only partially by the CAN Driver. Only BusOff events </p>
<p>are handled and reported to the upper layers by the CAN Driver. </p>
<p> </p>
<p><b>Please note </b></p>
<p>The BusOff recovery sequence cannot be shortened (e.g. by initializing the CAN </p>
<p>device). If the device goes BusOff, it will enter the INIT Mode by its own, stopping all </p>
<p>bus activities.  </p>
<p>When leaving the INIT Mode the device will wait for 129 occurrences of Bus Idle (129 x </p>
<p>11 consecutive recessive bits) before resuming normal operation.  </p>
<p> </p>
<p> </p>
<p><b>Please note </b></p>
<p>The Timeout Counter is used for CAN driver internal purposes (supervision of possible </p>
<p>transmit confirmations arriving delayed after a cancellation was requested). Thus the </p>
<p>“Timeout Occurred” interrupt may occur occasionally. </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p><b>4.10.2 </b></p>
<p><b>Not supported </b></p>
<p>Neither the Tx  Event  FIFO  nor  the Tx  Queue  is  used. All  available  32  transmit message </p>
<p>buffers per CAN channel are used as dedicated buffers and can be used either as BasicCAN </p>
<p>or FullCAN objects (see 4.3.1). </p>
<p>The filtering of High Priority messages is not supported. </p>
<p>No Range Filters are supported. </p>
<p><b> </b></p>
<p><b> </b></p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference    MICROSAR CAN Driver </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 3.00.01 </p>
<p>35 </p>
<p><b>5 </b></p>
<p><b>Integration </b></p>
<p>This chapter gives necessary information for the integration of the MICROSAR CAN into an </p>
<p>application environment of an ECU. </p>
<p><b>5.1 </b></p>
<p><b>Scope of Delivery </b></p>
<p>The delivery of the CAN contains the files, which are described in the chapter’s 5.1.1 and </p>
<p>5.1.2: </p>
<p>Dependent on library or source code delivery the marked (+) files may not be delivered. </p>
<p> </p>
<p><b>5.1.1 </b></p>
<p><b>Static Files </b></p>
<p><b>File Name </b></p>
<p><b>Description </b></p>
<p>(+) Can_Local.h </p>
<p>This is an internal header file which should not be included outside </p>
<p>this module </p>
<p>(+) Can.c </p>
<p>This is the source file of the CAN. It contains the implementation of </p>
<p>CAN module functionality. </p>
<p>(+) Can.lib </p>
<p>This is the library build out of Can.c, Can.h and Can_Local.h </p>
<p>Can.h </p>
<p>This is the header file of the CAN module (include API declaration) </p>
<p>Can_Irq.c </p>
<p>This is the interrupt declaration and callout file (supports interrupt </p>
<p>configuration as link time settings) </p>
<p>Table 5-1  </p>
<p>Static files </p>
<p><b>5.1.2 </b></p>
<p><b>Dynamic Files </b></p>
<p>The dynamic files are generated by the configuration tool. </p>
<p><b>File Name </b></p>
<p><b>Description </b></p>
<p>Can_Cfg.h </p>
<p>Generated header file, contains some type, prototype and pre-</p>
<p>compile settings </p>
<p>Can_Lcfg.c </p>
<p>Generated file contains link time settings. </p>
<p>Can_PBcfg.c </p>
<p>Generated file contains post build settings. </p>
<p>Can_DrvGeneralTypes.h </p>
<p>Generated file contains CAN Driver part of Can_GeneralTypes.h </p>
<p>(supported by Integrator) </p>
<p>Table 5-2  </p>
<p>Generated files </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference    MICROSAR CAN Driver </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 3.00.01 </p>
<p>36 </p>
<p><b>5.2 </b></p>
<p><b>Include Structure </b></p>
<p> </p>
<p>Figure 5-1 </p>
<p>Include Structure (AUTOSAR) </p>
<p>Deviation from AUTOSAR specification: </p>
<p></p>
<p> </p>
<p>Additionally the EcuM_Cbk.h is included by Can_Cfg.h (needed for wakeup notification </p>
<p>API). </p>
<p></p>
<p> </p>
<p>ComStack_Types.h included by Can_Cfg.h, because the specified types have to be </p>
<p>known in generated data as well. </p>
<p></p>
<p> </p>
<p>MICROSAR4x only: Os.h will be included by Can_Cfg.h because of used data-types </p>
<p></p>
<p> </p>
<p>Spi.h is not yet used. </p>
<p></p>
<p> </p>
<p>MICROSAR403 only: Can_GeneralTypes.h will be included by Can_Cfg.h not by Can.h </p>
<p>direct. </p>
<p> </p>
<p><b>5.3 </b></p>
<p><b>Critical Sections </b></p>
<p>The AUTOSAR standard provides with the BSW Scheduler a BSW module, which handles </p>
<p>entering and leaving critical sections.  </p>
<p>For more information about the BSW Scheduler please refer to [3]. When the BSW Scheduler </p>
<p>is used the CAN Driver provides critical section codes that have to be mapped by the BSW </p>
<p>Scheduler to following mechanism: </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference    MICROSAR CAN Driver </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 3.00.01 </p>
<p>37 </p>
<p><b>Critical Section Define </b></p>
<p><b>Description </b></p>
<p>CAN_EXCLUSIVE_AREA_0 </p>
<p>CanNestedGlobalInterruptDisable/Restore() is used within  </p>
<p>Can_MainFunction_Write() and inside the transmit confirmation to assure </p>
<p>that transmit confirmations do not conflict with further transmit requests. </p>
<p><b>&gt; </b></p>
<p>Duration is short. </p>
<p><b>&gt; </b></p>
<p>No API call of other BSW inside. </p>
<p>CAN_EXCLUSIVE_AREA_1 </p>
<p>Using inside Can_DisableControllerInterrupts() and </p>
<p>Can_EnableControllerInterrupts() to secure Interrupt counters for nested </p>
<p>calls. </p>
<p><b>&gt; </b></p>
<p>Duration is short. </p>
<p><b>&gt; </b></p>
<p>No API call of other BSW inside. </p>
<p><b>&gt; </b></p>
<p>Disable global interrupts – or – Empty in case </p>
<p>Can_Disable/EnableControllerInterrupts() are called within context </p>
<p>with lower or equal priority than CAN interrupt. </p>
<p>CAN_EXCLUSIVE_AREA_2 </p>
<p>Using inside Can_Write() to secure software states of transmit objects. </p>
<p><b>&gt; </b></p>
<p>Only when no Vector CAN Interface is used. </p>
<p><b>&gt; </b></p>
<p>Duration is medium. </p>
<p><b>&gt; </b></p>
<p>No API call of other BSW inside. </p>
<p><b>&gt; </b></p>
<p>Disable global interrupts - or - Disable CAN interrupts and does not </p>
<p>call function reentrant. </p>
<p>CAN_EXCLUSIVE_AREA_3 </p>
<p>Using inside Tx confirmation to secure state of transmit object in case of </p>
<p>cancellation. (Only used when Vector Interface Version smaller 4.10 </p>
<p>used) </p>
<p><b>&gt; </b></p>
<p>Duration is medium. </p>
<p><b>&gt; </b></p>
<p>Call to CanIf_CancelTxConfirmation() inside (no more calls in CanIf). </p>
<p><b>&gt; </b></p>
<p>Disable global interrupts - or - Disable CAN interrupts and do not call </p>
<p>function Can_Write() within. </p>
<p>CAN_EXCLUSIVE_AREA_4 </p>
<p>Using inside received data handling (Rx Queue treatment) to secure Rx </p>
<p>Queue counter and data. </p>
<p><b>&gt; </b></p>
<p>Duration is short. </p>
<p><b>&gt; </b></p>
<p>No API call of other BSW inside. </p>
<p><b>&gt; </b></p>
<p>Disable Global Interrupts - or - Disable all CAN interrupts. </p>
<p>CAN_EXCLUSIVE_AREA_5 </p>
<p>Using inside wakeup handling to secure state transition. (Only in wakeup </p>
<p>Polling Mode) </p>
<p><b>&gt; </b></p>
<p>Duration is short. </p>
<p><b>&gt; </b></p>
<p>Call to DET inside. </p>
<p><b>&gt; </b></p>
<p>Disable global interrupts   (do not use CAN interrupt locks here) </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference    MICROSAR CAN Driver </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 3.00.01 </p>
<p>38 </p>
<p>CAN_EXCLUSIVE_AREA_6 </p>
<p>Using inside Can_SetControllerMode() and BusOff to secure state </p>
<p>transition. </p>
<p><b>&gt; </b></p>
<p>Duration is medium. </p>
<p><b>&gt; </b></p>
<p>No API call of other BSW inside. </p>
<p><b>&gt; </b></p>
<p>Use CAN interrupt locks here, when the API for one controller is not </p>
<p>called in a context higher than the CAN interrupt </p>
<p>or </p>
<p>Disable global interrupts </p>
<p>Table 5-3  </p>
<p>Critical Section Codes </p>
<p><b>5.4 </b></p>
<p><b>Compiler Abstraction and Memory Mapping  </b></p>
<p>The  objects  (e.g.  variables,  functions,  constants)  are  declared  by  compiler  independent </p>
<p>definitions  –  the  compiler  abstraction  definitions.  Each  compiler  abstraction  definition  is </p>
<p>assigned to a memory section. </p>
<p>The  following  table  contains  the  memory  section  names  and  the  compiler  abstraction </p>
<p>definitions defined for the CAN Interface and illustrates their assignment among each other. </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference    MICROSAR CAN Driver </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 3.00.01 </p>
<p>39 </p>
<p><i><b>Compiler Abstraction </b></i></p>
<p><i><b>Definitions </b></i></p>
<p><i><b> </b></i></p>
<p><i> </i></p>
<p><i><b>Memory Mapping </b></i></p>
<p><i><b>Sections </b></i></p>
<p><i>CAN_CODE </i></p>
<p><i>CAN_STATIC_CODE </i></p>
<p><i>CAN_CONST  </i></p>
<p><i>CAN_CONST_PBCFG </i></p>
<p><i>CAN_VAR_NOINIT </i></p>
<p><i>CAN_VAR_INIT </i></p>
<p><i>CAN_VAR_PBCFG </i></p>
<p><i>CAN_INT_CTRL </i></p>
<p><i>CAN_REG_CANCELL </i></p>
<p><i>CAN_RX_TX_DATA </i></p>
<p><i>CAN_APPL_CODE </i></p>
<p><i>CAN_APPL_CONST </i></p>
<p><i>CAN_APPL_VAR </i></p>
<p>CAN_START_SEC_CODE </p>
<p>CAN_STOP_SEC_CODE </p>
<p></p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>CAN_START_SEC_STATIC_CODE </p>
<p>CAN_STOP_SEC_STATIC_CODE </p>
<p> </p>
<p></p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>CAN_START_SEC_CONST_8BIT </p>
<p>CAN_STOP_SEC_CONST_8BIT </p>
<p> </p>
<p> </p>
<p></p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>CAN_START_SEC_CONST_16BIT </p>
<p>CAN_STOP_SEC_CONST_16BIT </p>
<p> </p>
<p> </p>
<p></p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>CAN_START_SEC_CONST_32BIT </p>
<p>CAN_STOP_SEC_CONST_32BIT </p>
<p> </p>
<p> </p>
<p></p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>CAN_START_SEC_CONST_UNSPECIFIED </p>
<p>CAN_STOP_SEC_CONST_UNSPECIFIED </p>
<p> </p>
<p> </p>
<p></p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>CAN_START_SEC_PBCFG </p>
<p>CAN_STOP_SEC_PBCFG </p>
<p> </p>
<p> </p>
<p> </p>
<p></p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>CAN_START_SEC_PBCFG_ROOT </p>
<p>CAN_STOP_SEC_PBCFG_ROOT </p>
<p> </p>
<p> </p>
<p> </p>
<p></p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>CAN_START_SEC_VAR_NOINIT_UNSPECIFIED </p>
<p>CAN_STOP_SEC_VAR_NOINIT_UNSPECIFIED </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p></p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>CAN_START_SEC_VAR_INIT_UNSPECIFIED </p>
<p>CAN_STOP_SEC_VAR_INIT_UNSPECIFIED </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p></p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>CAN_START_SEC_VAR_PBCFG  </p>
<p>CAN_STOP_SEC_VAR_PBCFG </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p></p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>CAN_START_SEC_CODE_APPL </p>
<p>CAN_STOP_SEC_CODE_APPL </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p></p>
<p> </p>
<p> </p>
<p> </p>
<p>Table 5-4  </p>
<p>Compiler abstraction and memory mapping </p>
<p>The </p>
<p>Compiler </p>
<p>Abstraction </p>
<p>Definitions </p>
<p>CAN_APPL_CODE, </p>
<p>CAN_APPL_VAR </p>
<p>and </p>
<p>CAN_APPL_CONST are used to address code, variables and constants which are declared </p>
<p>by other modules and used by the CAN Driver. </p>
<p>These definitions are not mapped by the CAN Driver but by the memory mapping realized in </p>
<p>the CAN Interface or direct by application. </p>
<p>CAN_CODE: used for CAN module code. </p>
<p>CAN_STATIC_CODE: used for CAN module local code. </p>
<p>CAN_CONST: used for CAN module constants. </p>
<p>CAN_CONST_PBCFG: used for CAN module constants in Post-Build section. </p>
<p>CAN_VAR_*: used for CAN module variables. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference    MICROSAR CAN Driver </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 3.00.01 </p>
<p>40 </p>
<p>CAN_INT_CTRL: is used to access the CAN interrupt controls. </p>
<p>CAN_REG_CANCELL: is used to access the CAN cell itself. </p>
<p>CAN_RX_TX_DATA: access to CAN Data buffers. </p>
<p>CAN_APPL_*: access to higher layers. </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference    MICROSAR CAN Driver </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 3.00.01 </p>
<p>41 </p>
<p><b>6 </b></p>
<p><b>Hardware Specific Hints </b></p>
<p><b>6.1 </b></p>
<p><b>Usage of interrupt functions </b></p>
<p>   </p>
<p>According  to  the  current  implementation  of  MCAN  generator  there  is a  fix  assignment  of </p>
<p>interrupt functions to the CAN Controller. The postfix of the interrupt function name equates </p>
<p>the  controller  number.  The  following  table  shows  the  corresponding  assignment  for  the </p>
<p>derivative RH850 P1X-C. </p>
<p><b>Critical Section Define </b></p>
<p><b>Description </b></p>
<p>TTCAN_0</p>
<p>, </p>
<p>BaseAddress:  0xFFD30000  CanIsr_1</p>
<p>  </p>
<p>CanIsr_0  </p>
<p>MCAN_0</p>
<p>,  </p>
<p>BaseAddress:  0xFFEF0000  CanIsr_1</p>
<p>  </p>
<p>CanIsr_1  </p>
<p>MCAN_1</p>
<p>,  </p>
<p>BaseAddress:  0xFFD31000  CanIsr_2</p>
<p>  </p>
<p>CanIsr_2  </p>
<p>MCAN_2</p>
<p>,  </p>
<p>BaseAddress:  0xFFEF1000  CanIsr_3</p>
<p>  </p>
<p>CanIsr_3  </p>
<p>Table 5-5   Hardware Controller – Interrupt Functions  </p>
<p><b>6.2 </b></p>
<p><b>MCAN Errata  </b></p>
<p>The following Errata (please see ch. 6.2 for further details) are considered by the CAN Driver. </p>
<p>By default all erratas which are appropriate for the configured MCAN Revision are enabled. </p>
<p>If a specific erratum shall be disabled or enabled beyond that it can be configured via a user </p>
<p>configuration file. </p>
<p>Errata </p>
<p>No. </p>
<p>Title </p>
<p>MCAN </p>
<p>Rev. </p>
<p>affected </p>
<p>6 </p>
<p>Change of CAN operation mode during start of transmission. </p>
<p>Only activated if “</p>
<p>CAN_BOSCH_ERRATUM_006“ is defined as STD_ON.</p>
<p> </p>
<p>2.9.5, </p>
<p>2.9.6, </p>
<p>3.0.0, </p>
<p>3.0.1 </p>
<p>7 </p>
<p>Problem </p>
<p>with </p>
<p>frame </p>
<p>transmission </p>
<p>after </p>
<p>recovery </p>
<p>from </p>
<p>Restricted </p>
<p>Operation Mode. </p>
<p>Only activated if “</p>
<p>CAN_BOSCH_ERRATUM_007“ is defined as STD_ON.</p>
<p> </p>
<p>2.9.5, </p>
<p>2.9.6, </p>
<p>3.0.0, </p>
<p>3.0.1 </p>
<p>8 </p>
<p>Setting / resetting CCCR.INIT during frame reception. </p>
<p>Only activated if “</p>
<p>CAN_BOSCH_ERRATUM_008“ is defined as STD_ON.</p>
<p> </p>
<p>2.9.5, </p>
<p>2.9.6, </p>
<p>3.0.0, </p>
<p>3.0.1 </p>
<p>10 </p>
<p>Setting CCCR.CCE while a Tx scan is ongoing. </p>
<p>Only activated if “</p>
<p>CAN_BOSCH_ERRATUM_010“ is defined as STD_ON.</p>
<p> </p>
<p>2.9.5, </p>
<p>2.9.6,  </p>
<p>3.0.0, </p>
<p>3.0.1 </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference    MICROSAR CAN Driver </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 3.00.01 </p>
<p>42 </p>
<p>11 </p>
<p>Needless activation of interrupt IR.MRAF. </p>
<p>Only activated if “</p>
<p>CAN_BOSCH_ERRATUM_011“ is defined as STD_ON.</p>
<p> </p>
<p>2.9.5, </p>
<p>2.9.6, </p>
<p>3.0.0, </p>
<p>3.0.1, </p>
<p>3.1.0 </p>
<p>12 </p>
<p>Return  of  receiver  from  Bus  Integration  state  after  Protocol  Exception </p>
<p>Event. </p>
<p>Only activated if “</p>
<p>CAN_BOSCH_ERRATUM_012“ is defined as STD_ON.</p>
<p> </p>
<p>2.9.6, </p>
<p>3.0.0, </p>
<p>3.0.1, </p>
<p>3.1.0 </p>
<p>13  </p>
<p>Message RAM / RAM Arbiter not responding in time. </p>
<p>When the M_CAN wants to store a received frame and the Message RAM </p>
<p>/ RAM Arbiter does not respond in time, this message cannot be stored </p>
<p>completely and it is discarded with the reception of the next message. </p>
<p>Interrupt  ﬂag  IR.MRAF  is  set.  It  may  happen  that  the  next  received </p>
<p>message is stored incomplete.  </p>
<p>In </p>
<p>this </p>
<p>case, </p>
<p>the </p>
<p>respective </p>
<p>Rx </p>
<p>Buffer </p>
<p>or </p>
<p>Rx </p>
<p>FIFO </p>
<p>element </p>
<p>holds </p>
<p>inconsistent data. </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p>When the M_CAN has been integrated correctly (the Host and  the </p>
<p>CAN clock must be fast enough to handle a worst case </p>
<p>configuration containing the maximum of MCAN Message RAM </p>
<p>elements), this behaviour  can only occur in case of a problem with </p>
<p>the Message RAM itself or the RAM Arbiter.  </p>
<p>The application must assure that the clocking of Host and CAN is </p>
<p>appropriate. The CAN Driver does not care about these   </p>
<p>configuration aspects.  </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p>2.9.6, </p>
<p>3.0.0, </p>
<p>3.0.1, </p>
<p>3.1.0, </p>
<p>3.2.0 </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference    MICROSAR CAN Driver </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 3.00.01 </p>
<p>43 </p>
<p>14 </p>
<p>Data  loss  (payload)  in  case  storage  of </p>
<p>a  received  frame  has  not </p>
<p>completed until end of EOF ﬁeld is reached. </p>
<p>The  time  needed  for  acceptance  ﬁltering  and  storage  of  a  received </p>
<p>message depends on the  </p>
<p>- </p>
<p>Host clock frequency,  </p>
<p>- </p>
<p>the number of M_CANs connected to a single Message RAM,  </p>
<p>- </p>
<p>the Message RAM arbitration scheme, and  </p>
<p>- </p>
<p>the number of conﬁgured ﬁlter elements. </p>
<p>In case storage of a received message has not completed until end of the </p>
<p>received  frame  then  corrupted  data  can  be  contained  in  the  Message </p>
<p>RAM.  </p>
<p> </p>
<p>Interrupt ﬂag IR.MRAF is not set. </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p>If storage of messages cannot be completed the application is </p>
<p>responsible for reducing the maximum number of configured filter </p>
<p>elements for the M_CANs attached to the Message RAM until the </p>
<p>calculated clock frequency is below the Host clock frequency used </p>
<p>with the actual device. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p>2.9.6, </p>
<p>3.0.0, </p>
<p>3.0.1, </p>
<p>3.1.0, </p>
<p>3.2.0 </p>
<p>1-5 </p>
<p>These  errata  are  in  the  responsibility  of  the  application  and  are  not </p>
<p>considered by the CAN Driver. </p>
<p>2.0.0, </p>
<p>2.9.5, </p>
<p>2.9.6, </p>
<p>3.0.0, </p>
<p>3.0.1 </p>
<p>9 </p>
<p>Frame transmission in DAR mode. </p>
<p>Not considered by the CAN Driver, frame transmission in DAR mode is </p>
<p>not supported. </p>
<p> </p>
<p>2.9.5, </p>
<p>2.9.6, </p>
<p>3.0.0, </p>
<p>3.0.1 </p>
<p>15 </p>
<p>Edge ﬁltering causes miss-synchronization when falling edge at Rx input </p>
<p>pin coincides with end of integration phase. </p>
<p>Not considered by the CAN Driver, Edge Filtering is not supported. </p>
<p> </p>
<p>3.1.0, </p>
<p>3.2.0, </p>
<p>3.2.1 </p>
<p>16 </p>
<p>Conﬁguration of NBTP.NTSEG2 = ‘0’ is not allowed. </p>
<p>This erratum is in the responsibility of the application during configuration </p>
<p>time and is not considered by the CAN Driver during compile or runtime. </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference    MICROSAR CAN Driver </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 3.00.01 </p>
<p>44 </p>
<p>17 </p>
<p>Retransmission  in  DAR  mode  due  to  lost  arbitration  at  the  ﬁrst  two </p>
<p>identiﬁer bits. </p>
<p>Not considered by the CAN Driver, DAR Mode is not supported. </p>
<p>2.9.6, </p>
<p>3.0.0, </p>
<p>3.0.1, </p>
<p>3.1.0, </p>
<p>3.2.0, </p>
<p>3.2.1 </p>
<p>18 </p>
<p>Tx FIFO message sequence inversion. </p>
<p>Not considered by the CAN Driver, Tx Fifo is not supported. </p>
<p>Table 6-1  </p>
<p>MCAN Errata </p>
<p><b>6.3 </b></p>
<p><b>Platform Errata </b></p>
<p>The following Errata must be considered depending on the underlying hardware platform: </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference    MICROSAR CAN Driver </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 3.00.01 </p>
<p>45 </p>
<p><b>7 </b></p>
<p><b>API Description </b></p>
<p><b>7.1 </b></p>
<p><b>Interrupt Service Routines provided by CAN </b></p>
<p>In the decription below the “<i>platform</i>” placeholder stands for one of the given platforms (e.g. </p>
<p>Mpc5700, Spc5800, Traveo, Rh850, Tricore, Atmel SAM …)  </p>
<p>Depending on the settings in Tools component Hw_&lt;<i>platform</i>&gt;Cpu, the interrupt routine is </p>
<p>given by the driver or by Operating System. (Selection below, not </p>
<p>MICROSAR403</p>
<p>) </p>
<p>Example for Mpc5700 platform: </p>
<p> </p>
<p>Figure 7-1 </p>
<p>Select OS Type </p>
<p>There is the possibility to choose OS Type. Please select “None” for using no OS, “Autosar” </p>
<p>for AUTOSAR OS or “OSEK” for OSEK OS systems. </p>
<p><b>7.1.1 </b></p>
<p><b>OSEK (OS) </b></p>
<p>This means to include osek.h.  </p>
<p>Switch: V_OSTYPE_OSEK </p>
<p><b>7.1.2 </b></p>
<p><b>AutoSar (OS) </b></p>
<p>Os.h header file is used. </p>
<p>Switch: V_OSTYPE_AUTOSAR </p>
<p><b>7.1.3 </b></p>
<p><b>None (OS) </b></p>
<p>Choose “None” for OS Type, to include no Os header files and have no category 2 interrupt. </p>
<p>Switch: V_OSTYPE_NONE </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference    MICROSAR CAN Driver </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 3.00.01 </p>
<p>46 </p>
<p> </p>
<p> </p>
<p><b>7.1.4 </b></p>
<p><b>Type of Interrupt Function </b></p>
<p>See Chapter “Component Settings” for configuration aspects. </p>
<p>-</p>
<p> </p>
<p>Category 2 (only for OSEK OS or AUTOSAR OS):  </p>
<p>A macro “ISR(CanIsr_x)” will be used to declare ISR function call. The name given </p>
<p>as parameter for interrupt naming (x = Physical CAN Channel number). For macro </p>
<p>definition see OS specification. The OS has full control of the ISR. </p>
<p>switch: C_ENABLE_OSEK_OS_INTCAT2 </p>
<p>-</p>
<p> </p>
<p>Category 1: </p>
<p>Using OS with category 1 interrupts need an Interface layer handling these interrupts </p>
<p>in task context like defined in BSW00326 (AUTOSAR_SRS_General). </p>
<p>switch: C_DISABLE_OSEK_OS_INTCAT2 </p>
<p>-</p>
<p> </p>
<p>Void-Void Interrupt Function: </p>
<p>Like in Category 1 the Interrupt is not handled by OS and the ISR is declared as void </p>
<p>ISR(void) and has to be called by interrupt controller in case of an CAN interrupt. </p>
<p>switch: C_ENABLE_ISRVOID </p>
<p> </p>
<p> </p>
<p><b>7.1.5 </b></p>
<p><b>CAN ISR API </b></p>
<p><b>Prototype </b></p>
<p>void <b>CanIsr_&lt;x&gt;</b>(void); </p>
<p><b>Parameter </b></p>
<p>--- </p>
<p>--- </p>
<p><b>Return code </b></p>
<p>--- </p>
<p>--- </p>
<p><b>Functional Description </b></p>
<p>Handles interrupts of hardware channel &lt;x&gt; for Rx, Tx, BusOff events. </p>
<p><b>Particularities and Limitations </b></p>
<p>&gt; </p>
<p>Number of available functions depends on used MCU derivative. </p>
<p>&gt; </p>
<p>The functions are not designated as interrupt functions. If it is necessary to save/restore all general </p>
<p>purpose registers and to use a different “return from interrupt” instruction the application code has to </p>
<p>implement the compiler specific pragma (e.g. for Wind River™ DIAB™: #pragma interrupt CanIsr_x). </p>
<p>Table 7-1  </p>
<p>MCAN CanIsr_&lt;x&gt; </p>
<p><b>7.2 </b></p>
<p><b>Services provided by CAN </b></p>
<p>The CAN API consists of services, which are realized by function calls. </p>
<p> </p>
<p><b>7.2.1 </b></p>
<p><b>Can_InitMemory </b></p>
<p><b>Prototype </b></p>
<p>void <b>Can_InitMemory </b>(void) </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference    MICROSAR CAN Driver </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 3.00.01 </p>
<p>47 </p>
<p><b>Parameter </b></p>
<p>-  </p>
<p> </p>
<p><b>Return code </b></p>
<p>void </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>Service initializes module global variables, which cannot be initialized in the startup code.  </p>
<p>Use this to re-run the system without performing a new start from power on.  </p>
<p>(E.g.: used to support an ongoing debug session without a complete re-initialization.)  </p>
<p>Must be followed by a call to &quot;Can_Init()&quot;. </p>
<p><b>Particularities and Limitations </b></p>
<p>Called by Application. </p>
<p> </p>
<p><b>Caution</b> </p>
<p>None AUTOSAR API </p>
<p>Call context </p>
<p>&gt; </p>
<p>Should be called while power on initialization before &quot;Can_Init()&quot; on task level. </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Non-Reentrant </p>
<p>&gt; </p>
<p>Availability: Always </p>
<p>Table 7-2  </p>
<p>Can_InitMemory </p>
<p> </p>
<p><b>7.2.2 </b></p>
<p><b>Can_Init </b></p>
<p><b>Prototype </b></p>
<p>void <b>Can_Init </b>(Can_ConfigPtrType ConfigPtr) </p>
<p><b>Parameter </b></p>
<p>ConfigPtr [in] </p>
<p>Pointer to the configuration data structure.  </p>
<p>When using the &quot;Multiple ECU&quot; configuration feature, then for each Identity the </p>
<p>appropriate  </p>
<p>&quot;CanConfig_&lt;Identity&gt;&quot;-structure exists and has to be chosen here. </p>
<p><b>Return code </b></p>
<p>void </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>This function initializes global CAN Driver variables during ECU start-up.  </p>
<p><b>Particularities and Limitations </b></p>
<p>Called by Can Interface. </p>
<p>Parameter &quot;ConfigPtr&quot; will be taken into account only for &quot;Multiple ECU Configrutaion&quot; and in Post-Build </p>
<p>variant.  </p>
<p>Disabled Interrupts.  </p>
<p>Call context </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference    MICROSAR CAN Driver </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 3.00.01 </p>
<p>48 </p>
<p>&gt; </p>
<p>Has to be called during start-up before CAN communication.  </p>
<p>&gt; </p>
<p>Must be called before calling &quot;Can_InitController()&quot; but after call of &quot;Can_InitMemory()&quot;. </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Non-Reentrant </p>
<p>&gt; </p>
<p>Availability: Always </p>
<p>Table 7-3  </p>
<p>Can_Init </p>
<p> </p>
<p><b>7.2.3 </b></p>
<p><b>Can_InitController </b></p>
<p><b>Prototype </b></p>
<p>void <b>Can_InitController </b>(uint8 Controller, Can_ControllerBaudrateConfigPtrType </p>
<p>Config) </p>
<p><b>Parameter </b></p>
<p>Controller [in] </p>
<p>Number of controller </p>
<p>Config [in] </p>
<p>Pointer to baud rate configuration structure </p>
<p><b>Return code </b></p>
<p>void </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>Initialization of controller specific CAN hardware.  </p>
<p>The CAN Driver registers and variables are initialized.  </p>
<p>The CAN controller is fully initialized and left back within the state &quot;Stop Mode&quot;, ready to change to </p>
<p>&quot;Running Mode&quot;. </p>
<p><b>Particularities and Limitations </b></p>
<p>Called by CanInterface. </p>
<p>Disabled Interrupts.  </p>
<p>Call context </p>
<p>&gt; </p>
<p>Has to be called during the startup sequence before CAN communication takes place but after calling </p>
<p>&quot;Can_Init()&quot;.  </p>
<p>&gt; </p>
<p>Must not be called while in &quot;Sleep Mode&quot;. </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Non-Reentrant </p>
<p>&gt; </p>
<p>Availability: MICROSAR401 only </p>
<p>Table 7-4  </p>
<p>Can_InitController </p>
<p> </p>
<p><b>7.2.4 </b></p>
<p><b>Can_InitController </b></p>
<p><b>Prototype </b></p>
<p>void <b>Can_InitController </b>(uint8 Controller, Can_ControllerConfigPtrType </p>
<p>ControllerConfigPtr) </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference    MICROSAR CAN Driver </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 3.00.01 </p>
<p>49 </p>
<p><b>Parameter </b></p>
<p>Controller [in] </p>
<p>Number of controller </p>
<p>Config [in] </p>
<p>Pointer to the configuration data structure. </p>
<p><b>Return code </b></p>
<p>void </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>Initialization of controller specific CAN hardware.  </p>
<p>The CAN Driver registers and variables are initialized.  </p>
<p>The CAN controller is fully initialized and left back within the state &quot;Stop Mode&quot;, ready to change to </p>
<p>&quot;Running Mode&quot;. </p>
<p><b>Particularities and Limitations </b></p>
<p>Called by CanInterface. </p>
<p>Disabled Interrupts </p>
<p>Call context </p>
<p>&gt; </p>
<p>Has to be called during the startup sequence before CAN communication takes place but after calling </p>
<p>&quot;Can_Init()&quot;.  </p>
<p>&gt; </p>
<p>Must not be called while in &quot;Sleep Mode&quot;. </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Non-Reentrant </p>
<p>&gt; </p>
<p>Availability: MICROSAR3 only </p>
<p>Table 7-5  </p>
<p>Can_InitController </p>
<p> </p>
<p><b>7.2.5 </b></p>
<p><b>Can_ChangeBaudrate </b></p>
<p><b>Prototype </b></p>
<p>Std_ReturnType <b>Can_ChangeBaudrate </b>(uint8 Controller, const uint16 Baudrate) </p>
<p><b>Parameter </b></p>
<p>Controller [in] </p>
<p>Number of controller to be changed </p>
<p>Baudrate [in] </p>
<p>Baud rate to be set </p>
<p><b>Return code </b></p>
<p>Std_ReturnType </p>
<p>&gt; </p>
<p>E_NOT_OK Baud rate is not set  </p>
<p>&gt; </p>
<p>E_OK Baud rate is set </p>
<p><b>Functional Description </b></p>
<p>This service shall change the baud rate and reinitialize the CAN controller.  </p>
<p><b>Particularities and Limitations </b></p>
<p>Called by Application. </p>
<p>The CAN controller must be in &quot;Stop Mode&quot;. </p>
<p>Call context </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference    MICROSAR CAN Driver </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 3.00.01 </p>
<p>50 </p>
<p>&gt; </p>
<p>Has to be called during the startup sequence before CAN communication takes place but after calling </p>
<p>&quot;Can_Init()&quot;. </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Non-Reentrant </p>
<p>&gt; </p>
<p>Availability: MICROSAR403 only &amp; if &quot;CanChangeBaudrateApi&quot; is activated or &quot;CanSetBaudrateApi&quot; is </p>
<p>de-activated. </p>
<p>Table 7-6  </p>
<p>Can_ChangeBaudrate </p>
<p> </p>
<p><b>7.2.6 </b></p>
<p><b>Can_CheckBaudrate </b></p>
<p><b>Prototype </b></p>
<p>Std_ReturnType <b>Can_CheckBaudrate </b>(uint8 Controller, const uint16 Baudrate) </p>
<p><b>Parameter </b></p>
<p>Controller [in] </p>
<p>Number of controller to be checked </p>
<p>Baudrate [in] </p>
<p>Baud rate to be checked </p>
<p><b>Return code </b></p>
<p>Std_ReturnType </p>
<p>&gt; </p>
<p>E_NOT_OK Baud rate is not available  </p>
<p>&gt; </p>
<p>E_OK Baud rate is available </p>
<p><b>Functional Description </b></p>
<p>This service shall check if the given baud rate is supported of the CAN controller.  </p>
<p><b>Particularities and Limitations </b></p>
<p>Called by Application. </p>
<p>The CAN controller must be initialized.  </p>
<p>Call context </p>
<p>&gt; </p>
<p>Must not be called nested.  </p>
<p>&gt; </p>
<p>Only available if &quot;CanChangeBaudrateApi&quot; is activated. </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Non-Reentrant </p>
<p>&gt; </p>
<p>Availability: MICROSAR403 only &amp; &quot;CanChangeBaudrateApi&quot; is activated </p>
<p>(&quot;CAN_CHANGE_BAUDRATE_API == STD_ON&quot;) </p>
<p>Table 7-7  </p>
<p>Can_CheckBaudrate </p>
<p> </p>
<p><b>7.2.7 </b></p>
<p><b>Can_SetBaudrate </b></p>
<p><b>Prototype </b></p>
<p>Std_ReturnType <b>Can_SetBaudrate </b>(uint8 Controller, uint16 BaudRateConfigID) </p>
<p><b>Parameter </b></p>
<p>Controller [in] </p>
<p>Number of controller to be set </p>
<p>BaudRateConfigID [in] </p>
<p>Identity of the configured baud rate (available as Symbolic Name) </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference    MICROSAR CAN Driver </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 3.00.01 </p>
<p>51 </p>
<p><b>Return code </b></p>
<p>Std_ReturnType </p>
<p>&gt; </p>
<p>E_NOT_OK Baud rate is not set  </p>
<p>&gt; </p>
<p>E_OK Baud rate is set </p>
<p><b>Functional Description </b></p>
<p>This service shall change the baud rate and reinitialize the CAN controller.  </p>
<p>(Similar to &quot;Can_ChangeBaudrate()&quot; but used when identical baud rates are used for different CAN FD </p>
<p>settings).  </p>
<p><b>Particularities and Limitations </b></p>
<p>Called by Application. </p>
<p>Call context </p>
<p>&gt; </p>
<p>Must not be called nested.  </p>
<p>&gt; </p>
<p>Only available if &quot;CanSetBaudrateApi&quot; is activated. </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Non-Reentrant </p>
<p>&gt; </p>
<p>Availability: MICROSAR403 only &amp; &quot;CanSetBaudrateApi&quot; is activated (&quot;CAN_SET_BAUDRATE_API == </p>
<p>STD_ON&quot;) </p>
<p>Table 7-8  </p>
<p>Can_SetBaudrate </p>
<p> </p>
<p><b>7.2.8 </b></p>
<p><b>Can_InitStruct </b></p>
<p><b>Prototype </b></p>
<p>void <b>Can_InitStruct </b>(uint8 Controller, uint8 Index) </p>
<p><b>Parameter </b></p>
<p>Controller [in] </p>
<p>Number of the controller to be changed </p>
<p>Index [in] </p>
<p>Index of the initialization structure to be used for baud rate and mask settings </p>
<p><b>Return code </b></p>
<p>void </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>Set content of the initialization structure (before calling &quot;Can_InitController()&quot;).  </p>
<p>Service function to change the initialization structure setup left behind by the Generation Tool.  </p>
<p>The structure contains information about baud rate and filter settings.  </p>
<p>Subsequent &quot;Can_InitController()&quot; must be called to activate these settings.  </p>
<p><b>Particularities and Limitations </b></p>
<p>Called by Application. </p>
<p>&quot;Can_Init&quot; was called.  </p>
<p> </p>
<p><b>Caution</b> </p>
<p>None AUTOSAR API </p>
<p>Call context </p>
<p>&gt; </p>
<p>Call this function between calling &quot;Can_Init()&quot; and &quot;Can_InitController()&quot;. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference    MICROSAR CAN Driver </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 3.00.01 </p>
<p>52 </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Non-Reentrant </p>
<p>&gt; </p>
<p>Availability: MICROSAR3 only </p>
<p>Table 7-9  </p>
<p>Can_InitStruct </p>
<p> </p>
<p><b>7.2.9 </b></p>
<p><b>Can_GetVersionInfo </b></p>
<p><b>Prototype </b></p>
<p>void <b>Can_GetVersionInfo </b>(Can_VersionInfoPtrType VersionInfo) </p>
<p><b>Parameter </b></p>
<p>VersionInfo [out] </p>
<p>Pointer to where to store the version information of the CAN Driver.  </p>
<p>typedef struct {  </p>
<p>uint16 vendorID;  </p>
<p>uint16 moduleID;  </p>
<p>MICROSAR3 only: uint8 instanceID;  </p>
<p>uint8 sw_major_version; (MICROSAR3 only: BCD coded)  </p>
<p>uint8 sw_minor_version; (MICROSAR3 only: BCD coded)  </p>
<p>uint8 sw_patch_version; (MICROSAR3 only: BCD coded)  </p>
<p>} Std_VersionInfoType; </p>
<p><b>Return code </b></p>
<p>void </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>Get the version information of the CAN Driver.  </p>
<p><b>Particularities and Limitations </b></p>
<p>Called by Application. </p>
<p>Call context </p>
<p>&gt; </p>
<p>Only available if &quot;CanVersionInfoApi&quot; is activated. </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Reentrant </p>
<p>&gt; </p>
<p>Availability: &quot;CanVersionInfoApi&quot; is activated (&quot;CAN_VERSION_INFO_API == STD_ON&quot;) </p>
<p>Table 7-10  </p>
<p>Can_GetVersionInfo </p>
<p> </p>
<p><b>7.2.10 </b></p>
<p><b>Can_GetStatus </b></p>
<p><b>Prototype </b></p>
<p>uint8 <b>Can_GetStatus </b>(uint8 Controller) </p>
<p><b>Parameter </b></p>
<p>Controller [in] </p>
<p>Number of the controller requested for status information </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference    MICROSAR CAN Driver </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 3.00.01 </p>
<p>53 </p>
<p><b>Return code </b></p>
<p>uint8 </p>
<p>&gt; </p>
<p>CAN_STATUS_START </p>
<p>&gt; </p>
<p>CAN_STATUS_STOP (Bit coded status information)  </p>
<p>&gt; </p>
<p>CAN_STATUS_INIT  </p>
<p>&gt; </p>
<p>CAN_STATUS_INCONSISTENT,  </p>
<p>&gt; </p>
<p>CAN_DEACTIVATE_CONTROLLER (only with &quot;CanRamCheck&quot; active) </p>
<p>&gt; </p>
<p>CAN_STATUS_WARNING  </p>
<p>&gt; </p>
<p>CAN_STATUS_PASSIVE  </p>
<p>&gt; </p>
<p>CAN_STATUS_BUSOFF  </p>
<p>&gt; </p>
<p>CAN_STATUS_SLEEP </p>
<p><b>Functional Description </b></p>
<p>Delivers the status of the hardware.  </p>
<p>Only one of the status bits CAN_STATUS_SLEEP/ STOP/ START/ BUSOFF/ PASSIVE/ WARNING is set.  </p>
<p>The CAN_STATUS_INIT bit is always set if a controller is initialized.  </p>
<p>CAN_STATUS_SLEEP has the highest and CAN_STATUS_WARNING the lowest priority.  </p>
<p>CAN_STATUS_INCONSISTENT will be set if one Common CAN channel. is not &quot;Stop&quot; or &quot;Sleep&quot;.  </p>
<p>CAN_DEACTIVATE_CONTROLLER is set in case the &quot;CanRamCheck&quot; detected an Issue.  </p>
<p>&quot;status&quot; can be analyzed using the provided API macros:  </p>
<p>CAN_HW_IS_OK(status): return &quot;true&quot; in case no warning, passive or bus off occurred.  </p>
<p>CAN_HW_IS_WARNING(status): return &quot;true&quot; in case of waning status.  </p>
<p>CAN_HW_IS_PASSIVE(status): return &quot;true&quot; in case of passive status.  </p>
<p>CAN_HW_IS_BUSOFF(status): return &quot;true&quot; in case of bus off status (may be already false in Notification).  </p>
<p>CAN_HW_IS_WAKEUP(status): return &quot;true&quot; in case of not in Sleep Mode.  </p>
<p>CAN_HW_IS_SLEEP(status): return &quot;true&quot; in case of Sleep Mode.  </p>
<p>CAN_HW_IS_STOP(status): return &quot;true&quot; in case of Stop Mode.  </p>
<p>CAN_HW_IS_START(status): return &quot;true&quot; in case of not in Stop Mode.  </p>
<p>CAN_HW_IS_INCONSISTENT(status): return &quot;true&quot; in case of an inconsistency between two common </p>
<p>CAN channels.  </p>
<p><b>Particularities and Limitations </b></p>
<p>Called by network management or Application. </p>
<p> </p>
<p><b>Caution</b> </p>
<p>None AUTOSAR API </p>
<p>Call context </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Non-Reentrant </p>
<p>&gt; </p>
<p>Availability: &quot;CanGetStatus&quot; is activated (&quot;CAN_GET_STATUS == STD_ON&quot;) </p>
<p>Table 7-11  </p>
<p>Can_GetStatus </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference    MICROSAR CAN Driver </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 3.00.01 </p>
<p>54 </p>
<p><b>7.2.11 </b></p>
<p><b>Can_SetControllerMode </b></p>
<p><b>Prototype </b></p>
<p>Can_ReturnType <b>Can_SetControllerMode </b>(uint8 Controller, Can_StateTransitionType </p>
<p>Transition) </p>
<p><b>Parameter </b></p>
<p>Controller [in] </p>
<p>Number of the controller to be set </p>
<p>Transition [in] </p>
<p>Requested transition to destination mode </p>
<p><b>Return code </b></p>
<p>Can_ReturnType </p>
<p>&gt; </p>
<p>CAN_NOT_OK mode change unsuccessful  </p>
<p>&gt; </p>
<p>CAN_OK mode change successful </p>
<p><b>Functional Description </b></p>
<p>Change the controller mode to the following possible destination values:  </p>
<p>CAN_T_START,  </p>
<p>CAN_T_STOP,  </p>
<p>CAN_T_SLEEP,  </p>
<p>CAN_T_WAKEUP.  </p>
<p><b>Particularities and Limitations </b></p>
<p>Called by CanInterface. </p>
<p>Interrupts locked by CanInterface </p>
<p>Call context </p>
<p>&gt; </p>
<p>Must not be called within CAN Driver context like RX, TX or Bus Off callouts. </p>
<p>&gt; </p>
<p>This function is Non-Reentrant </p>
<p>&gt; </p>
<p>Availability: Always </p>
<p>Table 7-12  </p>
<p>Can_SetControllerMode </p>
<p> </p>
<p><b>7.2.12 </b></p>
<p><b>Can_ResetBusOffStart </b></p>
<p><b>Prototype </b></p>
<p>void <b>Can_ResetBusOffStart </b>(uint8 Controller) </p>
<p><b>Parameter </b></p>
<p>Controller [in] </p>
<p>Number of the controller </p>
<p><b>Return code </b></p>
<p>void </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>This is a compatibility function (for a CANbedded protocol stack) used during the start of the  </p>
<p>Bus Off handling to remove the Bus Off state.  </p>
<p><b>Particularities and Limitations </b></p>
<p>Called by CAN Driver. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference    MICROSAR CAN Driver </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 3.00.01 </p>
<p>55 </p>
<p> </p>
<p><b>Caution</b> </p>
<p>None AUTOSAR API </p>
<p>Call context </p>
<p>&gt; </p>
<p>Called while BusOff event handling (Polling or Interrupt context). </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Non-Reentrant </p>
<p>&gt; </p>
<p>Availability: Always </p>
<p>Table 7-13  </p>
<p>Can_ResetBusOffStart </p>
<p> </p>
<p><b>7.2.13 </b></p>
<p><b>Can_ResetBusOffEnd </b></p>
<p><b>Prototype </b></p>
<p>void <b>Can_ResetBusOffEnd </b>(uint8 Controller) </p>
<p><b>Parameter </b></p>
<p>Controller [in] </p>
<p>Number of the controller </p>
<p><b>Return code </b></p>
<p>void </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>This is a compatibility function (for a CANbedded protocol stack) used during the end of the  </p>
<p>Bus Off handling to remove the Bus Off state.  </p>
<p><b>Particularities and Limitations </b></p>
<p>Called by CAN Driver. </p>
<p> </p>
<p><b>Caution</b> </p>
<p>None AUTOSAR API </p>
<p>Call context </p>
<p>&gt; </p>
<p>Called inside &quot;Can_SetControllerMode()&quot; while Start transition. </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Non-Reentrant </p>
<p>&gt; </p>
<p>Availability: Always </p>
<p>Table 7-14  </p>
<p>Can_ResetBusOffEnd </p>
<p> </p>
<p><b>7.2.14 </b></p>
<p><b>Can_Write </b></p>
<p><b>Prototype </b></p>
<p>Can_ReturnType <b>Can_Write </b>(Can_HwHandleType Hth, Can_PduInfoPtrType PduInfo) </p>
<p><b>Parameter </b></p>
<p>Hth [in] </p>
<p>Handle of the mailbox intended to send the message </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference    MICROSAR CAN Driver </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 3.00.01 </p>
<p>56 </p>
<p>PduInfo [in] </p>
<p>Information about the outgoing message (ID, dataLength, data) </p>
<p><b>Return code </b></p>
<p>Can_ReturnType </p>
<p>&gt; </p>
<p>CAN_NOT_OK transmit unsuccessful  </p>
<p>&gt; </p>
<p>CAN_OK transmit successful  </p>
<p>&gt; </p>
<p>CAN_BUSY transmit could not be accomplished due to the controller is </p>
<p>busy. </p>
<p><b>Functional Description </b></p>
<p>Send a CAN message over CAN.  </p>
<p><b>Particularities and Limitations </b></p>
<p>Called by CanInterface. </p>
<p>CAN Interrupt locked.  </p>
<p>Call context </p>
<p>&gt; </p>
<p>Called by the CanInterface with at least disabled CAN interrupts.  </p>
<p>&gt; </p>
<p>(Due to data security reasons the CanInterface has to accomplish this and thus it is not needed a further </p>
<p>more in the CAN Driver.) </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Non-Reentrant </p>
<p>&gt; </p>
<p>Availability: Always </p>
<p>Table 7-15  </p>
<p>Can_Write </p>
<p> </p>
<p><b>7.2.15 </b></p>
<p><b>Can_CancelTx </b></p>
<p><b>Prototype </b></p>
<p>void <b>Can_CancelTx </b>(Can_HwHandleType Hth, PduIdType PduId) </p>
<p><b>Parameter </b></p>
<p>Hth [in] </p>
<p>Handle of the mailbox intended to be cancelled. </p>
<p>PduId [in] </p>
<p>Pdu identifier </p>
<p><b>Return code </b></p>
<p>void </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>Cancel the TX message in the hardware buffer (if possible) or mark the message as not to be confirmed  </p>
<p>in case of the cancellation is unsuccessful.  </p>
<p><b>Particularities and Limitations </b></p>
<p>Called by CanTp or Application. </p>
<p> </p>
<p><b>Caution</b> </p>
<p>None AUTOSAR API </p>
<p>Call context </p>
<p>&gt; </p>
<p>Called by CanTp or Application. </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference    MICROSAR CAN Driver </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 3.00.01 </p>
<p>57 </p>
<p>&gt; </p>
<p>This function is Non-Reentrant </p>
<p>&gt; </p>
<p>Availability: Always </p>
<p>Table 7-16  </p>
<p>Can_CancelTx </p>
<p> </p>
<p><b>7.2.16 </b></p>
<p><b>Can_SetMirrorMode </b></p>
<p><b>Prototype </b></p>
<p>void <b>Can_SetMirrorMode </b>(uint8 Controller, CddMirror_MirrorModeType mirrorMode) </p>
<p><b>Parameter </b></p>
<p>Controller [in] </p>
<p>CAN controller </p>
<p>mirrorMode [in] </p>
<p>Activate or deactivate the mirror mode. </p>
<p><b>Return code </b></p>
<p>void </p>
<p>none </p>
<p><b>Functional Description </b></p>
<p>Activate mirror mode. </p>
<p>Switch the Appl_GenericPreCopy/Confirmation function ON or OFF. </p>
<p><b>Particularities and Limitations </b></p>
<p>Configuration Variant(s): C_ENABLE_MIRROR_MODE (user configuration file)  Called by &quot;Mirror Mode&quot; </p>
<p>CDD. </p>
<p>None AUTOSAR API </p>
<p>Call context </p>
<p>&gt; </p>
<p>ANY </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Non-Reentrant </p>
<p>Table 7-17  </p>
<p>Can_SetMirrorMode </p>
<p> </p>
<p><b>7.2.17 </b></p>
<p><b>Can_SetSilentMode </b></p>
<p><b>Prototype </b></p>
<p>Std_ReturnType <b>Can_SetSilentMode </b>(uint8 Controller, Can_SilentModeType </p>
<p>silentMode) </p>
<p><b>Parameter </b></p>
<p>Controller [in] </p>
<p>CAN controller </p>
<p>silentMode [in] </p>
<p>Activate or deactivate the silent mode with CAN_SILENT_ACTIVE, </p>
<p>CAN_SILENT_INACTIVE (Enumeration) </p>
<p><b>Return code </b></p>
<p>Std_ReturnType </p>
<p>E_OK mode change successful. </p>
<p>Std_ReturnType </p>
<p>E_NOT_OK mode change failed. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference    MICROSAR CAN Driver </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 3.00.01 </p>
<p>58 </p>
<p><b>Functional Description </b></p>
<p>Activate or deactivate the Silent Mode. </p>
<p>Switch to Silent Mode, as a listen only mode without ACK, and deactivate this mode again for regular </p>
<p>communication. </p>
<p><b>Particularities and Limitations </b></p>
<p>The CAN controller must be in Stop Mode. </p>
<p>Configuration Variant(s): CAN_SILENT_MODE == STD_ON </p>
<p>Call context </p>
<p>&gt; </p>
<p>TASK </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Non-Reentrant </p>
<p>Table 7-18  </p>
<p>Can_SetSilentMode </p>
<p> </p>
<p><b>7.2.18 </b></p>
<p><b>Can_CheckWakeup </b></p>
<p><b>Prototype </b></p>
<p>Std_ReturnType <b>Can_CheckWakeup </b>(uint8 Controller) </p>
<p><b>Parameter </b></p>
<p>Controller [in] </p>
<p>Number of the controller to be checked for Wake Up events. </p>
<p><b>Return code </b></p>
<p>Std_ReturnType </p>
<p>&gt; </p>
<p>E_OK the given controller caused a Wake Up before.  </p>
<p>&gt; </p>
<p>E_NOT_OK the given controller caused no Wake Up before. </p>
<p><b>Functional Description </b></p>
<p>Service function to check the occurrence of Wake Up events for the given controller  </p>
<p>(used as Wake Up callback for higher layers).  </p>
<p><b>Particularities and Limitations </b></p>
<p>Called by CanInterface. </p>
<p>Call context </p>
<p>&gt; </p>
<p>Called while Wakeup validation phase. </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Non-Reentrant </p>
<p>&gt; </p>
<p>Availability: In AR4.x named &quot;Can_CheckWakeup&quot;, in AR3.x named &quot;Can_Cbk_CheckWakeup&quot; (Name </p>
<p>mapped by define) </p>
<p>Table 7-19  </p>
<p>Can_CheckWakeup </p>
<p> </p>
<p><b>7.2.19 </b></p>
<p><b>Can_DisableControllerInterrupts </b></p>
<p><b>Prototype </b></p>
<p>void <b>Can_DisableControllerInterrupts </b>(uint8 Controller) </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference    MICROSAR CAN Driver </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 3.00.01 </p>
<p>59 </p>
<p><b>Parameter </b></p>
<p>Controller [in] </p>
<p>Number of the CAN controller to disable interrupts for. </p>
<p><b>Return code </b></p>
<p>void </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>Service function to disable the CAN interrupt for the given controller (e.g. due to data security reasons).  </p>
<p><b>Particularities and Limitations </b></p>
<p>Called by SchM. </p>
<p>Must not be called while CAN controller is in Sleep Mode.  </p>
<p>Call context </p>
<p>&gt; </p>
<p>Called within Critical Area handling or out of Application code. </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Non-Reentrant </p>
<p>&gt; </p>
<p>Availability: Always </p>
<p>Table 7-20  </p>
<p>Can_DisableControllerInterrupts </p>
<p> </p>
<p><b>7.2.20 </b></p>
<p><b>Can_EnableControllerInterrupts </b></p>
<p><b>Prototype </b></p>
<p>void <b>Can_EnableControllerInterrupts </b>(uint8 Controller) </p>
<p><b>Parameter </b></p>
<p>Controller [in] </p>
<p>Number of the CAN controller to disable interrupts for. </p>
<p><b>Return code </b></p>
<p>void </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>Service function to (re-)enable the CAN interrupt for the given controller (e.g. due to data security reasons).  </p>
<p><b>Particularities and Limitations </b></p>
<p>Called by SchM. </p>
<p>Must not be called while CAN controller is in Sleep Mode.  </p>
<p>Call context </p>
<p>&gt; </p>
<p>Called within Critical Area handling or out of Application code. </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Non-Reentrant </p>
<p>&gt; </p>
<p>Availability: Always </p>
<p>Table 7-21  </p>
<p>Can_EnableControllerInterrupts </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference    MICROSAR CAN Driver </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 3.00.01 </p>
<p>60 </p>
<p><b>7.2.21 </b></p>
<p><b>Can_MainFunction_Write </b></p>
<p><b>Prototype </b></p>
<p>void <b>Can_MainFunction_Write </b>(void) </p>
<p><b>Parameter </b></p>
<p>-  </p>
<p> </p>
<p><b>Return code </b></p>
<p>void </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>Service function to poll TX events (confirmation, cancellation) for all controllers and all TX mailboxes  </p>
<p>to accomplish the TX confirmation handling (like CanInterface notification).  </p>
<p><b>Particularities and Limitations </b></p>
<p>Called by SchM. </p>
<p>Must not interrupt the call of &quot;Can_Write()&quot;. </p>
<p>Call context </p>
<p>&gt; </p>
<p>Called within cyclic TX task. </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Non-Reentrant </p>
<p>&gt; </p>
<p>Availability: Always </p>
<p>Table 7-22  </p>
<p>Can_MainFunction_Write </p>
<p> </p>
<p><b>7.2.22 </b></p>
<p><b>Can_MainFunction_Read </b></p>
<p><b>Prototype </b></p>
<p>void <b>Can_MainFunction_Read </b>(void) </p>
<p><b>Parameter </b></p>
<p>-  </p>
<p> </p>
<p><b>Return code </b></p>
<p>void </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>Service function to poll RX events for all controllers and all RX mailboxes to accomplish the  </p>
<p>RX indication handling (like CanInterface notification).  </p>
<p>Also used for a delayed read (from task level) of the RX Queue messages which were queued from </p>
<p>interrupt context.  </p>
<p><b>Particularities and Limitations </b></p>
<p>Called by SchM. </p>
<p>Call context </p>
<p>&gt; </p>
<p>Called within cyclic RX task. </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference    MICROSAR CAN Driver </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 3.00.01 </p>
<p>61 </p>
<p>&gt; </p>
<p>This function is Non-Reentrant </p>
<p>&gt; </p>
<p>Availability: Always </p>
<p>Table 7-23  </p>
<p>Can_MainFunction_Read </p>
<p> </p>
<p><b>7.2.23 </b></p>
<p><b>Can_MainFunction_BusOff </b></p>
<p><b>Prototype </b></p>
<p>void <b>Can_MainFunction_BusOff </b>(void) </p>
<p><b>Parameter </b></p>
<p>-  </p>
<p> </p>
<p><b>Return code </b></p>
<p>void </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>Polling of Bus Off events to accomplish the Bus Off handling. Service function to poll Bus Off events for all </p>
<p>controllers to accomplish the Bus Off handling  </p>
<p>(like calling of &quot;CanIf_ControllerBusOff()&quot; in case of Bus Off occurrence).  </p>
<p><b>Particularities and Limitations </b></p>
<p>Called by SchM. </p>
<p>Call context </p>
<p>&gt; </p>
<p>Called within cyclic BusOff task. </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Non-Reentrant </p>
<p>&gt; </p>
<p>Availability: Always </p>
<p>Table 7-24  </p>
<p>Can_MainFunction_BusOff </p>
<p> </p>
<p><b>7.2.24 </b></p>
<p><b>Can_MainFunction_Wakeup </b></p>
<p><b>Prototype </b></p>
<p>void <b>Can_MainFunction_Wakeup </b>(void) </p>
<p><b>Parameter </b></p>
<p>-  </p>
<p> </p>
<p><b>Return code </b></p>
<p>void </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>Service function to poll Wake Up events for all controllers to accomplish the Wake Up handling  </p>
<p>(like calling of &quot;CanIf_SetWakeupEvent()&quot; in case of Wake Up occurrence).  </p>
<p><b>Particularities and Limitations </b></p>
<p>Called by SchM. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference    MICROSAR CAN Driver </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 3.00.01 </p>
<p>62 </p>
<p>Call context </p>
<p>&gt; </p>
<p>Called within cyclic Wakeup task. </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Non-Reentrant </p>
<p>&gt; </p>
<p>Availability: Always </p>
<p>Table 7-25  </p>
<p>Can_MainFunction_Wakeup </p>
<p> </p>
<p><b>7.2.25 </b></p>
<p><b>Can_MainFunction_Mode </b></p>
<p><b>Prototype </b></p>
<p>void <b>Can_MainFunction_Mode </b>(void) </p>
<p><b>Parameter </b></p>
<p>-  </p>
<p> </p>
<p><b>Return code </b></p>
<p>void </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>Service function to poll Mode changes over all controllers.  </p>
<p>(This is handled asynchronous if not accomplished in &quot;Can_SetControllerMode()&quot;). </p>
<p><b>Particularities and Limitations </b></p>
<p>Called by SchM. </p>
<p>Call context </p>
<p>&gt; </p>
<p>Called within cyclic mode change task. </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Non-Reentrant </p>
<p>&gt; </p>
<p>Availability: MICROSAR4x only </p>
<p>Table 7-26  </p>
<p>Can_MainFunction_Mode </p>
<p> </p>
<p><b>7.2.26 </b></p>
<p><b>Can_RamCheckExecute </b></p>
<p><b>Prototype </b></p>
<p>void <b>Can_RamCheckExecute </b>(uint8 Controller) </p>
<p><b>Parameter </b></p>
<p>Controller [in] </p>
<p>CAN controller to be checked. </p>
<p><b>Return code </b></p>
<p>void </p>
<p>none </p>
<p><b>Functional Description </b></p>
<p>Check the MCAN Message RAM. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference    MICROSAR CAN Driver </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 3.00.01 </p>
<p>63 </p>
<p>Check all controller specific and mailbox specific registers by write patterns and read back. Issue </p>
<p>notification will appear in this context. </p>
<p><b>Particularities and Limitations </b></p>
<p>Has to be called within STOP Mode. </p>
<p>Configuration Variant(s): CAN_RAM_CHECK == CAN_EXTENDED  CREQ-106641 </p>
<p>Call context </p>
<p>&gt; </p>
<p>TASK </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Non-Reentrant </p>
<p>Table 7-27  </p>
<p>Can_RamCheckExecute </p>
<p> </p>
<p><b>7.2.27 </b></p>
<p><b>Can_RamCheckEnableMailbox </b></p>
<p><b>Prototype </b></p>
<p>void <b>Can_RamCheckEnableMailbox </b>(Can_HwHandleType htrh) </p>
<p><b>Parameter </b></p>
<p>htrh [in] </p>
<p>CAN mailbox to be reactivated. </p>
<p><b>Return code </b></p>
<p>void </p>
<p>none </p>
<p><b>Functional Description </b></p>
<p>Reactivate a mailbox after RamCheck failed. </p>
<p>Mailbox will be reactivated by clearing the deactivation flag (see also [7]). </p>
<p><b>Particularities and Limitations </b></p>
<p>Has to be called within STOP Mode after RamCheck failed (controller is deactivated).  </p>
<p>Must be followed by Can_RamCheckEnableController() to activate mailbox and controller. </p>
<p>Configuration Variant(s): CAN_RAM_CHECK == CAN_EXTENDED   </p>
<p>CREQ-106641 </p>
<p>Call context </p>
<p>&gt; </p>
<p>TASK </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Non-Reentrant </p>
<p>Table 7-28  </p>
<p>Can_RamCheckEnableMailbox </p>
<p> </p>
<p><b>7.2.28 </b></p>
<p><b>Can_RamCheckEnableController </b></p>
<p><b>Prototype </b></p>
<p>void <b>Can_RamCheckEnableController </b>(uint8 Controller) </p>
<p><b>Parameter </b></p>
<p>Controller [in] </p>
<p>CAN controller to be reactivated. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference    MICROSAR CAN Driver </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 3.00.01 </p>
<p>64 </p>
<p><b>Return code </b></p>
<p>void </p>
<p>none </p>
<p><b>Functional Description </b></p>
<p>Reactivate CAN cells after RamCheck failed. </p>
<p>CAN cell will be reactivated by execute reinitialization. </p>
<p><b>Particularities and Limitations </b></p>
<p>Has to be called within STOP Mode after RamCheck failed (controller is deactivated). </p>
<p>Configuration Variant(s): CAN_RAM_CHECK == CAN_EXTENDED   </p>
<p>CREQ-106641 </p>
<p>Call context </p>
<p>&gt; </p>
<p>TASK </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Non-Reentrant </p>
<p>Table 7-29  </p>
<p>Can_RamCheckEnableController </p>
<p> </p>
<p><b>7.2.29 </b></p>
<p><b>Appl_GenericPrecopy </b></p>
<p><b>Prototype </b></p>
<p>Can_ReturnType <b>Appl_GenericPrecopy </b>(uint8 Controller, Can_IdType ID, uint8 </p>
<p>DataLength, Can_DataPtrType DataPtr) </p>
<p><b>Parameter </b></p>
<p>Controller [in] </p>
<p>Controller which received the message </p>
<p>ID [in] </p>
<p>ID of the received message (include IDE,FD).  </p>
<p>In case of extended or mixed ID systems the highest bit (bit 31) is set to mark </p>
<p>an extended ID.  </p>
<p>FD-bit (bit 30) can be masked out with user define </p>
<p>CAN_ID_MASK_IN_GENERIC_CALLOUT. </p>
<p>DataLength [in] </p>
<p>Data length of the received message (read only). </p>
<p>pData [in] </p>
<p>Pointer to the data of the received message. </p>
<p><b>Return code </b></p>
<p>Can_ReturnType </p>
<p>&gt; </p>
<p>CAN_OK Higher layer indication will be called afterwards </p>
<p>(CanIf_RxIndication()). </p>
<p>&gt; </p>
<p>CAN_NOT_OK Higher layer indication will not be called afterwards. </p>
<p><b>Functional Description </b></p>
<p>Application callback function which informs about all incoming RX messages including the contained data. </p>
<p>It can be used to block notification to upper layer. E.g. to filter incoming messages or route it for special </p>
<p>handling.  </p>
<p><b>Particularities and Limitations </b></p>
<p>Called by CAN Driver. </p>
<p>&quot;pData&quot; is read only and must not be accessed for further write operations. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference    MICROSAR CAN Driver </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 3.00.01 </p>
<p>65 </p>
<p>The parameter DataLength refers to the received data length by the CAN controller hardware. </p>
<p>Note, that the CAN protocol allows the usage of data length values greater than eight (CAN-FD).  </p>
<p>Depending on the implementation of this callback it may be necessary to consider this special case (e.g. if </p>
<p>the data length is used as index value in a buffer write access). </p>
<p> </p>
<p><b>Caution</b> </p>
<p>None AUTOSAR API </p>
<p>Call context </p>
<p>&gt; </p>
<p>Called within CAN message reception context (Polling or Interrupt). </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Non-Reentrant </p>
<p>&gt; </p>
<p>Availability: &quot;CanGenericPrecopy&quot; is activated (&quot;CAN_GENERIC_PRECOPY == STD_ON&quot;). </p>
<p>Table 7-30  </p>
<p>Appl_GenericPrecopy </p>
<p> </p>
<p><b>7.2.30 </b></p>
<p><b>Appl_GenericConfirmation </b></p>
<p><b>Prototype </b></p>
<p>Can_ReturnType <b>Appl_GenericConfirmation </b>(PduIdType PduId) </p>
<p><b>Parameter </b></p>
<p>PduId [in] </p>
<p>Handle of the PDU specifying the message. </p>
<p><b>Return code </b></p>
<p>Can_ReturnType </p>
<p>&gt; </p>
<p>CAN_OK Higher layer confirmation will be called afterwards </p>
<p>(CanIf_TxConfirmation()).  </p>
<p>&gt; </p>
<p>CAN_NOT_OK Higher layer confirmation will not be called afterwards. </p>
<p><b>Functional Description </b></p>
<p>Application callback function which informs about TX messages being sent to the CAN bus.  </p>
<p><b>Particularities and Limitations </b></p>
<p>Called by CAN Driver. </p>
<p>&quot;PduId&quot; is read only and must not be accessed for further write operations.  </p>
<p> </p>
<p><b>Caution</b> </p>
<p>None AUTOSAR API </p>
<p>Call context </p>
<p>&gt; </p>
<p>Called within CAN message transmission finished context (Polling or Interrupt). </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Non-Reentrant </p>
<p>&gt; </p>
<p>Availability: &quot;CanGenericConfirmation&quot; is activated (&quot;CAN_GENERIC_CONFIRMATION == STD_ON&quot;) &amp; </p>
<p>&quot;CanIfTransmitBuffer&quot; activated (in CanInterface). </p>
<p>Table 7-31  </p>
<p>Appl_GenericConfirmation </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference    MICROSAR CAN Driver </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 3.00.01 </p>
<p>66 </p>
<p><b>7.2.31 </b></p>
<p><b>Appl_GenericConfirmation </b></p>
<p><b>Prototype </b></p>
<p>Can_ReturnType <b>Appl_GenericConfirmation </b>(uint8 Controller, Can_PduInfoPtrType </p>
<p>DataPtr) </p>
<p><b>Parameter </b></p>
<p>Controller [in] </p>
<p>CAN controller which send the message. </p>
<p>DataPtr [in] </p>
<p>Pointer to a Can_PduType structure including ID (include IDE,FD), </p>
<p>DataLength, PDU and data pointer. </p>
<p><b>Return code </b></p>
<p>Can_ReturnType </p>
<p>CAN_OK Higher layer (CanInterface) confirmation will be called. </p>
<p>CAN_NOT_OK No further higher layer (CanInterface) confirmation will be </p>
<p>called. </p>
<p><b>Functional Description </b></p>
<p>Application callback function which informs about TX messages being sent to the CAN bus. </p>
<p>It can be used to block confirmation or route the information to other layers as well. </p>
<p><b>Particularities and Limitations </b></p>
<p>Called by CAN Driver. </p>
<p>A new transmission within this call out will corrupt the DataPtr context. </p>
<p>If &quot;Generic Confirmation&quot; and &quot;Transmit Buffer&quot; (both set in CanInterface) are active, then the switch  </p>
<p>&quot;Cancel Support Api&quot; is also needed (also set in CanIf), otherwise a compiler error occurs.  </p>
<p> </p>
<p><b>Caution</b> </p>
<p>None AUTOSAR API </p>
<p>Call context </p>
<p>&gt; </p>
<p>Called within CAN message transmission finished context (Polling or Interrupt). </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Non-Reentrant </p>
<p>&gt; </p>
<p>Availability: &quot;CanGenericConfirmation&quot; is set to API2 (&quot;CAN_GENERIC_CONFIRMATION == </p>
<p>CAN_API2&quot;). </p>
<p>Table 7-32  </p>
<p>Appl_GenericConfirmation </p>
<p> </p>
<p><b>7.2.32 </b></p>
<p><b>Appl_GenericPreTransmit </b></p>
<p><b>Prototype </b></p>
<p>void <b>Appl_GenericPreTransmit </b>(uint8 Controller, Can_PduInfoPtrType_var DataPtr) </p>
<p><b>Parameter </b></p>
<p>Controller [in] </p>
<p>CAN controller on which the message will be send. </p>
<p>DataPtr [in] </p>
<p>Pointer to a Can_PduType structure including ID (include IDE,FD), </p>
<p>DataLength, PDU and data pointer. </p>
<p><b>Return code </b></p>
<p>void </p>
<p>- </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference    MICROSAR CAN Driver </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 3.00.01 </p>
<p>67 </p>
<p><b>Functional Description </b></p>
<p>Application callback function allowing the modification of the data to be transmitted (e.g.: add CRC).  </p>
<p><b>Particularities and Limitations </b></p>
<p>Called by CAN Driver. </p>
<p> </p>
<p><b>Caution</b> </p>
<p>None AUTOSAR API </p>
<p>Call context </p>
<p>&gt; </p>
<p>Called within &quot;Can_Write()&quot;. </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Non-Reentrant </p>
<p>&gt; </p>
<p>Availability: &quot;CanGenericPretransmit&quot; is activated (&quot;CAN_GENERIC_PRETRANSMIT == STD_ON&quot;). </p>
<p>Table 7-33  </p>
<p>Appl_GenericPreTransmit </p>
<p> </p>
<p><b>7.2.33 </b></p>
<p><b>ApplCanTimerStart </b></p>
<p><b>Prototype </b></p>
<p>void <b>ApplCanTimerStart </b>(CanChannelHandle Controller, uint8 source) </p>
<p><b>Parameter </b></p>
<p>Controller [in] </p>
<p>Number of the controller on which the hardware observation takes place.  </p>
<p>(only if not using &quot;Optimize for one controller&quot;) </p>
<p>source [in] </p>
<p>Source for the hardware observation (see chapter Hardware Loop Check / </p>
<p>Timeout Monitoring). </p>
<p><b>Return code </b></p>
<p>void </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>Service function to start an observation timer (see chapter Hardware Loop Check / Timeout Monitoring).  </p>
<p><b>Particularities and Limitations </b></p>
<p>Called by CAN Driver. </p>
<p> </p>
<p><b>Caution</b> </p>
<p>None AUTOSAR API </p>
<p>Call context </p>
<p>&gt; </p>
<p>For context information please refer to chapter &quot;Hardware Loop Check&quot;. </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Non-Reentrant </p>
<p>&gt; </p>
<p>Availability: &quot;CanHardwareCancelByAppl&quot; is activated (&quot;CAN_HW_LOOP_SUPPORT_API == </p>
<p>STD_ON&quot;). </p>
<p>Table 7-34  </p>
<p>ApplCanTimerStart </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference    MICROSAR CAN Driver </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 3.00.01 </p>
<p>68 </p>
<p><b>7.2.34 </b></p>
<p><b>ApplCanTimerLoop </b></p>
<p><b>Prototype </b></p>
<p>Can_ReturnType <b>ApplCanTimerLoop </b>(CanChannelHandle Controller, uint8 source) </p>
<p><b>Parameter </b></p>
<p>Controller [in] </p>
<p>Number of the controller on which the hardware observation takes place.  </p>
<p>(only if not using &quot;Optimize for one controller&quot;) </p>
<p>source [in] </p>
<p>Source for the hardware observation (see chapter Hardware Loop Check / </p>
<p>Timeout Monitoring). </p>
<p><b>Return code </b></p>
<p>Can_ReturnType </p>
<p>&gt; </p>
<p>CAN_NOT_OK when loop shall be broken (observation stops)  </p>
<p>&gt; </p>
<p>CAN_NOT_OK should only be used in case of a timeout occurs due to a </p>
<p>hardware issue.  </p>
<p>&gt; </p>
<p>After this an appropriate error handling is needed (see chapter Hardware </p>
<p>Loop Check / Timeout Monitoring).  </p>
<p>&gt; </p>
<p>CAN_OK when loop shall be continued (observation continues) </p>
<p><b>Functional Description </b></p>
<p>Service function to check (against generated max loop value) whether a hardware loop shall be continued </p>
<p>or broken.  </p>
<p><b>Particularities and Limitations </b></p>
<p>Called by CAN Driver. </p>
<p> </p>
<p><b>Caution</b> </p>
<p>None AUTOSAR API </p>
<p>Call context </p>
<p>&gt; </p>
<p>For context information please refer to chapter &quot;Hardware Loop Check&quot;. </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Non-Reentrant </p>
<p>&gt; </p>
<p>Availability: &quot;CanHardwareCancelByAppl&quot; is activated (&quot;CAN_HW_LOOP_SUPPORT_API == </p>
<p>STD_ON&quot;). </p>
<p>Table 7-35  </p>
<p>ApplCanTimerLoop </p>
<p> </p>
<p><b>7.2.35 </b></p>
<p><b>ApplCanTimerEnd </b></p>
<p><b>Prototype </b></p>
<p>void <b>ApplCanTimerEnd </b>(CanChannelHandle Controller, uint8 source) </p>
<p><b>Parameter </b></p>
<p>Controller [in] </p>
<p>Number of the controller on which the hardware observation takes place.  </p>
<p>(only if not using &quot;Optimize for one controller&quot;) </p>
<p>source [in] </p>
<p>Source for the hardware observation (see chapter Hardware Loop Check / </p>
<p>Timeout Monitoring). </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference    MICROSAR CAN Driver </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 3.00.01 </p>
<p>69 </p>
<p><b>Return code </b></p>
<p>void </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>Service function to to end an observation timer (see chapter Hardware Loop Check / Timeout Monitoring).  </p>
<p><b>Particularities and Limitations </b></p>
<p>Called by CAN Driver. </p>
<p> </p>
<p><b>Caution</b> </p>
<p>None AUTOSAR API </p>
<p>Call context </p>
<p>&gt; </p>
<p>For context information please refer to chapter &quot;Hardware Loop Check&quot;. </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Non-Reentrant </p>
<p>&gt; </p>
<p>Availability: &quot;CanHardwareCancelByAppl&quot; is activated (&quot;CAN_HW_LOOP_SUPPORT_API == </p>
<p>STD_ON&quot;). </p>
<p>Table 7-36  </p>
<p>ApplCanTimerEnd </p>
<p> </p>
<p><b>7.2.36 </b></p>
<p><b>ApplCanInterruptDisable </b></p>
<p><b>Prototype </b></p>
<p>void <b>ApplCanInterruptDisable </b>(uint8 Controller) </p>
<p><b>Parameter </b></p>
<p>Controller [in] </p>
<p>Number of the controller for the CAN interrupt lock. </p>
<p><b>Return code </b></p>
<p>void </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>Service function to support the disabling of CAN Interrupts by the application.  </p>
<p>E.g.: the CAN Driver itself should not access the common Interrupt Controller due to application  </p>
<p>specific restrictions (like security level etc.). Or the application like to be informed because of  </p>
<p>an CAN interrupt lock.  </p>
<p><b>Particularities and Limitations </b></p>
<p>Called by CAN Driver. </p>
<p> </p>
<p><b>Caution</b> </p>
<p>None AUTOSAR API </p>
<p>Call context </p>
<p>&gt; </p>
<p>Called by the CAN Driver within &quot;Can_DisableControllerInterrupts()&quot;. </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Non-Reentrant </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference    MICROSAR CAN Driver </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 3.00.01 </p>
<p>70 </p>
<p>&gt; </p>
<p>Availability: &quot;CanInterruptLock&quot; is set to APPL or BOTH (&quot;CAN_INTLOCK == CAN_APPL&quot; or </p>
<p>&quot;CAN_INTLOCK == CAN_BOTH&quot;). </p>
<p>Table 7-37  </p>
<p>ApplCanInterruptDisable </p>
<p> </p>
<p><b>7.2.37 </b></p>
<p><b>ApplCanInterruptRestore </b></p>
<p><b>Prototype </b></p>
<p>void <b>ApplCanInterruptRestore </b>(uint8 Controller) </p>
<p><b>Parameter </b></p>
<p>Controller [in] </p>
<p>Number of the controller for the CAN interrupt unlock. </p>
<p><b>Return code </b></p>
<p>void </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>Service function to support the enabling of CAN Interrupts by the application.  </p>
<p>E.g.: the CAN Driver itself should not access the common Interrupt Controller due to application  </p>
<p>specific restrictions (like security level etc.). Or the application like to be informed because of  </p>
<p>an CAN interrupt lock.  </p>
<p><b>Particularities and Limitations </b></p>
<p>Called by CAN Driver. </p>
<p> </p>
<p><b>Caution</b> </p>
<p>None AUTOSAR API </p>
<p>Call context </p>
<p>&gt; </p>
<p>Called by the CAN Driver within &quot;Can_EnableControllerInterrupts()&quot;. </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Non-Reentrant </p>
<p>&gt; </p>
<p>Availability: &quot;CanInterruptLock&quot; is set to APPL or BOTH (&quot;CAN_INTLOCK == CAN_APPL&quot; or </p>
<p>&quot;CAN_INTLOCK == CAN_BOTH&quot;). </p>
<p>Table 7-38  </p>
<p>ApplCanInterruptRestore </p>
<p> </p>
<p><b>7.2.38 </b></p>
<p><b>Appl_CanOverrun </b></p>
<p><b>Prototype </b></p>
<p>void <b>Appl_CanOverrun </b>(uint8 Controller) </p>
<p><b>Parameter </b></p>
<p>Controller [in] </p>
<p>Number of the controller for which the overrun was detected. </p>
<p><b>Return code </b></p>
<p>void </p>
<p>- </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference    MICROSAR CAN Driver </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 3.00.01 </p>
<p>71 </p>
<p><b>Functional Description </b></p>
<p>This function will be called when an overrun is detected for a BasicCAN mailbox.  </p>
<p>Alternatively, a DET call can be selected instead of (&quot;CanOverrunNotification&quot; is set to &quot;DET&quot;). </p>
<p><b>Particularities and Limitations </b></p>
<p>Called by CAN Driver. </p>
<p> </p>
<p><b>Caution</b> </p>
<p>None AUTOSAR API </p>
<p>Call context </p>
<p>&gt; </p>
<p>Called within CAN message reception or error detection context (Polling or Interrupt). </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Non-Reentrant </p>
<p>&gt; </p>
<p>Availability: &quot;CanOverrunNotification&quot; set to APPL (&quot;CAN_OVERRUN_NOTIFICATION == CAN_APPL&quot;). </p>
<p>Table 7-39  </p>
<p>Appl_CanOverrun </p>
<p> </p>
<p><b>7.2.39 </b></p>
<p><b>Appl_CanFullCanOverrun </b></p>
<p><b>Prototype </b></p>
<p>void <b>Appl_CanFullCanOverrun </b>(uint8 Controller) </p>
<p><b>Parameter </b></p>
<p>Controller [in] </p>
<p>Number of the controller for which the overrun was detected. </p>
<p><b>Return code </b></p>
<p>void </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>This function will be called when an overrun is detected for a FullCAN mailbox.  </p>
<p>Alternatively a DET call can be selected instead of (&quot;CanOverrunNotification&quot; is set to &quot;DET&quot;). </p>
<p><b>Particularities and Limitations </b></p>
<p>Called by CAN Driver. </p>
<p> </p>
<p><b>Caution</b> </p>
<p>None AUTOSAR API </p>
<p>Call context </p>
<p>&gt; </p>
<p>Called within CAN message reception or error detection context (Polling or Interrupt). </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Non-Reentrant </p>
<p>&gt; </p>
<p>Availability: &quot;CanOverrunNotification&quot; set to APPL (&quot;CAN_OVERRUN_NOTIFICATION == CAN_APPL&quot;). </p>
<p>Table 7-40  </p>
<p>Appl_CanFullCanOverrun </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference    MICROSAR CAN Driver </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 3.00.01 </p>
<p>72 </p>
<p><b>7.2.40 </b></p>
<p><b>Appl_CanCorruptMailbox </b></p>
<p><b>Prototype </b></p>
<p>void <b>Appl_CanCorruptMailbox </b>(uint8 Controller, Can_HwHandleType hwObjHandle) </p>
<p><b>Parameter </b></p>
<p>Controller [in] </p>
<p>Number of the controller for which the check failed. </p>
<p>hwObjHandle [in] </p>
<p>Hardware handle of the defect mailbox. </p>
<p><b>Return code </b></p>
<p>void </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>This function will notify the application (during &quot;Can_InitController()&quot;) about a defect mailbox within the CAN </p>
<p>cell.  </p>
<p><b>Particularities and Limitations </b></p>
<p>Called by CAN Driver. </p>
<p> </p>
<p><b>Caution</b> </p>
<p>None AUTOSAR API </p>
<p>Call context </p>
<p>&gt; </p>
<p>Call within controller initialization. </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Non-Reentrant </p>
<p>&gt; </p>
<p>Availability: &quot;CanRamCheck&quot; set to &quot;MailboxNotifiation&quot; (&quot;CAN_RAM_CHECK == </p>
<p>CAN_NOTIFY_MAILBOX&quot;). </p>
<p>Table 7-41  </p>
<p>Appl_CanCorruptMailbox </p>
<p> </p>
<p><b>7.2.41 </b></p>
<p><b>Appl_CanRamCheckFailed </b></p>
<p><b>Prototype </b></p>
<p>uint8 <b>Appl_CanRamCheckFailed </b>(uint8 Controller) </p>
<p><b>Parameter </b></p>
<p>Controller [in] </p>
<p>Number of the controller for which the check failed </p>
<p><b>Return code </b></p>
<p>uint8 </p>
<p>&gt; </p>
<p>action With this &quot;action&quot; the application can decide how to proceed with the </p>
<p>initialization.  </p>
<p>&gt; </p>
<p>CAN_DEACTIVATE_CONTROLLER - deactivate the controller  </p>
<p>&gt; </p>
<p>CAN_ACTIVATE_CONTROLLER - activate the controller </p>
<p><b>Functional Description </b></p>
<p>This function will notify the application (during &quot;Can_InitController()&quot;) about a defect CAN controller  </p>
<p>due to a previous failed mailbox check.  </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference    MICROSAR CAN Driver </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 3.00.01 </p>
<p>73 </p>
<p><b>Particularities and Limitations </b></p>
<p>Called by CAN Driver. </p>
<p> </p>
<p><b>Caution</b> </p>
<p>None AUTOSAR API </p>
<p>Call context </p>
<p>&gt; </p>
<p>Call within controller initialization. </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Non-Reentrant </p>
<p>&gt; </p>
<p>Availability: &quot;CanRamCheck&quot; set to &quot;Active&quot; or &quot;MailboxNotifiation&quot; (&quot;CAN_RAM_CHECK != </p>
<p>CAN_NONE&quot;). </p>
<p>Table 7-42  </p>
<p>Appl_CanRamCheckFailed </p>
<p> </p>
<p><b>7.2.42 </b></p>
<p><b>ApplCanInitPostProcessing </b></p>
<p><b>Prototype </b></p>
<p>void <b>ApplCanInitPostProcessing </b>(CAN_HW_CHANNEL_CANTYPE_ONLY) </p>
<p><b>Parameter </b></p>
<p>Controller [in] </p>
<p>Number of the controller for which the check failed </p>
<p><b>Return code </b></p>
<p>void </p>
<p>none </p>
<p><b>Functional Description </b></p>
<p>Service function to </p>
<p>a) overwrite the previously set initialization values for the bit timing, taken from the generated data, with </p>
<p>customer specific values: </p>
<p>  For your convenience, the following access macros are supported:  </p>
<p>  - <b>CanBtpReg</b>(controller):   the (N)BTP register of the specified CAN channel can be set according to the    </p>
<p>                                            register definition (see Hardware Manufacturer Document in ch. 2).  </p>
<p>        Example: CanBtpReg(Controller) = 0x00070F70u;  </p>
<p>                    or CanBtpReg(0) = 0x00070F70u; (when using 'Optimize for one controller').  </p>
<p>-  <b>CanCRelReg</b>(controller):   the CREL register of the specified CAN channel can be read according to the    </p>
<p>                                            register definition (see Hardware Manufacturer Document in ch. 2). </p>
<p>-  <b>CanGetMcanRevision</b>(controller):   the CREL register of the specified CAN channel is read and the </p>
<p>release information (Version, Step and Sub Step) is returned as a vuint16 type. </p>
<p> </p>
<p> </p>
<p>b) bypass or configure the CAN Calibration Unit (CCCU) where available: </p>
<p>    The CCCU is only available when using SPC58xx derivatives. Within this callback you are requested  </p>
<p>    toeither configure or bypass the CCCU. If so, you must assure by your configuration that the first CAN  </p>
<p>    channel being initialized is „MCAN_2“(Base Address 0xF7EE8000). </p>
<p>        Example (for SPC58EC80): </p>
<p>             </p>
<p>  // CCCR INIT and CCE bits aleady set by CAN Driver during  </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference    MICROSAR CAN Driver </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 3.00.01 </p>
<p>74 </p>
<p>            initialization </p>
<p>         CCCU.CCFG |= 0x00000040ul;   // CCFG.BCC = „1“ Bypass CCCU </p>
<p>         MCAN.CCCR &amp;= 0xFFFFFFFBul;   // CCCR.ASM = „0“ Reset Restricted Mode</p>
<p> </p>
<p><b>Particularities and Limitations </b></p>
<p>Called by CAN Driver at the end of the CAN Driver initialization. </p>
<p>none </p>
<p> </p>
<p><b>Caution</b> </p>
<p>None AUTOSAR API  </p>
<p>It is the responsibility of the application to assure that the register values are consistent with the </p>
<p>release of the underlying derivative. </p>
<p>Call context </p>
<p>&gt; </p>
<p>Called within controller initialization. </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Non-Reentrant </p>
<p>&gt; </p>
<p>Availability: Only available if 'C_ENABLE_INIT_POST_PROCESS' is defined via a user-config file. </p>
<p>Table 7-43  </p>
<p>ApplCanInitPostProcessing </p>
<p> </p>
<p><b>7.3 </b></p>
<p><b>Services used by CAN </b></p>
<p>In the following table services provided by other components, which are used by the CAN are </p>
<p>listed. For details about prototype and functionality refer to the documentation of the providing </p>
<p>component. </p>
<p><b>Component </b></p>
<p><b>API </b></p>
<p>DET </p>
<p><b>Det_ReportError </b></p>
<p>(see “Development Error Reporting”) </p>
<p>DEM </p>
<p><b>Dem_ReportErrorStatus </b></p>
<p>(see “Production Code Error Reporting”) </p>
<p>EcuM </p>
<p><b>EcuM_CheckWakeup </b></p>
<p>This function is called when Wakeup over CAN bus occur. </p>
<p><b>EcuM_GeneratorCompatibilityError </b></p>
<p>This function is called during the initialization, of the CAN Driver if </p>
<p>the Generator Version Check or the CRC Check fails. (see [5]) </p>
<p>Application (optional non AUTOSAR) </p>
<p><b>Appl_GenericPrecopy </b></p>
<p><b>Appl_GenericConfirmation </b></p>
<p><b>Appl_GenericPreTransmit </b></p>
<p><b>ApplCanTimerStart/Loop/End </b></p>
<p><b>Appl_CanRamCheckFailed, Appl_CanCorruptMailbox </b></p>
<p><b>ApplCanInterruptDisable/Restore </b></p>
<p><b>Appl_CanOverrun </b></p>
<p>For detailed description see Chapter 7.2 </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference    MICROSAR CAN Driver </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 3.00.01 </p>
<p>75 </p>
<p>CANIF </p>
<p><b>CanIf_CancelTxNotification </b>(non AUTOSAR) </p>
<p>A special Software cancellation callback only used within Vector </p>
<p>CAN Driver CAN Interface bundle. </p>
<p><b>CanIf_TxConfirmation </b></p>
<p>Notification for a successful transmission. (see [4]) </p>
<p><b>CanIf_CancelTxConfirmation </b></p>
<p>Notification for a successful Tx cancellation. (see [4]) </p>
<p><b>CanIf_RxIndication </b></p>
<p>Notification for a message reception. (see [4]) </p>
<p><b>CanIf_ControllerBusOff </b></p>
<p>Bus Off notification function. (see [4]) </p>
<p><b>CanIf_ControllerModeIndication </b></p>
<p>MICROSAR4x only: Notification for mode sucessfully changed. </p>
<p><b>CanIf_RamCheckCorruptMailbox </b></p>
<p>Notification if RAM check detects a corrupt mailbox. </p>
<p><b>CanIf_RamCheckCorruptController </b></p>
<p>Notification if RAM check detects a corrupt CAN channel. </p>
<p>Os (MICROSAR4x) </p>
<p><b>OS_TICKS2MS_&lt;counterShortName&gt;()</b></p>
<p> </p>
<p>Os macro to get timebased ticks from counter. </p>
<p><b>GetElapsedValue </b></p>
<p>Get elapsed tick count. </p>
<p><b>GetCounterValue </b></p>
<p>Get tick count start. </p>
<p> </p>
<p>Table 7-44  </p>
<p>Services used by the CAN </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference    MICROSAR CAN Driver </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 3.00.01 </p>
<p>76 </p>
<p><b>8 </b></p>
<p><b>Configuration </b></p>
<p>For CAN driver the attributes can be configured with configuration tool  “CFG5”. The CAN </p>
<p>Driver supports pre-compile, link-time and post-build configuration. For post-build systems, </p>
<p>re-flashing the generated data can change some configuration settings. For post-build and </p>
<p>link-time configurations pre-compile settings are configured at compile time and therefore </p>
<p>unchangeable at link or post-build time.  </p>
<p>The following parameters are set by  CFG5 configuration (see chapter “Configuration with </p>
<p>GENy”). </p>
<p><b>8.1 </b></p>
<p><b>Pre-Compile Parameters </b></p>
<p>Settings have to be available before compilation: </p>
<p><b>&gt; </b></p>
<p>Version API (Can_GetVersionInfo() activation) </p>
<p>#define CAN_VERSION_INFO_API        STD_ON/STD_OFF </p>
<p><b>&gt; </b></p>
<p>DET (development error detection) </p>
<p>#define CAN_DEV_ERROR_DETECT        STD_ON/STD_OFF </p>
<p><b>&gt; </b></p>
<p>Hardware Loop Check (timeout monitoring) </p>
<p>#define CAN_HARDWARE_CANCELLATION    STD_ON/STD_OFF </p>
<p><b>&gt; </b></p>
<p>Polling modes: Tx confirmation, Reception, Wakeup, BusOff </p>
<p>#define CAN_TX_PROCESSING  CAN_INTERRUPT/CAN_POLLING </p>
<p>#define  CAN_RX_PROCESSING CAN_INTERRUPT/CAN_POLLING </p>
<p>#define CAN_BUSOFF_PROCESSING CAN_INTERRUPT/CAN_POLLING </p>
<p>#define CAN_WAKEUP_PROCESSING CAN_INTERRUPT/CAN_POLLING  </p>
<p>#define CAN_INDIVIDUAL_PROCESSING    STD_ON/STD_OFF </p>
<p><b>&gt; </b></p>
<p>Multiplexed Tx (external PIA – by usage of multiple Tx mailboxes) </p>
<p>#define CAN_MULTIPLEXED_TRANSMISSION   STD_ON/STD_OFF</p>
<p> </p>
<p><b>&gt; </b></p>
<p>Configuration Variant (define the configuration type when using post build variant) </p>
<p>#define CAN_ENABLE_SELECTABLE_PB</p>
<p> </p>
<p><b>&gt; </b></p>
<p>Use Generic Precopy Function (None AUTOSAR feature) </p>
<p>#define CAN_GENERIC_PRECOPY          STD_ON/STD_OFF</p>
<p> </p>
<p><b>&gt; </b></p>
<p>Use Generic Confirmation Function (None AUTOSAR feature) </p>
<p>#define CAN_GENERIC_CONFIRMATION      STD_ON/STD_OFF </p>
<p><b>&gt; </b></p>
<p>Use Rx Queue Function (None AUTOSAR feature) </p>
<p>  </p>
<p>#define CAN_RX_QUEUE          STD_ON/ (not supported)         </p>
<p>                         STD_OFF </p>
<p><b>&gt; </b></p>
<p>Used ID type (standard/extended or mixed ID format) </p>
<p>#define CAN_EXTENDED_ID           STD_ON/STD_OFF </p>
<p>#define CAN_MIXED_ID              STD_ON/STD_OFF    </p>
<p><b>&gt; </b></p>
<p>Usage of Rx and Tx Full and BasicCAN objects (deactivate only when not using and </p>
<p>to save ROM and runtime consumption) </p>
<p>#define CAN_RX_FULLCAN_OBJECTS         STD_ON/STD_OFF </p>
<p>#define CAN_TX_FULLCAN_OBJECTS         STD_ON/STD_OFF </p>
<p>#define CAN_RX_BASICCAN_OBJECTS        STD_ON/STD_OFF </p>
<p><b>&gt; </b></p>
<p>Use Multiple BasicCAN objects </p>
<p>  </p>
<p>#define CAN_MULTIPLE_BASICCAN          STD_ON/STD_OFF </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference    MICROSAR CAN Driver </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 3.00.01 </p>
<p>77 </p>
<p><b>&gt; </b></p>
<p>Optimizations </p>
<p>#define CAN_ONE_CONTROLLER_OPTIMIZATION STD_ON/STD_OFF </p>
<p>#define CAN_DYNAMIC_FULLCAN_ID         STD_ON/STD_OFF </p>
<p><b>&gt; </b></p>
<p>Usage of nested CAN interrupts </p>
<p>  #define CAN_NESTED_INTERRUPTS          STD_ON/STD_OFF </p>
<p><b>&gt; </b></p>
<p>Use Multiple ECU configurations </p>
<p>   #define CAN_MULTI_ECU_CONFIG           STD_ON/STD_OFF </p>
<p><b>&gt; </b></p>
<p>Use RAM Check (verify mailbox buffers) </p>
<p>  </p>
<p>#define CAN_RAM_CHECK       CAN_NONE/ </p>
<p>                            CAN_NOTIFY_ISSUE/ </p>
<p>                            CAN_NOTIFY_MAILBOX </p>
<p><b>&gt; </b></p>
<p>Use Overrun detection </p>
<p> </p>
<p>#define CAN_OVERRUN_NOTIFICATION    CAN_NONE/ </p>
<p>CAN_DET/ </p>
<p>CAN_APPL </p>
<p><b>&gt; </b></p>
<p>Select MicroSar version </p>
<p> </p>
<p>#define CAN_MICROSAR_VERSION         CAN_MSR30/ </p>
<p>                                  CAN_MSR40 </p>
<p><b>&gt; </b></p>
<p>Tx Cancellation of Identical IDs </p>
<p> #define CAN_IDENTICAL_ID_CANCELLATION    STD_ON/STD_OFF </p>
<p> </p>
<p><b>8.2 </b></p>
<p><b>Link-Time Parameters </b></p>
<p>The library version of the CAN Driver uses the following generated settings: </p>
<p> </p>
<p><b>&gt; </b></p>
<p>Maximum amount of used controllers and Tx mailboxes (has to be set for post-</p>
<p>build variants at link-time) </p>
<p><b>&gt; </b></p>
<p>Rx Queue size </p>
<p><b>&gt; </b></p>
<p>Controller mapping (mapping of logical channel to hardware node). </p>
<p><b>&gt; </b></p>
<p>CAN hardware base address. </p>
<p> </p>
<p><b>8.3 </b></p>
<p><b>Post-Build Parameters </b></p>
<p>Following settings are post-build data that can be changed for re-flashing: </p>
<p> </p>
<p><b>&gt; </b></p>
<p>Amount and usage of FullCAN Rx and Tx mailboxes </p>
<p><b>&gt; </b></p>
<p>Used database (message information like ID, DLC) </p>
<p><b>&gt; </b></p>
<p>Filters for BasicCAN Rx mailbox </p>
<p><b>&gt; </b></p>
<p>Baud-rate settings </p>
<p><b>&gt; </b></p>
<p>Module Start Address (only for post-build systems: The memory location for re-</p>
<p>flashed data has to be defined) </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference    MICROSAR CAN Driver </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 3.00.01 </p>
<p>78 </p>
<p><b>&gt; </b></p>
<p>Configuration ID (only for post-build systems: This number is used to identify the </p>
<p>post-build data </p>
<p><b>&gt; </b></p>
<p>CAN hardware Fifo depth </p>
<p><b>&gt; </b></p>
<p>CAN hardware clock and bit timing settings </p>
<p> </p>
<p><b>8.4 </b></p>
<p><b>Configuration with GENy </b></p>
<p>Please assure that your platform is available with GenTool GENy ! </p>
<p> </p>
<p>The CAN driver is configured with the help of the configuration tool GENy. To generate </p>
<p>communication specific settings, like used message objects e.g. FullCAN Rx mailboxes, </p>
<p>baud rate settings and hardware specific settings for CAN communication, the GENy tool is </p>
<p>used. This chapter explains the usage of this tool. </p>
<p>Please refer to the online help of the tool for detailed information about the general usage. </p>
<p>And see below for special settings of the hardware specifics. </p>
<p> </p>
<p><b>8.4.1 </b></p>
<p><b>Platform Settings </b></p>
<p> </p>
<p>Platform settings are done in the initial setup dialog: </p>
<p>The example below shows Mpc5700 platform: </p>
<p> </p>
<p>Figure 8-1 </p>
<p>Platform Settings </p>
<p> </p>
<p><b> </b></p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference    MICROSAR CAN Driver </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 3.00.01 </p>
<p>79 </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>Since the Generation Tool does not know which MCAN Hardware Revision for the </p>
<p>selected derivative you are actually using, this has to be specified in addition. </p>
<p> </p>
<p>Please see below the supported values for the different hardware revisions: </p>
<p> </p>
<p>MCAN_REV_10: MCAN Release 1, no CAN-FD support, no Rx FullCAN support  </p>
<p>MCAN_REV_20: MCAN Release 2, CAN-FD support with higher bitrates  </p>
<p>MCAN_REV_30: MCAN Release 3, CAN-FD support with higher bitrates and   </p>
<p>                                                           extended data length   </p>
<p>MCAN_REV_310: MCAN Release 3, Step 1, SubStep 0, non-compatibility change to   </p>
<p>                                                           previous revisions   </p>
<p>MCAN_REV_315: MCAN Release 3, Step 1, SubStep 5, CAN-FD support with   </p>
<p>                                                           ISO-11898-1 compatibility </p>
<p> </p>
<p>The MCAN Revisions 3.2.x are compatible with MCAN_REV_315 and thus not </p>
<p>mentioned separately. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Compiler Selection  </b></p>
<p>Select GNU if compiler HighTec for the PowerPC™ is used. </p>
<p>Select DIAB if compiler DiabData for the PowerPC™ is used  </p>
<p> </p>
<p> </p>
<p> </p>
<p>(Wind River Compiler toolkit, formerly known as the Diab Compiler). </p>
<p>Select GHS if compiler Greenhills for the PowerPC™ is used. </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference    MICROSAR CAN Driver </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 3.00.01 </p>
<p>80 </p>
<p><b>8.4.2 </b></p>
<p><b>Component Settings </b></p>
<p> </p>
<p>Figure 8-2 </p>
<p>Component Settings </p>
<p><b>8.4.2.1 </b></p>
<p><b>CAN-FD Non ISO Compatibility  </b></p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference    MICROSAR CAN Driver </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 3.00.01 </p>
<p>81 </p>
<p>When  selecting  MCAN Rev.  3.1.5 or later an additional  configuration  attribute  “Non  ISO </p>
<p>Operation” comes up which allows to select either “ISO 11898-1” or “Bosch CAN-FD Spec. </p>
<p>V1.0” oeration of CAN-FD. </p>
<p> </p>
<p><b>8.4.2.2 </b></p>
<p><b>Attribute Description List </b></p>
<p><b>Attribute Name </b></p>
<p><b>Configuration </b></p>
<p><b> Variant </b></p>
<p><b>Value  </b></p>
<p><b>Type </b></p>
<p><b>Values </b></p>
<p><b>Description </b></p>
<p>Configurable Options </p>
<p>Can MCAN </p>
<p>Revision </p>
<p>pre-compile </p>
<p>Enum </p>
<p> </p>
<p> </p>
<p>M_CAN_REV_10 </p>
<p>M_CAN_REV_20 </p>
<p>M_CAN_REV_30 </p>
<p>M_CAN_REV_310 </p>
<p>M_CAN_REV_315 </p>
<p> </p>
<p>Select the MCAN Release of your  </p>
<p>derivative </p>
<p>Rel.1,   </p>
<p>Rel.2,  </p>
<p>Rel.3,  </p>
<p>Rel.3, Step1, Sub Step 0, </p>
<p>Rel.3, Step1, Sub Step 5, </p>
<p>For further revisions (3.2.x) M_CAN_REV_315 </p>
<p>can be used </p>
<p>Non ISO </p>
<p>Operation </p>
<p>pre-compile </p>
<p>Enum </p>
<p>ISO-11898, </p>
<p>Bosch_V10 </p>
<p>Select either ISO 11898-1 or Bosch CAN-FD </p>
<p>Spec. V1.0 compatibility </p>
<p>Common </p>
<p>Configuration </p>
<p>Variant </p>
<p>pre-compile </p>
<p>Enum </p>
<p>pre-compile, </p>
<p>link-time,  </p>
<p>post-build </p>
<p>Select your project type </p>
<p>Version Info API </p>
<p>pre-compile </p>
<p>Bool </p>
<p>On / Off </p>
<p>Activate function to get version </p>
<p>information </p>
<p>Dev Error </p>
<p>Detection </p>
<p>pre-compile </p>
<p>Bool </p>
<p>On / Off </p>
<p>Activate to get information about </p>
<p>possible conflicts (refer to DET  </p>
<p>module description) </p>
<p>Prod Error </p>
<p>Detection </p>
<p>pre-compile </p>
<p>Bool </p>
<p>On / Off </p>
<p>Activate to get information about </p>
<p>possible conflicts in a running  </p>
<p>system (refer to DEM module  </p>
<p>description) </p>
<p>User Config File </p>
<p>pre-compile </p>
<p>String </p>
<p>File name  </p>
<p>and path </p>
<p>This file will be included in the  </p>
<p>Can_cfg.h for special settings </p>
<p> </p>
<p>Miscellaneous </p>
<p>Hardware Loop </p>
<p>Check </p>
<p>pre-compile </p>
<p>Bool </p>
<p>On / Off </p>
<p>Activate to check for hardware problems inside </p>
<p>a loop (possible endless loops because of </p>
<p>hardware issues will be notified over DEM). </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference    MICROSAR CAN Driver </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 3.00.01 </p>
<p>82 </p>
<p><b>Attribute Name </b></p>
<p><b>Configuration </b></p>
<p><b> Variant </b></p>
<p><b>Value  </b></p>
<p><b>Type </b></p>
<p><b>Values </b></p>
<p><b>Description </b></p>
<p>Multiplexed </p>
<p>Transmission </p>
<p>pre-compile </p>
<p>Bool </p>
<p>On / Off </p>
<p>Activate to get multiple transmit objects for the </p>
<p>Tx BasicCAN object (3 send objects instead of </p>
<p>1). This avoids external Id priority inversion. </p>
<p>Wakeup Support </p>
<p>pre-compile </p>
<p>Bool </p>
<p>Off </p>
<p>Activate  to  Wake  up  over  CAN  bus  by  CAN </p>
<p>Driver. </p>
<p>Identical ID </p>
<p>cancellation </p>
<p>pre-compile </p>
<p>Bool </p>
<p>On / Off </p>
<p>'Hardware Transmit Cancellation&quot; also cancels </p>
<p>messages with the same identifier (newer data </p>
<p>will be send) out of hardware mailboxes. </p>
<p>Otherwise only lower prior identifiers will be </p>
<p>cancelled (older data will be send). </p>
<p>Timeout </p>
<p>Timeout Duration </p>
<p>Factor </p>
<p>(MICROSAR3 </p>
<p>only)</p>
<p> </p>
<p>pre-compile </p>
<p>Integer Loop counter </p>
<p>Maximum loop count for hardware loop check. </p>
<p>Refer to loop descriptions set this value for </p>
<p>your needs. </p>
<p>Timeout Duration </p>
<p>(MICROSAR4x only)</p>
<p> </p>
<p>pre-compile </p>
<p>Float </p>
<p>Time </p>
<p>Specifies </p>
<p>the </p>
<p>time </p>
<p>(in </p>
<p>seconds) </p>
<p>for </p>
<p>the </p>
<p>“Hardware Loop Check”. </p>
<p>Timeout Counter </p>
<p>ID </p>
<p>(MICROSAR401 only) </p>
<p>pre-compile </p>
<p>Float </p>
<p>Time </p>
<p>Specifies the counter ID used in OS for 'Timeout </p>
<p>Duration'</p>
<p> </p>
<p>Polling </p>
<p>Tx Processing </p>
<p>pre-compile </p>
<p>Enum </p>
<p>Interrupt / Polling </p>
<p>Activate to handle transmit messages over </p>
<p>polling </p>
<p>Rx Processing </p>
<p>pre-compile </p>
<p>Enum </p>
<p>Interrupt /  </p>
<p>Polling </p>
<p>Activate to handle receive messages </p>
<p>over polling </p>
<p>Busoff Processing  pre-compile </p>
<p>Enum </p>
<p>Interrupt /  </p>
<p>Polling </p>
<p>Activate to handle BusOff event over  </p>
<p>Polling </p>
<p>Wakeup </p>
<p>Processing </p>
<p>pre-compile </p>
<p>Enum </p>
<p>Interrupt /  </p>
<p>Polling </p>
<p>Activate to handle WakeUp events by  </p>
<p>Polling Mode.  </p>
<p>AUTOSAR extension </p>
<p>Generic PreCopy </p>
<p>pre-compile </p>
<p>Bool </p>
<p>On / Off </p>
<p>Generic precopy function for all  </p>
<p>receive messages </p>
<p>Generic </p>
<p>Confirmation </p>
<p>pre-compile </p>
<p>Bool </p>
<p>On / Off </p>
<p>Generic Tx confirmation for all  </p>
<p>transmit messages </p>
<p>Rx FullCAN </p>
<p>Support </p>
<p>pre-compile </p>
<p>Bool </p>
<p>Off </p>
<p>Use Rx FullCAN message objects  </p>
<p>(deactivate to reduce ROM and  </p>
<p>runtime consumption) </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference    MICROSAR CAN Driver </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 3.00.01 </p>
<p>83 </p>
<p><b>Attribute Name </b></p>
<p><b>Configuration </b></p>
<p><b> Variant </b></p>
<p><b>Value  </b></p>
<p><b>Type </b></p>
<p><b>Values </b></p>
<p><b>Description </b></p>
<p>Tx FullCAN </p>
<p>Support </p>
<p>pre-compile </p>
<p>Bool </p>
<p>On </p>
<p>Use Tx FullCAN message objects  </p>
<p>(deactivate to reduce ROM and  </p>
<p>runtime consumption) </p>
<p>Rx BasicCAN </p>
<p>Support </p>
<p>pre-compile </p>
<p>Bool </p>
<p>On </p>
<p>Use Rx BasicCAN message objects  </p>
<p>(deactivate to reduce ROM and  </p>
<p>runtime consumption) </p>
<p>Use Nested CAN </p>
<p>Interrupts </p>
<p>pre-compile </p>
<p>Bool </p>
<p>On / Off </p>
<p>Use Nested CAN interrupts  </p>
<p>(deactivate to reduce runtime  </p>
<p>consumption) </p>
<p>Hardware Loop </p>
<p>Check by </p>
<p>Application </p>
<p>pre-compile </p>
<p>Bool </p>
<p>On / Off </p>
<p>Enable this when you like to handle  </p>
<p>hardware cancellation by your own.  </p>
<p>Using API functions  </p>
<p>“ApplCanTimerStart()“,  </p>
<p>„ApplCanTimerEnd()“ and  </p>
<p>„ApplCanTimerLoop()“ </p>
<p>Report  </p>
<p>CAN_E_TIMEOUT </p>
<p> as DET 0x07  </p>
<p>notification </p>
<p>pre-compile </p>
<p>Bool </p>
<p>On / Off </p>
<p>Reports DEM Timeout as DET 0x07  </p>
<p>notification </p>
<p>Individual </p>
<p>Processing </p>
<p>pre-compile </p>
<p>Bool </p>
<p>On / Off </p>
<p>Enable  this  if  you  like  to  configure  mailbox </p>
<p>specific polling/interrupt processing. </p>
<p>This  feature  is  only  available  with  “High  End” </p>
<p>license. </p>
<p>Support Mixed ID </p>
<p>pre-compile </p>
<p>Bool </p>
<p>On / Off </p>
<p>Use standard and extended ID mode for </p>
<p> Rx and Tx messages. </p>
<p>Type of Interrupt  </p>
<p>Function </p>
<p>link-time </p>
<p>Enum </p>
<p>Category 1 </p>
<p>Category 2 </p>
<p>Category 1: Interrupt Function has to be added </p>
<p>to the interrupt vector table. </p>
<p>Category 2: Interrupt Function is defined with </p>
<p>ISR() define. </p>
<p>Get Status API </p>
<p>pre-compile </p>
<p>Bool </p>
<p>On / Off </p>
<p>Support Can_GetStatus() API that return </p>
<p>the hardware states: </p>
<p>CAN_STATUS_STOP, </p>
<p>CAN_STATUS_INIT,  </p>
<p>CAN_STATUS_WARNING,  </p>
<p>CAN_STATUS_PASSIVE,  </p>
<p>CAN_STATUS_BUSOFF,  </p>
<p>CAN_STATUS_SLEEP </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference    MICROSAR CAN Driver </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 3.00.01 </p>
<p>84 </p>
<p><b>Attribute Name </b></p>
<p><b>Configuration </b></p>
<p><b> Variant </b></p>
<p><b>Value  </b></p>
<p><b>Type </b></p>
<p><b>Values </b></p>
<p><b>Description </b></p>
<p>CAN Interrupt lock  pre-compile </p>
<p>Enum </p>
<p>CANDriver </p>
<p>Application </p>
<p>Both </p>
<p>Disable and Restore Can Interrupt by  </p>
<p>CAN Driver or Application or CAN Driver </p>
<p> and Application. Reason may be, that  </p>
<p>the CAN Driver should not access the  </p>
<p>Interrupt controller for CAN interrupts or </p>
<p>there are other restrictions (special  </p>
<p>security level) or Application has to care </p>
<p>about additional Interrupts like Wakeup.</p>
<p><b> </b></p>
<p>Multiple BasicCAN </p>
<p>Objects </p>
<p>pre-compile </p>
<p>Bool </p>
<p>On / Off </p>
<p>Support Multiple BasicCAN objects. This gives </p>
<p>the possibility to use multiple Filters and </p>
<p>optimize acceptance Filtering as well as avoid </p>
<p>overrun. This feature is only available with </p>
<p>“High End” license. </p>
<p>Optimize for one </p>
<p>controller </p>
<p>pre-compile </p>
<p>Bool </p>
<p>On / Off </p>
<p>If only one CAN controller is used, then  </p>
<p>the code can be optimized for space and  </p>
<p>runtime. </p>
<p>Dynamic FullCAN </p>
<p>Tx ID </p>
<p>pre-compile </p>
<p>Bool </p>
<p>Off </p>
<p>Use dynamic FullCAN Tx IDs during  </p>
<p>runtime. </p>
<p>Size of Hw </p>
<p>HandleType </p>
<p>link-time </p>
<p>Integer Size </p>
<p>Adapt the type of hw handles for  </p>
<p>compiler options. </p>
<p>Partial Networking </p>
<p>(may not be </p>
<p>visible,  depends </p>
<p>on your delivery) </p>
<p>pre-compile </p>
<p>Bool </p>
<p>Off </p>
<p>Activate this when you like to support a  </p>
<p>partial network that will be woken up by </p>
<p> a special NM message. This feature  </p>
<p>has to be enabled if one of the  </p>
<p>controllers shall wake up by a partial  </p>
<p>network transceiver. </p>
<p>RAM Check </p>
<p>pre-compile </p>
<p>Enum </p>
<p>None/ </p>
<p>Active/ </p>
<p>Mailbox  </p>
<p>Notification </p>
<p>RAM check of mailbox buffers. </p>
<p>None: No RAM check </p>
<p>Active: Active RAM check (global notification) </p>
<p>Mailbox Notification: Active RAM check (global </p>
<p>+ mailbox notification) </p>
<p>Overrun </p>
<p>Notification </p>
<p>pre-compile </p>
<p>Enum </p>
<p>None, </p>
<p>DET, </p>
<p>Application </p>
<p>Action to be done in case of a  Rx FIFO </p>
<p>overrun </p>
<p>Generic </p>
<p>PreTransmit </p>
<p>pre-compile </p>
<p>Bool </p>
<p>On / Off </p>
<p>A generic pre-transmit, common for all Tx </p>
<p>messages will be called when this  </p>
<p>checkbox is enabled. Use this to change  </p>
<p>data or abort transmission right before  </p>
<p>the message will be send. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference    MICROSAR CAN Driver </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 3.00.01 </p>
<p>85 </p>
<p><b>Attribute Name </b></p>
<p><b>Configuration </b></p>
<p><b> Variant </b></p>
<p><b>Value  </b></p>
<p><b>Type </b></p>
<p><b>Values </b></p>
<p><b>Description </b></p>
<p>Rx Queue </p>
<p>Rx Queue </p>
<p>pre-compile </p>
<p>Bool </p>
<p>On / Off </p>
<p>Enable this when you like to handle Rx </p>
<p>messages in polling context. (Shorten interrupt </p>
<p>latency time). This feature is only available with </p>
<p>“High End” license. </p>
<p>Size </p>
<p>pre-compile </p>
<p>Bool </p>
<p>On / Off </p>
<p>Size of FIFO in which the Message information </p>
<p>is buffered. </p>
<p>Postbuild configuration   (not supported for the Beta version) </p>
<p>Module Start </p>
<p>Address  </p>
<p>(Post-build only) </p>
<p>post-build </p>
<p>Integer Address </p>
<p>Destination address where data has to be  </p>
<p>flashed </p>
<p>Max Nr. Of Tx  </p>
<p>Objects  </p>
<p>(Post-build only) </p>
<p>link-time </p>
<p>Integer Amount </p>
<p>Total amount of maximum used transmit  </p>
<p>objects over all controllers.  </p>
<p>This is used for RAM variables. </p>
<p>Max CanController  </p>
<p>(Post-build only) </p>
<p>link-time </p>
<p>Integer Amount </p>
<p>Amount of maximum used controllers  </p>
<p>(used for RAM variables). </p>
<p>Configuration ID  </p>
<p>(Post-build only) </p>
<p>post-build </p>
<p>Integer Identity </p>
<p>A special value to identify this  </p>
<p>configuration in the Flash. </p>
<p>Table 8-2  </p>
<p>Component Parameter Description </p>
<p> </p>
<p><b>8.4.3 </b></p>
<p><b>Individual Polling Settings </b></p>
<p> </p>
<p> </p>
<p>With “Individual Polling” feature (see 8.4.2) you can select for each mailbox Rx/Tx event to </p>
<p>be polled or handled by interrupt. In case of FullCAN mailbox the name of the message is </p>
<p>shown. In case of BasicCAN mailbox “BasicCAN Rx (X)” or “Normal Tx” has to be selected </p>
<p>to handle all messages related to this mailbox in Polling Mode. </p>
<p>“Normal Tx” is the collection of all none FullCAN Tx messages. </p>
<p>“BasicCAN Rx (X)” is the collection of all none FullCAN Rx messages pass the BasicCAN </p>
<p>Filter “X”. </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference    MICROSAR CAN Driver </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 3.00.01 </p>
<p>86 </p>
<p><b>8.4.4 </b></p>
<p><b>Common CAN settings </b></p>
<p>Not supported. </p>
<p>To use the Common CAN feature the used derivative must have at least two CAN channels </p>
<p>and at least one CAN channel must be available. </p>
<p>To activate the feature the ‘Use Common CAN’ checkbox in the hardware specific </p>
<p>configuration page of the channel must be turned ‘on’ and the ‘CAN B base address’ of the </p>
<p>‘second’ hardware channel must be selected.  </p>
<p>After the feature was activated on the channel it is possible to place additional Rx FullCAN </p>
<p>message objects to the ‘second’ – ‘B’ hardware channel: </p>
<p> </p>
<p><b>8.4.5 </b></p>
<p><b>Controller (Channel) Settings </b></p>
<p>Add up to three different Init Structures to setup a variety of baud rate and filter settings that </p>
<p>can be selected during the initialization of the ECU. The structure to be activated can be </p>
<p>selected during initialization by calling the function “Can_InitStruct()” . </p>
<p>Can_InitStruct is a (None AUTOSAR API) service function that allows to change the active </p>
<p>initialization structure left behind by the Generation Tool. </p>
<p>A subsequent call of Can_InitController() must be accomplished to activate these settings. </p>
<p> </p>
<p>void _InitStruct(uint8 Controller, uint8 Index) </p>
<p> </p>
<p>param[in]     Controller    CAN controller to be changed  </p>
<p>  </p>
<p>param[in]     Index         </p>
<p>Index of the initialization structure to be used     </p>
<p> </p>
<p>Note: Call this function between calling &quot;Can_Init()&quot; and Can_InitController()&quot;. </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference    MICROSAR CAN Driver </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 3.00.01 </p>
<p>87 </p>
<p> </p>
<p> </p>
<p>Figure 8-2 </p>
<p>Controller Settings </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference    MICROSAR CAN Driver </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 3.00.01 </p>
<p>88 </p>
<p><b>8.4.5.1 </b></p>
<p><b>Init Structure Settings </b></p>
<p> </p>
<p>Figure 8-3 </p>
<p>Init Structure Dialog </p>
<p><b>Attribute Name </b></p>
<p><b>Configuration </b></p>
<p><b> Variant </b></p>
<p><b>Value  </b></p>
<p><b>Type </b></p>
<p><b>Values </b></p>
<p><b>Description </b></p>
<p>Initialization </p>
<p>BTP </p>
<p>link-time, </p>
<p>post-build </p>
<p>Integer </p>
<p>&quot;Bit Timing and </p>
<p>Prescaler&quot; </p>
<p>This value results from </p>
<p>the “Bustiming  </p>
<p>configuration” (see </p>
<p>below) or can  </p>
<p>alternatively be  </p>
<p>entered directly.  </p>
<p>FBTP (optional) </p>
<p>link-time, </p>
<p>post-build </p>
<p>Integer </p>
<p>&quot;Fast Bit Timing,  </p>
<p>Prescaler and </p>
<p>Transceiver Delay </p>
<p>Compensation&quot; </p>
<p>This value results from </p>
<p>the “CAN-FD Bustiming  </p>
<p>configuration” (see </p>
<p>below) or can  </p>
<p>alternatively be  </p>
<p>entered directly. </p>
<p>Acceptance Filter  </p>
<p>Configuration </p>
<p>link-time, </p>
<p>post-build </p>
<p>Integer </p>
<p>See chapter </p>
<p>&quot;Acceptance Filter </p>
<p>Settings &quot; </p>
<p>Acceptance filter  </p>
<p>configuration for  </p>
<p>BasicCAN Rx objects. </p>
<p>Bustiming Configuration </p>
<p>link-time, </p>
<p>post-build </p>
<p>Integer </p>
<p>See chapter &quot;Bus </p>
<p>Timing Settings&quot; </p>
<p>Bit timing configuration </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference    MICROSAR CAN Driver </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 3.00.01 </p>
<p>89 </p>
<p><b>Attribute Name </b></p>
<p><b>Configuration </b></p>
<p><b> Variant </b></p>
<p><b>Value  </b></p>
<p><b>Type </b></p>
<p><b>Values </b></p>
<p><b>Description </b></p>
<p>CAN-FD Bustiming </p>
<p>Configuration </p>
<p>link-time, </p>
<p>post-build </p>
<p>Integer </p>
<p>See chapter &quot;Bus </p>
<p>Timing Settings&quot; </p>
<p>Fast Bit timing </p>
<p>configuration </p>
<p>Figure 8-4 </p>
<p>Init Structure description </p>
<p>Add Init Structures to setup multiple baud rate that can be selected at Initialization phase of </p>
<p>the ECU. </p>
<p>MicroSar3  only:  This  structure  can  be  selected  with </p>
<p>Can_InitStruct()</p>
<p>  before  calling </p>
<p>Can_InitController().</p>
<p> </p>
<p> </p>
<p><b>8.4.5.2 </b></p>
<p><b>MCAN Hardware Configuration </b></p>
<p><b>Attribute Name </b></p>
<p><b>Configuration </b></p>
<p><b> Variant </b></p>
<p><b>Value  </b></p>
<p><b>Type </b></p>
<p><b>Values </b></p>
<p><b>Description </b></p>
<p>Hw_Mpc5700MCanCpuCan </p>
<p>CAN-FD support </p>
<p>pre-compile, </p>
<p>link-time </p>
<p>Bool </p>
<p>On / Off </p>
<p>Activate this when you </p>
<p>like to support CAN-FD </p>
<p>(with bitrates higher </p>
<p>than 1 Mbit for a fast </p>
<p>data transfer). </p>
<p>MCAN BaseAddress </p>
<p>pre-compile, </p>
<p>link-time </p>
<p>Enum </p>
<p>0xF7ED4000 … </p>
<p>0xFBEF0000 </p>
<p>Select the base  </p>
<p>address of the CAN </p>
<p>controller which is  </p>
<p>used on the channel. </p>
<p>Filters per Basic CAN </p>
<p>pre-compile,  </p>
<p>link-time </p>
<p>Integer </p>
<p>0 … 128 for Standard,  </p>
<p>0 … 64  for Extended,  </p>
<p>0 … 192 for Mixed ID  </p>
<p>Enter the number of  </p>
<p>available filters on this </p>
<p> channel. </p>
<p>Rx Fifo(0/1) depth </p>
<p>pre-compile, </p>
<p>link-time </p>
<p>Integer </p>
<p>1 … 64 per Fifo </p>
<p>Enter the number of </p>
<p>messages that can be </p>
<p>stored within Fifo-0  </p>
<p>(and Fifo-1 in case of </p>
<p>MultipleBasicCAN). </p>
<p>Figure 8-5 </p>
<p>Hardware description </p>
<p> </p>
<p><b>8.4.5.3 </b></p>
<p><b>Acceptance Filter Configuration </b></p>
<p> </p>
<p>Setup the Filter by pressing the “Acceptance Filter Configuration” button. </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference    MICROSAR CAN Driver </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 3.00.01 </p>
<p>90 </p>
<p> </p>
<p>Figure 8-6 </p>
<p>Setup Filter Dialog </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference    MICROSAR CAN Driver </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 3.00.01 </p>
<p>91 </p>
<p> </p>
<p><b>Attribute  </b></p>
<p><b>Name </b></p>
<p><b>Configuration  </b></p>
<p><b>Variant </b></p>
<p><b>Value Type </b></p>
<p><b>Values </b></p>
<p> </p>
<p><b>Description </b></p>
<p>Setup </p>
<p>Acceptance </p>
<p>Filter </p>
<p>post-build </p>
<p>Integer </p>
<p>Mask and Code </p>
<p>register </p>
<p>Each ID –bit is represented by a </p>
<p> “0/1/X”, means must match a “0” or  </p>
<p>“1” or must not match “X” </p>
<p>Open filters </p>
<p> </p>
<p>Action </p>
<p>- </p>
<p>Open the filter completely to receive  </p>
<p>all IDs </p>
<p>Optimize </p>
<p> </p>
<p>Action </p>
<p>- </p>
<p>Open the filter automatic to just  </p>
<p>receive the IDs in database. “Use  </p>
<p>FullCAN” try to put as much  </p>
<p>messages in FullCAN objects to  </p>
<p>better optimize filters </p>
<p>Table 8-1  </p>
<p>Filter Parameter Description </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>The hardware supports a maximum of 128 standard and 64 extended filters for each </p>
<p>CAN channel. For each Rx FullCAN object one filter is grabbed by the generation tool. </p>
<p>Your configuration must not exceed the total available number of standard/extended </p>
<p>filters used for FullCAN and BasicCAN objects. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p> </p>
<p><b>8.4.5.4 </b></p>
<p><b>Bus Timing Configuration </b></p>
<p> </p>
<p>Setup the Baud rate by pressing the “Bustiming Configuration” button. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference    MICROSAR CAN Driver </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 3.00.01 </p>
<p>92 </p>
<p> </p>
<p>Figure 8-7 </p>
<p>Baud Rate Dialog </p>
<p><b>Attribute </b></p>
<p><b> Name </b></p>
<p><b>Configuration </b></p>
<p><b> Variant </b></p>
<p><b>Value  </b></p>
<p><b>Type </b></p>
<p><b>Values </b></p>
<p> </p>
<p><b>Description </b></p>
<p>Clock </p>
<p>post-build </p>
<p>Integer </p>
<p>CAN clock </p>
<p>Set the clock of the CAN engine, i.e.  </p>
<p>oscillator clock or system clock. </p>
<p>Baud rate </p>
<p>post-build </p>
<p>Integer </p>
<p>Baud Rate </p>
<p>Set baud rate to be used for this channel </p>
<p>Calculate </p>
<p> </p>
<p>Action </p>
<p>- </p>
<p>It is possible to calculate possible  </p>
<p>hardware register settings out of baud </p>
<p> rate or vice versa. </p>
<p>Sample,  </p>
<p>BTL cycles,  </p>
<p>SJW </p>
<p>post-build </p>
<p>Select  </p>
<p>Set of </p>
<p>Values </p>
<p>Baud Rate </p>
<p>Settings </p>
<p>Select the sample point and sync phase </p>
<p>related to your bus physics </p>
<p>Table 8-2  </p>
<p>Baud Rate Parameter Description </p>
<p>Setup the CAN-FD Baud rate by pressing the “CAN-FD Bustiming Configuration” button. </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference    MICROSAR CAN Driver </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 3.00.01 </p>
<p>93 </p>
<p> </p>
<p>Figure 8-8 </p>
<p>CAN-FD Baud Rate Dialog </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference    MICROSAR CAN Driver </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 3.00.01 </p>
<p>94 </p>
<p> </p>
<p><b>Attribute </b></p>
<p><b> Name </b></p>
<p><b>Configuration </b></p>
<p><b> Variant </b></p>
<p><b>Value  </b></p>
<p><b>Type </b></p>
<p><b>Values </b></p>
<p> </p>
<p><b>Description </b></p>
<p>Clock </p>
<p>post-build </p>
<p>Integer </p>
<p>CAN clock </p>
<p>Set the clock of the CAN engine, i.e.  </p>
<p>oscillator clock or system clock. </p>
<p>Transceiver </p>
<p>Delay </p>
<p>Compensation </p>
<p>post-build </p>
<p>Bool </p>
<p>On / Off </p>
<p>If selected the the transmitter measures </p>
<p>within each CAN FD frame the delay </p>
<p>between the data transmitted at pin </p>
<p>M_CAN_Tx and the data received at </p>
<p>M_CAN_Rx pin.  </p>
<p>A secondary sample point is calculated by </p>
<p>adding the configurable transceiver delay </p>
<p>compensation (see below) to the </p>
<p>measured transceiver delay.  </p>
<p>The delay is measured in M_CAN core </p>
<p>clock periods. </p>
<p>Delay </p>
<p>Compensation </p>
<p>post-build </p>
<p>Integer </p>
<p>CAN-FD </p>
<p>Delay </p>
<p>Compensation </p>
<p>A secondary sample point is calculated by </p>
<p>adding this configurable transceiver delay </p>
<p>compensation to the measured transceiver </p>
<p>delay (see above).  </p>
<p>The transceiver delay compensation is </p>
<p>used to adjust the secondary sample point </p>
<p>inside the bit time. The position of the </p>
<p>secondary sample point is rounded down </p>
<p>to the next integer number of the time </p>
<p>quanta. </p>
<p>To check for bit errors during the data </p>
<p>phase, the delayed transmit data is </p>
<p>compared against the received data at the </p>
<p>secondary sample point. If a bit error is </p>
<p>detected at the secondary sample point, </p>
<p>the transmitter will react to this bit error at </p>
<p>the next following sample point. </p>
<p>Baud rate </p>
<p>post-build </p>
<p>Integer </p>
<p>CAN-FD Baud </p>
<p>Rate </p>
<p>Set baud rate to be used for this channel </p>
<p>Calculate </p>
<p> </p>
<p>Action </p>
<p>- </p>
<p>It is possible to calculate possible  </p>
<p>hardware register settings out of baud </p>
<p> rate or vice versa. </p>
<p>Sample,  </p>
<p>BTL cycles,  </p>
<p>SJW </p>
<p>post-build </p>
<p>Select  </p>
<p>Set of </p>
<p>Values </p>
<p>Baud Rate </p>
<p>Settings </p>
<p>Select the sample point and sync phase </p>
<p>related to your bus physics </p>
<p>Table 8-3  </p>
<p>CAN-FD Baud Rate Parameter Description </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference    MICROSAR CAN Driver </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 3.00.01 </p>
<p>95 </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>For the transceiver delay compensation the following boundary conditions have </p>
<p>to be considered: </p>
<p>▪</p>
<p> </p>
<p>The  sum  of  the  measured  delay  from  M_CAN_Tx  to  M_CAN_Rx  and  the </p>
<p>configured transceiver delay compensation has to be less than 3 bit times in </p>
<p>the data phase.  </p>
<p>▪</p>
<p> </p>
<p>The  sum  of  the  measured  delay  from  M_CAN_Tx  to  M_CAN_Rx  and  the </p>
<p>configured transceiver delay compensation has to be less or equal 63 M_CAN </p>
<p>core clock periods. In case this sum exceeds 63 M_CAN core clock periods, </p>
<p>the maximum value of 63 M_CAN core clock periods is used for transceiver </p>
<p>delay compensation. </p>
<p>▪</p>
<p> </p>
<p>The actual delay compensation value is monitored by reading the MCAN test </p>
<p>register TEST(TDCV). </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p> </p>
<p><b>8.5 </b></p>
<p><b>Configuration with da DaVinci Configurator </b></p>
<p>See Online help within DaVinci Configurator and BSWMD file for parameter settings. </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference    MICROSAR CAN Driver </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 3.00.01 </p>
<p>96 </p>
<p><b>9 </b></p>
<p><b>AUTOSAR Standard Compliance </b></p>
<p><b>9.1 </b></p>
<p><b>Limitations / Restrictions </b></p>
<p><b>Category </b></p>
<p><b>Description </b></p>
<p><b>Version </b></p>
<p>Functional </p>
<p>No multiple AUTOSAR CAN driver allowed in the system </p>
<p>3.0.6  </p>
<p>Functional </p>
<p>No support for L-PDU callout (AUTOSAR 3.2.1), but support ‘Generic </p>
<p>Precopy’ instead </p>
<p>3.2.1 </p>
<p>Functional </p>
<p>No support for multiple read and write period configuration </p>
<p>3.2.1 </p>
<p>API </p>
<p>“</p>
<p>Symbolic Name Values” may change their values after precompile </p>
<p>phase so do not use it for Link Time or Post Build variants. </p>
<p>It’s recommended that higher layer generator use Values (ObjectIDs) </p>
<p>from EcuC file. Vector CAN Interface does so.</p>
<p> </p>
<p>3.0.6 </p>
<p> </p>
<p>For the acceptance filtering a maximum of 64 filters per CAN channel </p>
<p>is supported in case of GENy is used as Generation Tool. </p>
<p> </p>
<p> </p>
<p> </p>
<p><b>9.2 </b></p>
<p><b>Hardware Limitations </b></p>
<p><b>9.2.1 </b></p>
<p><b>Tx side </b></p>
<p>MCAN Tx Event FIFO is not supported. </p>
<p>MCAN Tx Queue is not supported. </p>
<p>All available buffers per CAN (32) are configured as dedicated Tx buffers. </p>
<p><b>9.2.2 </b></p>
<p><b>Rx side </b></p>
<p>SREQ00014271 “message reception shall use overwrite mode” is not fulfilled for FullCAN </p>
<p>messages due to hardware behaviour. </p>
<p><b>9.2.3 </b></p>
<p><b>Used resources </b></p>
<p>Please  note  that  the  theoretical  possible  maximum  configuration  for  the  derivatives  often </p>
<p>requires more RAM space in the Shared Message RAM than there is actual available. </p>
<p>For each CAN channel the following elements can be configured. If the required size for a </p>
<p>distinct  configuration  exceeds  the  maximum  available  RAM  space  in  hardware  then  the </p>
<p>configuration tool issues an error during generation time and you are requested to tailor down </p>
<p>your configuration until it fits into the available Shared Message RAM.  </p>
<p> </p>
<p>Resource usage for one CAN channel: </p>
<p>Area </p>
<p>Address range </p>
<p>Max size (byte) </p>
<p>Max.  number  of </p>
<p>elements </p>
<p>Std Filter     </p>
<p>0x0000 – 0x01FF </p>
<p>  512  </p>
<p>128 </p>
<p>Ext Filter     </p>
<p>0x0200 – 0x03FF </p>
<p>  512  </p>
<p>  64 </p>
<p>Rx FIFO 0   </p>
<p>0x0400 – 0x07FF </p>
<p>1024  </p>
<p>  64 </p>
<p>Rx FIFO 1   </p>
<p>0x0800 – 0x0BFF </p>
<p>1024  </p>
<p>  64 </p>
<p>Rx Buffer </p>
<p>0x0C00 – 0x0FFF </p>
<p>1024  </p>
<p>  64 </p>
<p>TxEvt FIFO </p>
<p>0x1000 – 0x10FF </p>
<p>  256 </p>
<p>  32 </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference    MICROSAR CAN Driver </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 3.00.01 </p>
<p>97 </p>
<p>Tx buffer   </p>
<p>0x1100 – 0x12FF </p>
<p>  512 </p>
<p>  32 </p>
<p>                           0x1300 </p>
<p> </p>
<p> </p>
<p> </p>
<p>             <b>4864 </b>bytes total </p>
<p> </p>
<p>Thus a maximum of 24320 bytes (4864 * 5) can theoretically be configured but less RAM is </p>
<p>physically available (e.g.: 16 KByte per CAN channel). You are requested to reduce the </p>
<p>areas according to your needs. </p>
<p>Please note that in case of CAN-FD with data lengths greater than 8 data bytes </p>
<p>corresponding Message RAM sizes have to be taken into consideration. </p>
<p>Please note that the “Tx Buffer region” and the “TTCAN region” (for channels with TTCAN </p>
<p>support) for each channel is restricted to a dedicated address.  </p>
<p>This is not consistent for all hardware releases, please refer to your hardware manufacturer </p>
<p>documentation (see ch. 2 “Hardware Overview”). </p>
<p>  </p>
<p><b>9.2.4 </b></p>
<p><b>Initialization of the CAN Message RAM </b></p>
<p>The  internal  SRAM  features  Error  Correcting  Code  (ECC).  Because  these  ECC  bits  can </p>
<p>contain random data after the device is turned on, all SRAM locations must be initialized </p>
<p>before being read by application code. Initialization is done by executing 64-bit writes to the </p>
<p>entire SRAM block. The value written does not matter at this point, so the Store Multiple Word </p>
<p>instruction will be used to write 16 general-purpose registers with each loop iteration. </p>
<p>By default the CAN Driver tries to accomplish this initialization. Due to the need of  using </p>
<p>assembler  code  notation  it  might  happen  that  specific  options  for  a  distinct  compiler </p>
<p>(assembler) are not appropriate. If so, you can feel free to disable the CAN Driver internal </p>
<p>initialization (see below on how to) and use your own initialization instead of.  </p>
<p>To  disable  the  CAN  Driver  internal  initialization  use  a  “User  Config  File”  containing  the </p>
<p>following preprocessor definition: </p>
<p>#define CAN_ECC_INIT    STD_OFF </p>
<p>Put your initialization into execution just before calling Can_Init(). The MCAN clock must be </p>
<p>available at this point of time. </p>
<p>Please refer to your hardware manufacturer documentation (see ch. 2 “Hardware Overview”) </p>
<p>for the address layout. </p>
<p> </p>
<p><b>9.2.5 </b></p>
<p><b>Multiple configuration </b></p>
<p>When using the Multiple Configurations feature (only available with GENy as Generation </p>
<p>Tool) you must care of the physical CAN channel assignment to the logical CAN channels. </p>
<p>Due to the common CAN Message RAM usage of several CAN channels it has to be </p>
<p>avoided that the allocated Message RAM partitions per CAN channel overlap each other. </p>
<p> </p>
<p>Example (1):  </p>
<p>Correct configuration with 3 logical channels  </p>
<p>using 2 physical channels  within 2 identities </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference    MICROSAR CAN Driver </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 3.00.01 </p>
<p>98 </p>
<p> </p>
<p> </p>
<p>Figure 9-1 </p>
<p>Correct Identity Mapping example </p>
<p>Let us assume that the logical channels “DUT_CH0” and “DUT_CH1” use the same </p>
<p>physical channel “M_CAN_2” and “DUT_CH2” is mapped on the physical channel </p>
<p>“M_CAN_4”.  </p>
<p>The CAN Message RAM is allocated per logical channel starting with the first one. </p>
<p> </p>
<p>If the first logical channel “DUT_CH0” (see Figure 9-1) has a different configuration </p>
<p>(allocating more or less CAN Message RAM) than the subsequent logical channel </p>
<p>“DUT_CH1”, both mapped to the first physical channel “M_CAN_2”, then the subsequent </p>
<p>channels within one and the same identity must assure that there is no address conflict </p>
<p>(overlap or gap) within the CAN Message RAM allocation. </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>Figure 9-2 </p>
<p>Correct CAN Message RAM allocation example </p>
<p> </p>
<p>Message RAM allocated by  </p>
<p>DUT_CH0 (M_CAN-2) </p>
<p>Message RAM allocated by  </p>
<p>DUT_CH1 (M_CAN-2) </p>
<p>Message RAM allocated by  </p>
<p>DUT_CH2 (M_CAN-4) </p>
<p>ID1 </p>
<p>ID2 </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference    MICROSAR CAN Driver </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 3.00.01 </p>
<p>99 </p>
<p>Example (2):  </p>
<p>Faulty configuration with 3 logical channels  </p>
<p>using 2 physical channels within 2 identities </p>
<p> </p>
<p>If you modify the identity mapping in the way that the previous channel allocation is </p>
<p>changed like shown in “Figure 9-3 </p>
<p>Faulty Identity Mapping” then you must assure that no </p>
<p>CAN Message RAM overlap can appear (see “Figure 9-4 Faulty CAN Message RAM </p>
<p>allocation example”Figure 9-4).  </p>
<p> </p>
<p>In the example below the “M_CAN_2” configuration is partly overwritten by the “M_CAN_4” </p>
<p>configuration when using Identity-2: </p>
<p> </p>
<p> </p>
<p> </p>
<p>Figure 9-3 </p>
<p>Faulty Identity Mapping example </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>Figure 9-4 </p>
<p>Faulty CAN Message RAM allocation example </p>
<p> </p>
<p> </p>
<p>DUT_CH2 (M_CAN-4) </p>
<p>Message RAM allocated by  </p>
<p>DUT_CH0 (M_CAN-2) </p>
<p>Partly overwritten Message RAM </p>
<p>allocated by DUT_CH1 (M_CAN-2) </p>
<p> </p>
<p> </p>
<p> </p>
<p>Message RAM allocated by  </p>
<p> </p>
<p>DUT_CH2 (M_CAN-4) </p>
<p>ID1 </p>
<p>ID2 </p>
<p>Overlap (M_CAN_4 / M_CAN_2)</p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference    MICROSAR CAN Driver </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 3.00.01 </p>
<p>100 </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p> </p>
<p>(The Message RAM Start/End addresses of each channel can be checked within </p>
<p>the generated table “CanShmStartEndAdr”.) </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>9.3 </b></p>
<p><b>Vector Extensions </b></p>
<p>Refer to Chapter “Features ” listed under “</p>
<p><b>AUTOSAR extensions” </b></p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference    MICROSAR CAN Driver </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 3.00.01 </p>
<p>101 </p>
<p><b>10  Glossary and Abbreviations </b></p>
<p><b>10.1 </b></p>
<p><b>Glossary </b></p>
<p><b>Term </b></p>
<p><b>Description </b></p>
<p>GENy </p>
<p>Generation tool for CANbedded and MICROSAR components </p>
<p>High End (</p>
<p>license)</p>
<p> </p>
<p>Product </p>
<p>license</p>
<p> to support an extended feature set (see Feature table) </p>
<p>Table 10-1  </p>
<p>Glossary </p>
<p> </p>
<p><b>10.2 </b></p>
<p><b>Abbreviations </b></p>
<p><b>Abbreviation </b></p>
<p><b>Description </b></p>
<p>API </p>
<p>Application Programming Interface </p>
<p> </p>
<p>AUTOSAR </p>
<p>Automotive Open System Architecture </p>
<p>BSW </p>
<p>Basis Software </p>
<p>DEM </p>
<p>Diagnostic Event Manager </p>
<p>DET </p>
<p>Development Error Tracer </p>
<p>ECU </p>
<p>Electronic Control Unit </p>
<p>HIS </p>
<p>Hersteller Initiative Software </p>
<p>ISR </p>
<p>Interrupt Service Routine </p>
<p>MICROSAR </p>
<p>Microcontroller Open System Architecture (the Vector AUTOSAR </p>
<p>solution) </p>
<p>3.3x  = AUTOSAR version 3 </p>
<p>401  = AUTOSAR version 4.0.1 </p>
<p>403  = AUTOSAR version 4.0.3 </p>
<p>4x    = AUTOSAR version 4.x.x </p>
<p>SWS </p>
<p>Software Specification </p>
<p>Common CAN </p>
<p>Connect two physical peripheral channels to one CAN bus (to increase </p>
<p>the amount of FullCAN objects) </p>
<p>Hardware Loop  </p>
<p>Check </p>
<p>Timeout monitoring for possible endless loops. </p>
<p>Table 10-2  </p>
<p>Abbreviations </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference    MICROSAR CAN Driver </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 3.00.01 </p>
<p>102 </p>
<p><b>11  Contact </b></p>
<p>Visit our website for more information on </p>
<p> </p>
<p>&gt;   News </p>
<p>&gt;   Products </p>
<p>&gt;   Demo software </p>
<p>&gt;   Support </p>
<p>&gt;   Training data </p>
<p>&gt;   Addresses </p>
<p> </p>
<p><b>www.vector.com </b></p>
<p> </p>
</body>
</html>
{% endraw %}