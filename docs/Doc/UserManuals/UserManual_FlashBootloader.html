---
layout: default
title: UserManual_FlashBootloader
nav_order: 45
parent: Doc
---
{% raw %}
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
     "http://www.w3.org/TR/html4/transitional.dtd">
<html>
<head>

  <meta http-equiv="content-type" content="text/html; charset=utf-8"/>
  <title></title>
  <meta name="generator" content="LibreOffice 24.2.7.2 (Linux)"/>
  <meta name="created" content="00:00:00"/>
  <meta name="changed" content="00:00:00"/>
</head>
<body>
<h1></h1>
<p> </p>
<p>Vector Informatik GmbH, Ingerheimer Str. 24, 70499 Stuttgart </p>
<p>Tel. 0711/80670-0, Fax 0711/80670-399, Email can@vector-informatik.de </p>
<p>Internet http:\\www.vector-informatik.de </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p><b>Flash Bootloader </b></p>
<p>User Manual </p>
<p>(Your First Steps) </p>
<p> </p>
<p> </p>
<p>Version 2.7 </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>User Manual  Flash Bootloader </p>
<p> </p>
<p>1 / 56</p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>CAN</p>
<p>LIN</p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p><b>Authors: </b></p>
<p>Klaus Emmert </p>
<p><b>Version: </b></p>
<p>2.7 </p>
<p><b>Status: </b></p>
<p>released  </p>
<p>(in preparation/completed/inspected/released)</p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>©</p>
<p>2006, Vector Informatik GmbH </p>
<p> </p>
<p>Version: 2.7 </p>
<p> </p>
<p> </p>
<p>based of template version 2.0 </p>
<h1 style="page-break-before:always; "></h1>
<p>User Manual  Flash Bootloader </p>
<p> </p>
<p>2 / 56</p>
<p><b>History </b></p>
<p><b>Author </b></p>
<p><b>Date </b></p>
<p><b>Version </b></p>
<p><b>Remarks </b></p>
<p>Klaus Emmert </p>
<p>2004-07-09 </p>
<p>2.2 </p>
<p>Switch to new Layout Version 2.0 </p>
<p>New symbols </p>
<p>Klaus Emmert </p>
<p>2004-02-09 </p>
<p>2.3 </p>
<p>Changes from Review Ra 2004-</p>
<p>09-20, link labels </p>
<p>Klaus Emmert </p>
<p>2005-03-23 </p>
<p>2.4 </p>
<p>Chapter 3.8 and warning for </p>
<p>startup-codes added </p>
<p>Klaus Emmert </p>
<p>2006-02-06 </p>
<p>2.5 </p>
<p>Change of file structure </p>
<p>Klaus Emmert </p>
<p>2006-08-18 </p>
<p>2.6 </p>
<p>File Structure illustration </p>
<p>Klaus Emmert </p>
<p>2006-09-01 </p>
<p>2.7 </p>
<p>WDtimer and some minor issues </p>
<p>©</p>
<p>2006, Vector Informatik GmbH </p>
<p> </p>
<p>Version: 2.7 </p>
<p> </p>
<p> </p>
<p>based of template version 2.0 </p>
<h1 style="page-break-before:always; "></h1>
<p>User Manual  Flash Bootloader </p>
<p> </p>
<p>3 / 56</p>
<p><b>Motivation For This Work </b></p>
<p>After  a  seemingly  almost  endlessly  long  development  process,  the  software  is </p>
<p>finally finished and ready for the ECU, downloaded one last time, tested and the </p>
<p>ECUs packaged for express delivery the next day.  </p>
<p>Now it‘s 10:00 P.M. </p>
<p>Shortly before quitting time the next business day the telephone rings, and what is </p>
<p>on the display makes your forehead break out in a sweat of alarm!  Errors, nothing </p>
<p>is  working,  says  the  message  from  your  customer.  You  hastily  start  up  another </p>
<p>ECU in the lab and you have to also observe the same result just reported to you. </p>
<p>After searching for a little while you realize that the error is in version management. </p>
<p>You put the correct version together, recompile it, briefly test the result and send </p>
<p>the hex code to your customer, who can now flash the new functioning software via </p>
<p>CAN and diagnostics onto the ECU and as a result, can proceed with the planned </p>
<p>tests without substantial delays. </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p><b>WARNING </b></p>
<p><b>All </b></p>
<p><b>application </b></p>
<p><b>code </b></p>
<p><b>in </b></p>
<p><b>any </b></p>
<p><b>of </b></p>
<p><b>the </b></p>
<p><b>Vector </b></p>
<p><b>User </b></p>
<p><b>Manuals </b></p>
<p><b>is </b></p>
<p><b>for </b></p>
<p><b>training </b></p>
<p><b>purposes only. They are slightly tested and designed to understand the basic </b></p>
<p><b>idea of using a certain component or a set of components. </b></p>
<p>A short story </p>
<p>about flashing</p>
<p>©</p>
<p>2006, Vector Informatik GmbH </p>
<p> </p>
<p>Version: 2.7 </p>
<p> </p>
<p> </p>
<p>based of template version 2.0 </p>
<h1 style="page-break-before:always; "></h1>
<p>User Manual  Flash Bootloader </p>
<p> </p>
<p>4 / 56</p>
<p><b>Contents </b></p>
<p><b>1</b></p>
<p> </p>
<p><b>Welcome to the Flash Bootloader User Manual ............................................. 7</b></p>
<p> </p>
<p>1.1</p>
<p> </p>
<p>Beginners with Flash Bootloader start here ? ..................................... 7</p>
<p> </p>
<p>1.2</p>
<p> </p>
<p>For Advanced Users ........................................................................... 7</p>
<p> </p>
<p>1.3</p>
<p> </p>
<p>Special topics...................................................................................... 7</p>
<p> </p>
<p>1.4</p>
<p> </p>
<p>Documents this one refers to…........................................................... 8</p>
<p> </p>
<p><b>2</b></p>
<p> </p>
<p><b>About This Document ....................................................................................... 9</b></p>
<p> </p>
<p>2.1</p>
<p> </p>
<p>How This Documentation Is Set-Up .................................................... 9</p>
<p> </p>
<p>2.2</p>
<p> </p>
<p>Legend and Explanation of Symbols................................................. 10</p>
<p> </p>
<p><b>3</b></p>
<p> </p>
<p><b>Flashing – An Overall View ............................................................................ 11</b></p>
<p> </p>
<p>3.1</p>
<p> </p>
<p>What Is Flashing? ............................................................................. 11</p>
<p> </p>
<p>3.2</p>
<p> </p>
<p>What Happens During Flashing? ...................................................... 12</p>
<p> </p>
<p>3.3</p>
<p> </p>
<p>What Is The Flash Bootloader?......................................................... 12</p>
<p> </p>
<p>3.4</p>
<p> </p>
<p>Bootloader ......................................................................................... 12</p>
<p> </p>
<p>3.5</p>
<p> </p>
<p>Flash Driver....................................................................................... 13</p>
<p> </p>
<p>3.6</p>
<p> </p>
<p>Flash Tool ......................................................................................... 14</p>
<p> </p>
<p>3.7</p>
<p> </p>
<p>What The Flash Bootloader Does ..................................................... 15</p>
<p> </p>
<p>3.8</p>
<p> </p>
<p>What The Flash Bootloader NOT Does ............................................ 15</p>
<p> </p>
<p><b>4</b></p>
<p> </p>
<p><b>Flashing – A More Detailed View ................................................................... 16</b></p>
<p> </p>
<p>4.1</p>
<p> </p>
<p>The Bootloader Is Always Started First............................................. 16</p>
<p> </p>
<p>4.2</p>
<p> </p>
<p>Flashing After A Reset ...................................................................... 16</p>
<p> </p>
<p>4.3</p>
<p> </p>
<p>Your Application Initiates The Flashing Process............................... 17</p>
<p> </p>
<p>4.3.1</p>
<p> </p>
<p>What might happen? ......................................................................... 17</p>
<p> </p>
<p>4.4</p>
<p> </p>
<p>Handling of the Validation Concepts ................................................. 18</p>
<p> </p>
<p>4.4.1</p>
<p> </p>
<p>Validation Area.................................................................................. 18</p>
<p> </p>
<p>4.4.2</p>
<p> </p>
<p>Access to the Validation Area ........................................................... 18</p>
<p> </p>
<p>4.4.3</p>
<p> </p>
<p>ApplFblIsValidApp ............................................................................. 18</p>
<p> </p>
<p>4.4.4</p>
<p> </p>
<p>ApplFblValidateApp........................................................................... 18</p>
<p> </p>
<p>4.4.5</p>
<p> </p>
<p>ApplFblInvalidateApp ........................................................................ 18</p>
<p> </p>
<p>4.5</p>
<p> </p>
<p>Proposals For Handling The Validation Area .................................... 19</p>
<p> </p>
<p>4.5.1</p>
<p> </p>
<p>Proposal A......................................................................................... 19</p>
<p> </p>
<p>4.5.2</p>
<p> </p>
<p>Proposal B......................................................................................... 20</p>
<p> </p>
<p>4.5.3</p>
<p> </p>
<p>Proposal C ........................................................................................ 22</p>
<p> </p>
<p>4.6</p>
<p> </p>
<p>The Interrupt Vector Tables .............................................................. 23</p>
<p> </p>
<p>4.7</p>
<p> </p>
<p>Label Reference File......................................................................... 24</p>
<p> </p>
<p><b>5</b></p>
<p> </p>
<p><b>FLASHING IN 5 STEPS.................................................................................... 25</b></p>
<p> </p>
<p>©</p>
<p>2006, Vector Informatik GmbH </p>
<p> </p>
<p>Version: 2.7 </p>
<p> </p>
<p> </p>
<p>based of template version 2.0 </p>
<h1 style="page-break-before:always; "></h1>
<p>User Manual  Flash Bootloader </p>
<p> </p>
<p>5 / 56</p>
<p>5.1</p>
<p> </p>
<p>STEP 1 Design The Memory Layout................................................. 26</p>
<p> </p>
<p>5.2</p>
<p> </p>
<p>STEP 2 Write A Test Application ...................................................... 27</p>
<p> </p>
<p>5.3</p>
<p> </p>
<p>STEP 3 Integrate The Bootloader ..................................................... 28</p>
<p> </p>
<p>5.4</p>
<p> </p>
<p>STEP 4 Adapt Your Test Application For The Tester ....................... 29</p>
<p> </p>
<p>5.5</p>
<p> </p>
<p>STEP 5 Download Your Test Application With The Tester ............... 29</p>
<p> </p>
<p><b>6</b></p>
<p> </p>
<p><b> Details of Bootloader Integration Step (STEP 3) ......................................... 30</b></p>
<p> </p>
<p>6.1</p>
<p> </p>
<p>Bootloader STEP 1 – Extract the files to a folder on your pc ............ 31</p>
<p> </p>
<p>6.2</p>
<p> </p>
<p>Bootloader STEP 2 Adjust the marked files to fit your </p>
<p>application ......................................................................................... 34</p>
<p> </p>
<p>6.2.1</p>
<p> </p>
<p>Make… Makefile and make.exe........................................................ 34</p>
<p> </p>
<p>6.2.2</p>
<p> </p>
<p>fbl_cfg.h - The Configuration File For The Flash Bootloader ............ 34</p>
<p> </p>
<p>6.2.3</p>
<p> </p>
<p>FBL_apxx.C ...................................................................................... 36</p>
<p> </p>
<p>6.2.4</p>
<p> </p>
<p>Fbl_vect.c / Applvect.c(.h) - The Interrupt Vector Tables.................. 42</p>
<p> </p>
<p>6.3</p>
<p> </p>
<p>Bootloader STEP 3 Now compile the Flash Bootloader.................... 44</p>
<p> </p>
<p>6.4</p>
<p> </p>
<p>Bootloader STEP 4 Transfer the Bootloader to the target </p>
<p>hardware ........................................................................................... 44</p>
<p> </p>
<p>6.5</p>
<p> </p>
<p>Bootloader STEP 5 Use the Flash Tool to Test the Bootloader........ 44</p>
<p> </p>
<p>6.6</p>
<p> </p>
<p>Bootloader STEP 6 – Test the flashing after a reset......................... 44</p>
<p> </p>
<p>6.7</p>
<p> </p>
<p>Bootloader Step 7 – Make your application ready for the </p>
<p>transition to the Bootloader ............................................................... 45</p>
<p> </p>
<p>6.8</p>
<p> </p>
<p>Bootloader Step 8 – Start Bootloader from your application ............. 45</p>
<p> </p>
<p><b>7</b></p>
<p> </p>
<p><b>Background Information................................................................................. 46</b></p>
<p> </p>
<p>7.1</p>
<p> </p>
<p>The Watchdog................................................................................... 46</p>
<p> </p>
<p>7.1.1</p>
<p> </p>
<p>Initializing The Watchdog .................................................................. 49</p>
<p> </p>
<p>7.2</p>
<p> </p>
<p>Multiple ECU Support........................................................................ 49</p>
<p> </p>
<p>7.3</p>
<p> </p>
<p>Validation Ok – Application Faulty .................................................... 50</p>
<p> </p>
<p>7.4</p>
<p> </p>
<p>FlashSegmentSize ............................................................................ 51</p>
<p> </p>
<p>7.4.1</p>
<p> </p>
<p>Why Does The Tool Have To Know This Block Length? .................. 51</p>
<p> </p>
<p>7.5</p>
<p> </p>
<p>Frequently Asked Questions ............................................................. 52</p>
<p> </p>
<p>7.5.1</p>
<p> </p>
<p>Bootloader Crashes .......................................................................... 52</p>
<p> </p>
<p>7.5.2</p>
<p> </p>
<p>Application Is Not Started.................................................................. 53</p>
<p> </p>
<p>7.5.3</p>
<p> </p>
<p>Bootloader Is Not Started.................................................................. 54</p>
<p> </p>
<p>7.5.4</p>
<p> </p>
<p>The Flash Tool's Error Codes ........................................................... 54</p>
<p> </p>
<p><b>8</b></p>
<p> </p>
<p><b>Index ................................................................................................................... 2</b></p>
<p> </p>
<p> </p>
<p>©</p>
<p>2006, Vector Informatik GmbH </p>
<p> </p>
<p>Version: 2.7 </p>
<p> </p>
<p> </p>
<p>based of template version 2.0 </p>
<h1 style="page-break-before:always; "></h1>
<p>User Manual  Flash Bootloader </p>
<p> </p>
<p>6 / 56</p>
<p><b>Illustrations </b></p>
<p>Figure 1-1</p>
<p> </p>
<p>Manuals and References for the Flash Bootloader...................................... 8</p>
<p> </p>
<p>Figure 3-1</p>
<p> </p>
<p>What Is Flashing ........................................................................................ 11</p>
<p> </p>
<p>Figure 3-2</p>
<p> </p>
<p>Bootloader, Flash Driver And Flash Tool Form The Flash Bootloader ...... 12</p>
<p> </p>
<p>Figure 3-3</p>
<p> </p>
<p>Bootloader And Your Application Never Run Simultaneously.................... 13</p>
<p> </p>
<p>Figure 3-4</p>
<p> </p>
<p>Order And Way Of The Download Of The Software Components............. 14</p>
<p> </p>
<p>Figure 4-1</p>
<p> </p>
<p>Transition Between The Bootloader And Your Application And Vice </p>
<p>Versa .......................................................................................................... 16</p>
<p> </p>
<p>Figure 4-2</p>
<p> </p>
<p>Using A Flag Only In The Validation Area.................................................. 19</p>
<p> </p>
<p>Figure 4-3</p>
<p> </p>
<p>Separate Your Application Into Several Modules....................................... 20</p>
<p> </p>
<p>Figure 4-4</p>
<p> </p>
<p>Using A Validation Function For Validation Your Application..................... 22</p>
<p> </p>
<p>Figure 4-5</p>
<p> </p>
<p>Principle Of The Two Interrupt Vector Tables ............................................ 23</p>
<p> </p>
<p>Figure 5-1</p>
<p> </p>
<p>Basic Memory Layout Of An Application with the Flash Bootloader .......... 26</p>
<p> </p>
<p>Figure 5-2</p>
<p> </p>
<p>The Test Application In The ECU Memory Using Two Interrupt Vector </p>
<p>Tables ........................................................................................................ 27</p>
<p> </p>
<p>Figure 5-3</p>
<p> </p>
<p>Flashing via Flash Tool and OEM-specific Tester...................................... 28</p>
<p> </p>
<p>Figure 6-1</p>
<p> </p>
<p>Details of Bootloader Integration Step (Step 3).......................................... 30</p>
<p> </p>
<p>Figure 6-2</p>
<p> </p>
<p>Function Calling Sequence During Flashing .............................................. 37</p>
<p> </p>
<p>Figure 6-3</p>
<p> </p>
<p>Situation Directly After The Programming Of The Bootloader Together </p>
<p>With The Dummy Application Vector Table ............................................... 42</p>
<p> </p>
<p>Figure 7-1</p>
<p> </p>
<p>Memory Layout Of The Watchdog Trigger Functions ................................ 46</p>
<p> </p>
<p>Figure 7-2</p>
<p> </p>
<p>Functions For Manipulating The Watchdog ............................................... 48</p>
<p> </p>
<p>Figure 7-3</p>
<p> </p>
<p>Modified Function Calling Sequence.......................................................... 50</p>
<p> </p>
<p>Figure 7-4</p>
<p> </p>
<p>Segmenting During Flashing...................................................................... 51</p>
<p> </p>
<p> </p>
<p>©</p>
<p>2006, Vector Informatik GmbH </p>
<p> </p>
<p>Version: 2.7 </p>
<p> </p>
<p> </p>
<p>based of template version 2.0 </p>
<h1 style="page-break-before:always; "></h1>
<p>User Manual  Flash Bootloader </p>
<p> </p>
<p>7 / 56</p>
<p><b>1 </b></p>
<p><b>Welcome to the Flash Bootloader User Manual </b></p>
<p>Chapter 3.1</p>
<p>Chapter 3.3 </p>
<p><b>1.1 </b></p>
<p><b>Beginners with Flash Bootloader start here ?  </b></p>
<p>You need some information about this document?   </p>
<p>Chapter 2</p>
<p>What is Flashing? </p>
<p>What is the Flash Bootloader? </p>
<p> </p>
<p>Chapter 4 </p>
<p><b>1.2 </b></p>
<p><b>For Advanced Users  </b></p>
<p>Chapter 5 </p>
<p>Start reading here. </p>
<p>5 Steps for Flash Bootloader integration. </p>
<p> </p>
<p> </p>
<p><b>1.3 </b></p>
<p><b>Special topics  </b></p>
<p>Why do I need 2 Interrupt Vector Tables? </p>
<p>Chapter 4.6 </p>
<p>How to define my application valid?  </p>
<p>Chapter 4.4 </p>
<p>Validation Ok but application not valid… </p>
<p>Chapter 7.3 </p>
<p>How to handle my watchdog?  </p>
<p>Chapter 7.1 </p>
<p> </p>
<p>©</p>
<p>2006, Vector Informatik GmbH </p>
<p> </p>
<p>Version: 2.7 </p>
<p> </p>
<p> </p>
<p>based of template version 2.0 </p>
<h1 style="page-break-before:always; "></h1>
<p>User Manual  Flash Bootloader </p>
<p> </p>
<p>8 / 56</p>
<p><b>1.4 </b></p>
<p><b>Documents this one refers to… </b></p>
<p></p>
<p> </p>
<p>FlashTool Documentation </p>
<p></p>
<p> </p>
<p>OEM-specific Documentation </p>
<p></p>
<p> </p>
<p>Hardware-specific Documentation </p>
<p> </p>
<p><b>User Manual</b></p>
<p><b>Technical</b></p>
<p><b>Reference</b></p>
<p><b>Hardware</b></p>
<p><b>Technical</b></p>
<p><b>Reference</b></p>
<p><b>OEM</b></p>
<p><b>Flash Tool</b></p>
<p><b>Documentation</b></p>
<p><b>You are here</b></p>
<p>#hw_&lt;xxx&gt;</p>
<p>headline</p>
<p>headline</p>
<p>#oem_&lt;yyy&gt;</p>
<p> </p>
<p>Figure 1-1 </p>
<p>Manuals and References for the Flash Bootloader </p>
<p>The  Flash  Bootloader  can  be  separated  into  a  general  part,  that  is  equal  to  all </p>
<p>Flash Bootloaders and parts that are dependent on the requirements of the OEM </p>
<p>and the features of the hardware. All common topics are described within this user </p>
<p>manual.  Use  the  references  when  indicated  to  figure  out  the  specifics  for  your </p>
<p>Flash Bootloader. </p>
<p>For the OEM-specifics of your Flash Bootloader refer to the: </p>
<p><b>TechnicalReference_FBL_&lt;OEM&gt;.pdf</b>.  The  ID  for  a  reference  to  this  document </p>
<p>looks like: </p>
<p><b>[#oem_&lt;xxx&gt;]. </b></p>
<p>This ID you will find in the corresponding headline there. </p>
<p>For the hardware-specifics of your Flash Bootloader refer to the : </p>
<p><b>TechnicalReference_FBL_&lt;hardware&gt;.pdf</b>. </p>
<p>The </p>
<p>ID </p>
<p>for </p>
<p>a </p>
<p>reference </p>
<p>to </p>
<p>this </p>
<p>document looks like: </p>
<p><b>[#hw_&lt;yyy&gt;]. </b></p>
<p>This ID you will find in the corresponding headline </p>
<p>there.</p>
<p> </p>
<p> </p>
<p>©</p>
<p>2006, Vector Informatik GmbH </p>
<p> </p>
<p>Version: 2.7 </p>
<p> </p>
<p> </p>
<p>based of template version 2.0 </p>
<h1 style="page-break-before:always; "></h1>
<p>User Manual  Flash Bootloader </p>
<p> </p>
<p>9 / 56</p>
<p><b>2 </b></p>
<p><b>About This Document </b></p>
<p>This  document  gives  you  an  understanding  of  the  Flash  Bootloader.  You  will </p>
<p>receive general information, a step-by-step tutorial to get the Flash Bootloader up </p>
<p>and  running,  details  regarding  diagnostic  services,  directions  to  implement  the </p>
<p>watchdog, and instructions regarding the Flash Tool. </p>
<p>This is the general Flash Bootloader Document, independent of oem-specific settings </p>
<p>or hardware. For more information about OEM solutions or hardware dependencies </p>
<p>refer to those specific documents. </p>
<p> </p>
<p><b>2.1 </b></p>
<p><b>How This Documentation Is Set-Up </b></p>
<p><b>Chapter </b></p>
<p><b>Content </b></p>
<p><b>Chapter 1 </b></p>
<p>The welcome page allows easy navigation throughout the document. </p>
<p><b>Chapter 2 </b></p>
<p>Contains some formal information about this document, and explanation of legends </p>
<p>and symbols. </p>
<p><b>Chapter 3 </b></p>
<p>Provides a brief introduction to flashing and the different parts that make up the Flash </p>
<p>Bootloader. </p>
<p><b>Chapter 4 </b></p>
<p>Provides  details  about  the  flash  process,  states  the  validation  concept,  and  the </p>
<p>implementation of the two interrupt vector tables. </p>
<p><b>Chapter 5 </b></p>
<p>Describes the five basic steps to integrate the Flash Bootloader, and download the </p>
<p>application using the Vector Flash Tool. </p>
<p><b>Chapter 6 </b></p>
<p>Describes how to download the application using the OEM-Specific flash tool. </p>
<p><b>Chapter 7 </b></p>
<p>Lists some common problems encountered while integrating the bootloader and their </p>
<p>proper solution</p>
<p>.</p>
<p> </p>
<p> </p>
<p>©</p>
<p>2006, Vector Informatik GmbH </p>
<p> </p>
<p>Version: 2.7 </p>
<p> </p>
<p> </p>
<p>based of template version 2.0 </p>
<h1 style="page-break-before:always; "></h1>
<p>User Manual  Flash Bootloader </p>
<p> </p>
<p>10 / 56</p>
<p><b>2.2 </b></p>
<p><b>Legend and Explanation of Symbols </b></p>
<p>You  find  these  symbols  at  the  right  side  of  the  document.  They  indicate  special </p>
<p>areas in the text. Here is a list of their meaning. </p>
<p>These areas </p>
<p>to the right of </p>
<p>the text </p>
<p>contain brief </p>
<p>items of </p>
<p>information </p>
<p>that will </p>
<p>facilitate your </p>
<p>search for </p>
<p>specific </p>
<p>topics. </p>
<p><b>Symbol </b></p>
<p><b>Meaning </b></p>
<p> </p>
<p>The building bricks mark examples. </p>
<p> </p>
<p>You will find key words and information in short sentences in the margin. This will </p>
<p>greatly simplify your search for topics. </p>
<p>Comments </p>
<p>and </p>
<p>explanation</p>
<p> </p>
<p>The footprints will lead you through the steps until you can use the described Flash </p>
<p>Bootloader. </p>
<p> </p>
<p>There is something you should take care about. </p>
<p> </p>
<p>Useful and additional information is displayed in areas with this symbol. </p>
<p> </p>
<p>This file you are allowed to edit on demand. </p>
<p> </p>
<p>This file you must not edit at all.  </p>
<p> </p>
<p>This indicates an area dealing with frequently asked questions (FAQ). </p>
<p> </p>
<p>©</p>
<p>2006, Vector Informatik GmbH </p>
<p> </p>
<p>Version: 2.7 </p>
<p> </p>
<p> </p>
<p>based of template version 2.0 </p>
<h1 style="page-break-before:always; "></h1>
<p>User Manual  Flash Bootloader </p>
<p> </p>
<p>11 / 56</p>
<p><b>3 </b></p>
<p><b>Flashing – An Overall View </b></p>
<p><b>3.1 </b></p>
<p><b>What Is Flashing? </b></p>
<p>During the flashing process an application (or a part of it), which must be available </p>
<p>in hex format (using the Flash Tool), is transferred into the ECU‘s memory. This </p>
<p>transfer is done via a bus protocol like CAN, LIN, FlexRay, etc.  </p>
<p>The Flash </p>
<p>Bootloader </p>
<p>downloads </p>
<p>the </p>
<p>application as </p>
<p>a hex file to </p>
<p>the ECU via </p>
<p>CAN. </p>
<p> </p>
<p> </p>
<p></p>
<p><b>F  l  a  s  h    M  e  m  o  r  y</b></p>
<p><b>R  A  M</b></p>
<p><b>F l a s h  M e m o r y</b></p>
<p><b>Memory Map</b></p>
<p>Application</p>
<p><b>Application.hex</b></p>
<p><b>.bin</b></p>
<p><b>.mot</b></p>
<p><b>...</b></p>
<p>flashing</p>
<p>[CAN, LIN, FlexRay, ...]</p>
<p> </p>
<p>PC or Laptop, </p>
<p>CAN Card </p>
<p>and the Flash </p>
<p>Tool – this is </p>
<p>all you need </p>
<p>for flashing. </p>
<p>Figure 3-1 </p>
<p>What Is Flashing </p>
<p> </p>
<p>To  transfer  your  application  to  the  target  platform  you  simply  need  the  Flash </p>
<p>Bootloader,  a PC or a laptop, a CAN card and the Flash Tool.  </p>
<p>Using  an  emulator,  a  BDM  tool,  or  the  like  to  perform  the  flashing  in  an  already </p>
<p>built-in ECU would be expensive. In addition, the ECU’s hardware interface for the </p>
<p>BDM or emulator is not always accessible. </p>
<p>The interface is based on a CAN bus as part of the Physical Layer, the Transport </p>
<p>Protocol, and on KWP2000 for the specification of diagnostic services.  </p>
<p>For flash data exchange between your new node and the tool you need two CAN </p>
<p>messages, one for request and one for response. </p>
<p>©</p>
<p>2006, Vector Informatik GmbH </p>
<p> </p>
<p>Version: 2.7 </p>
<p> </p>
<p> </p>
<p>based of template version 2.0 </p>
<h1 style="page-break-before:always; "></h1>
<p>User Manual  Flash Bootloader </p>
<p> </p>
<p>12 / 56</p>
<p><b>3.2 </b></p>
<p><b>What Happens During Flashing? </b></p>
<p>The Flash Driver (flash algorithms) is downloaded via the bus protocol. Afterwards </p>
<p>the application is downloaded and written (flashed) into the Flash Memory (using </p>
<p>the Flash Driver). </p>
<p><b>3.3 </b></p>
<p><b>What Is The Flash Bootloader? </b></p>
<p>The  Flash  Bootloader  is  a  combination  of  embedded  software  and  PC  tool, </p>
<p>designed to do the flashing of the ECU software via a bus protocol (e.g. CAN). </p>
<p>Therefore the Flash Bootloader is divided up into 3 parts, the Bootloader, the Flash </p>
<p>Driver and the Flash Tool. </p>
<p></p>
<p>Flash Programming</p>
<p>CAN<i>fbl</i></p>
<p>Application</p>
<p>Bootloader</p>
<p>Flash Driver</p>
<p>Interrupt Vector Table</p>
<p>[FBL]</p>
<p>Interrupt Vector Table</p>
<p>[Application]</p>
<p>Interrupt Vector Table</p>
<p>[Application]</p>
<p>The <b>Flash Driver</b> downloads the </p>
<p>executable via CAN/LIN in </p>
<p>connection with the Flashtool. </p>
<p>The <b>Flashtool</b> is an easy to use PC tool </p>
<p>and controls the download of your </p>
<p>application (as executable)</p>
<p>via a PC card, e.g. CANcardXL or CAN-</p>
<p>AC2-PCI. </p>
<p>Flash</p>
<p>Tool</p>
<p>The <b>Bootloader</b> contains basic CAN </p>
<p>communication, a Transport Protocol and </p>
<p>Diagnostics (KWP2000), both code optimized </p>
<p>to use minimum memory.</p>
<p>CAN</p>
<p>LIN</p>
<p><b>F  l  a  s  h    M  e  m  o  r  y</b></p>
<p><b>R  A  M</b></p>
<p><b>F l a s h  M e m o r y</b></p>
<p> </p>
<p>Figure 3-2 </p>
<p>Bootloader, Flash Driver And Flash Tool Form The Flash Bootloader </p>
<p><b>3.4 </b></p>
<p><b>Bootloader </b></p>
<p>The Bootloader is a stand-alone program. It is compiled, linked, and downloaded to </p>
<p>the  ECU  separately  from  your  application.  The  Bootloader  and  your  application </p>
<p>never run simultaneously. </p>
<p>The Bootloader uses Flash memory, in the protected area of the ECU. If your ECU </p>
<p>does not support such a hardware protection, the Bootloader will protect itself from </p>
<p>being overwritten.  </p>
<p> </p>
<p>©</p>
<p>2006, Vector Informatik GmbH </p>
<p> </p>
<p>Version: 2.7 </p>
<p> </p>
<p> </p>
<p>based of template version 2.0 </p>
<h1 style="page-break-before:always; "></h1>
<p>User Manual  Flash Bootloader </p>
<p> </p>
<p>13 / 56</p>
<p><b>F  l  a  s  h    M  e  m  o  r  y</b></p>
<p><b>R  A  M</b></p>
<p><b>F l a s h  M e m o r y</b></p>
<p><b>Memory Map</b></p>
<p><b>F  l  a  s  h    M  e  m  o  r  y</b></p>
<p><b>R  A  M</b></p>
<p><b>F l a s h  M e m o r y</b></p>
<p><b>Memory Map</b></p>
<p>Application</p>
<p><b>IsValid</b></p>
<p>⏐</p>
<p><b>Invalidate</b></p>
<p>⏐</p>
<p><b>Validate</b></p>
<p><b>Bootloader</b></p>
<p>Transport Protocol,</p>
<p>KWP2000-Services,</p>
<p>CAN Driver</p>
<p>Application</p>
<p>Data</p>
<p><b>F  l  a  s  h    M  e  m  o  r  y</b></p>
<p><b>R  A  M</b></p>
<p><b>F l a s h  M e m o r y</b></p>
<p><b>Memory Map</b></p>
<p><b>F  l  a  s  h    M  e  m  o  r  y</b></p>
<p><b>R  A  M</b></p>
<p><b>F l a s h  M e m o r y</b></p>
<p><b>Memory Map</b></p>
<p><b>IsValid</b></p>
<p>⏐</p>
<p><b>Invalidate</b></p>
<p>⏐</p>
<p><b>Validate</b></p>
<p><b>Bootloader</b></p>
<p>Transport Protocol,</p>
<p>KWP2000-Services,</p>
<p>CAN Driver</p>
<p><b>Flash Driver</b></p>
<p><b>Application.hex</b></p>
<p>Application is running                   Flash Bootloader is running</p>
<p>flashing</p>
<p> </p>
<p>Figure 3-3 </p>
<p>Bootloader And Your Application Never Run Simultaneously  </p>
<p>The  Bootloader  is  transferred  to  the  target  platform  via  a  Flash  programmer  or </p>
<p>burner, which is hardware dependent (It is not downloaded over CAN). </p>
<p><b>3.5 </b></p>
<p><b>Flash Driver </b></p>
<p>The  Flash  Driver  (actual  flash  algorithm)  is  the  hardware  dependent  code  for </p>
<p>performing the flash functions. </p>
<p>In most cases, programming flash memory from flash is not possible. Therefore the </p>
<p>Flash Driver is downloaded and executed into RAM to allow programming of the </p>
<p>application. </p>
<p>The advantage of downloading the flash algorithm into RAM is that updates to the </p>
<p>flash algorithms are possible without the need to reprogram the primary bootloader. </p>
<p>The  algorithm  is  cleared  from  RAM  upon  completion  of  the  download  to  avoid </p>
<p>accidental calls to the flash functions while in the application. </p>
<p>In special cases the flash algorithms are kept in flash memory and copied to RAM </p>
<p>when needed. Of course the possibility of changing the flash algorithms is no longer </p>
<p>available  when  this  configuration  is  used.  Moreover,  there  is  a  risk  that  the  flash </p>
<p>memory  will  be  unintentionally  erased  from  an  accidental  call  to  these  functions. A </p>
<p>remedy to correct this would be to encrypt the corresponding program code, such as </p>
<p>e.g. an XOR or the like.  </p>
<p>Reasons for </p>
<p>Flash Driver to </p>
<p>run in RAM: </p>
<p>Physical reasons </p>
<p>Protection </p>
<p>against a faulty </p>
<p>call deleting the </p>
<p>flash  </p>
<p>Save ROM </p>
<p>memory </p>
<p>Easy to make </p>
<p>updates. </p>
<p>As the Bootloader </p>
<p>downloads data </p>
<p>via CAN, it </p>
<p>contains a CAN </p>
<p>Driver and a </p>
<p>Transport </p>
<p>Protocol. </p>
<p>©</p>
<p>2006, Vector Informatik GmbH </p>
<p> </p>
<p>Version: 2.7 </p>
<p> </p>
<p> </p>
<p>based of template version 2.0 </p>
<h1 style="page-break-before:always; "></h1>
<p>User Manual  Flash Bootloader </p>
<p> </p>
<p>14 / 56</p>
<p><b>3.6 </b></p>
<p><b>Flash Tool </b></p>
<p>The Flash Tool is a Windows™ based PC tool that controls the download of the </p>
<p>application.  </p>
<p>The Flash Tool reads the compiled and linked application data (Motorola-S or Intel-</p>
<p>Hex format), triggers and controls the flash process, transfers the data via the bus </p>
<p>protocol (e.g. CAN) and verifies this process via a checksum. </p>
<p>To  do  the  download  you  additionally  need  a  CAN  card  (CANcardXL,  CAN  AC2-</p>
<p>PCI) to connect your hardware to the PC.  </p>
<p> </p>
<p>The following figure shows the Bootloader, the Flash Driver, the application, and </p>
<p>how they get in the memory of the controller. As the Bootloader is the component </p>
<p>to  enable  the  download  of  the  Flash  Driver  and  the  application,  it  cannot  be </p>
<p>transferred by itself. This job must be done with a suitable programmer or burner </p>
<p>(development environment).  </p>
<p><b>F  l  a  s  h    M  e  m  o  r  y</b></p>
<p><b>R  A  M</b></p>
<p><b>F l a s h  M e m o r y</b></p>
<p><b>Memory Map</b></p>
<p><b>F  l  a  s  h    M  e  m  o  r  y</b></p>
<p><b>R  A  M</b></p>
<p><b>F l a s h  M e m o r y</b></p>
<p><b>Memory Map</b></p>
<p>Application</p>
<p><b>Interrupt Vector Table</b></p>
<p><b>[FBL]</b></p>
<p><b>IsValid</b></p>
<p>⏐</p>
<p><b>Invalidate</b></p>
<p>⏐</p>
<p><b>Validate</b></p>
<p><b>Bootloader</b></p>
<p>Transport Protocol,</p>
<p>KWP2000-Services,</p>
<p>CAN Driver</p>
<p><b>Interrupt Vector Table</b></p>
<p><b>Application]</b></p>
<p><b>Validation Area</b></p>
<p><b>Flash Driver</b></p>
<p>Programmer</p>
<p>Burner</p>
<p>CAN, LIN</p>
<p>FlexRay, ...</p>
<p>CAN, LIN</p>
<p>FlexRay, ...</p>
<p>1</p>
<p>2</p>
<p>3</p>
<p> </p>
<p>Figure 3-4 </p>
<p>Order And Way Of The Download Of The Software Components </p>
<p>The numbers in the figure show the download order, Bootloader first, then the Flash </p>
<p>Driver to be able to flash the application. </p>
<p> </p>
<p>©</p>
<p>2006, Vector Informatik GmbH </p>
<p> </p>
<p>Version: 2.7 </p>
<p> </p>
<p> </p>
<p>based of template version 2.0 </p>
<h1 style="page-break-before:always; "></h1>
<p>User Manual  Flash Bootloader </p>
<p> </p>
<p>15 / 56</p>
<p><b>3.7 </b></p>
<p><b>What The Flash Bootloader Does </b></p>
<p></p>
<p> </p>
<p>Initializes the CAN controller  </p>
<p></p>
<p> </p>
<p>Sends diagnostic messages via CAN </p>
<p></p>
<p> </p>
<p>Receives diagnostic messages via CAN </p>
<p></p>
<p> </p>
<p>Erases and programs the flash memory </p>
<p> </p>
<p><b>3.8 </b></p>
<p><b>What The Flash Bootloader NOT Does </b></p>
<p>It is no “Ready-to-use” program: </p>
<p></p>
<p> </p>
<p>Adaptations of callback functions, startup / initialization is necessary </p>
<p></p>
<p> </p>
<p>Adaptation to runtime environment and specific hardware requirements are </p>
<p>necessary </p>
<p> </p>
<p>©</p>
<p>2006, Vector Informatik GmbH </p>
<p> </p>
<p>Version: 2.7 </p>
<p> </p>
<p> </p>
<p>based of template version 2.0 </p>
<h1 style="page-break-before:always; "></h1>
<p>User Manual  Flash Bootloader </p>
<p> </p>
<p>16 / 56</p>
<p><b>4 </b></p>
<p><b>Flashing – A More Detailed View </b></p>
<p>The Flash </p>
<p>Bootloader is </p>
<p>called after a </p>
<p>reset or </p>
<p>directly from </p>
<p>your </p>
<p>application.  </p>
<p><b>4.1 </b></p>
<p><b>The Bootloader Is Always Started First </b></p>
<p>As you now know, on the one hand the Bootloader resides in the protected area </p>
<p>and is always resident on the ECU. On the other hand it is not guaranteed that a </p>
<p>valid, executable application is also present in the ECU. This is the reason why the </p>
<p>Bootloader is always executed first after a reset. The decision is then made to start </p>
<p>the application or to stay in the Bootloader. </p>
<p> </p>
<p> </p>
<p><b>Reset</b></p>
<p> </p>
<p><b>Flash Process</b></p>
<p><b>Application</b></p>
<p> </p>
<p><b>Bootloader</b></p>
<p> </p>
<p><b>Application Valid? </b></p>
<p><b>Dependent on OEM</b></p>
<p><b>Wait for Diagnostic Service </b></p>
<p><b>to start Flash</b></p>
<p>yes</p>
<p> </p>
<p>no</p>
<p> </p>
<p>(ApplFblIsValidApp)</p>
<p>OEM specific</p>
<p>wait time</p>
<p><b>Invalidate Application? </b></p>
<p>(ApplFblInvalidateApp)</p>
<p><b>Validate Application? </b></p>
<p>(ApplFblValidateApp)</p>
<p> </p>
<p>Figure 4-1 </p>
<p>Transition Between The Bootloader And Your Application And Vice Versa </p>
<p>The Bootloader can be made to start in different ways, from your application and </p>
<p>after a reset. </p>
<p><b>4.2 </b></p>
<p><b>Flashing After A Reset </b></p>
<p>The Flash Bootloader is executed always first after a reset. At this point in time the </p>
<p>bootloader  has  to  determine  if  a  valid  application  has  been  flashed.  This  test  is </p>
<p>done through the use of the <b>ApplFblIsValidApp </b>function.  </p>
<p>You will find some example strategies of how an application can be set to valid or </p>
<p>invalid in chapter 4.5. </p>
<p>The return value of the function <b>ApplFblIsValidApp  </b>(see Figure 4-1) is used to </p>
<p>decide whether the process should branch into the application or if the ECU should </p>
<p>©</p>
<p>2006, Vector Informatik GmbH </p>
<p> </p>
<p>Version: 2.7 </p>
<p> </p>
<p> </p>
<p>based of template version 2.0 </p>
<h1 style="page-break-before:always; "></h1>
<p>User Manual  Flash Bootloader </p>
<p> </p>
<p>17 / 56</p>
<p>remain in the Flash Bootloader. The code in this function and the way you decide </p>
<p>whether the application is valid or not, is up to you.  </p>
<p>After a reset </p>
<p>the </p>
<p><b>ApplFblIsVali</b></p>
<p><b>dApp</b></p>
<p> function </p>
<p>decides </p>
<p>whether to</p>
<p> </p>
<p>branch into </p>
<p>the </p>
<p>application. </p>
<p>If  the  application  area  is  blank  or  the  code  is  faulty,  the  Bootloader  waits  for  a </p>
<p>Diagnostic CAN message to start the flash process, i.e. the Flash Driver is loaded </p>
<p>into </p>
<p>the </p>
<p>ECU‘s </p>
<p>RAM </p>
<p>memory </p>
<p>and </p>
<p>started. </p>
<p>Now </p>
<p>the </p>
<p>application </p>
<p>is </p>
<p>being </p>
<p>downloaded, which is the actual flash process. </p>
<p>The </p>
<p>application </p>
<p>is </p>
<p>connected </p>
<p>to </p>
<p>the </p>
<p>Flash </p>
<p>Bootloader </p>
<p>via </p>
<p>three </p>
<p>functions </p>
<p><b>ApplFblIsValidApp</b>, </p>
<p><b>ApplFblValidateApp </b></p>
<p>and </p>
<p><b>ApplFblInvalidateApp. </b></p>
<p>These </p>
<p>functions are to manipulate the Validation Area.  </p>
<p>The  names  of  the  functions  ApplFblValidateApp  and  ApplFblInvalidateApp  can </p>
<p>vary slightly for some OEMs. Please refer to your OEM-specific Documentation for </p>
<p>more detailed information </p>
<p><b>[#oem_valfunc</b></p>
<p>]. </p>
<p>In the following, these three functions are abbreviated sometimes only with IsValid, </p>
<p>Validate  and  Invalidate.  These  abbreviations  are  found  in  most  of  the  following </p>
<p>figures. </p>
<p><b>4.3 </b></p>
<p><b>Your Application Initiates The Flashing Process </b></p>
<p>The other way to start the flashing process is the one via your application and its </p>
<p>diagnostics.  </p>
<p>Before the Flash Bootloader manipulates data in the application area the function </p>
<p><b>ApplFblInvalidateApp </b> is  called  to  set  the  Validation  Area  to  invalid.  Then  the </p>
<p>Flash Bootloader downloads the new application (the corresponding hex file) and </p>
<p>executes </p>
<p>a </p>
<p>reset </p>
<p>or </p>
<p>starts </p>
<p>the </p>
<p>application </p>
<p>directly </p>
<p>(depending </p>
<p>on </p>
<p>the </p>
<p>OEM </p>
<p><b>[#oem_start]</b></p>
<p>).  Before  starting  the  application,  the  function <b> ApplFblValidateApp </b></p>
<p>validates the application again.  </p>
<p>Before the beginning of flashing, the application must be set to invalid. This prevents  </p>
<p>starting a partially flashed application if the flash process failed or was interrupted.  </p>
<p><b>4.3.1 </b></p>
<p><b>What might happen? </b></p>
<p>Imagine  your  validity  check  results  in  a  valid  application  but  it  is  actually  faulty. </p>
<p>Every reset leads in the application that is not working properly and the watchdog </p>
<p>will provoke a reset again. Now the software is in an endless loop.  </p>
<p>In  this  case  it  is  not  possible  to  flash  the  application  again.  See  an  optional </p>
<p>selectable solution to this problem in the chapter 7.3 (Validation ok – Application </p>
<p>Faulty). </p>
<p>©</p>
<p>2006, Vector Informatik GmbH </p>
<p> </p>
<p>Version: 2.7 </p>
<p> </p>
<p> </p>
<p>based of template version 2.0 </p>
<h1 style="page-break-before:always; "></h1>
<p>User Manual  Flash Bootloader </p>
<p> </p>
<p>18 / 56</p>
<p><b>4.4 </b></p>
<p><b>Handling of the Validation Concepts </b></p>
<p>The concept for the flash mechanism is designed to allow maximum flexibility as </p>
<p>well as a very easy implementation. The main thing you have to take care for is to </p>
<p>call  the  application  only  if  there  is  a  valid  version  flashed.  The  manner  you </p>
<p>recognize a valid version is up to you and realized in the so-called Validation Area.  </p>
<p><b>4.4.1 </b></p>
<p><b>Validation Area </b></p>
<p>In this area you can store the indicators for a valid application. This can be a simple </p>
<p>flag that indicates valid or even code for checking validity of the application. In the </p>
<p>latter case the <b>ApplFblIsValidApp </b>should check this function before calling it. </p>
<p><b>4.4.2 </b></p>
<p><b>Access to the Validation Area </b></p>
<p>The  Bootloader  provides  3  functions  to  access  the  validation  area  as  mentioned </p>
<p>just before. The functions reside in the Bootloader and the coding has to be done </p>
<p>by you. The functions are:  </p>
<p><b>4.4.3 </b></p>
<p><b>ApplFblIsValidApp </b></p>
<p>This function checks the validity of the application. The return value decides about </p>
<p>the further actions (see Figure 4-1).  </p>
<p>Since this function is called on every Reset, it is recommended to simply check a flag </p>
<p>previously set. This speeds up the restart time. </p>
<p><b>4.4.4 </b></p>
<p><b>ApplFblValidateApp </b></p>
<p>Use the </p>
<p>following </p>
<p>proposals to </p>
<p>get a little </p>
<p>comfortable </p>
<p>with the </p>
<p>possibilities of </p>
<p>configuration </p>
<p>arising with </p>
<p>this concept. </p>
<p>This  function  signs  the  application  as  valid  by  accessing  the    Validation  Area </p>
<p>directly. After the flash process the function <b>ApplFblValidateApp </b>is called to check </p>
<p>the validity of the flashed application and to set the indicators (e.g. a Flag, a certain </p>
<p>memory location etc.). The indicators are utilized on reset by the IsValid function. </p>
<p><b>4.4.5 </b></p>
<p><b>ApplFblInvalidateApp </b></p>
<p>This  function  is  called  before  erasing  the  flash  memory.  Herein  you  reset  your </p>
<p>indicators and mark the application as invalid in order to avoid the case where a </p>
<p>possible reset or error while flashing occurs without invalidating the partially erased </p>
<p>or programmed application. </p>
<p>The  implementation of the validation function is application-specific, however, once a </p>
<p>solution </p>
<p>is </p>
<p>implemented </p>
<p>it </p>
<p>cannot </p>
<p>be </p>
<p>changed </p>
<p>unless </p>
<p>the </p>
<p>Bootloader </p>
<p>is </p>
<p>re-</p>
<p>programmed.</p>
<p>  </p>
<p> </p>
<p>©</p>
<p>2006, Vector Informatik GmbH </p>
<p> </p>
<p>Version: 2.7 </p>
<p> </p>
<p> </p>
<p>based of template version 2.0 </p>
<h1 style="page-break-before:always; "></h1>
<p>User Manual  Flash Bootloader </p>
<p> </p>
<p>19 / 56</p>
<p><b>4.5 </b></p>
<p><b>Proposals For Handling The Validation Area </b></p>
<p>The following three examples are examples of how you can deal with the validation </p>
<p>concept  offered  by  the  Flash  Bootloader.  Before  starting  to  develop  your  own </p>
<p>strategy based on the concepts mentioned here, please refer to the OEM-specific </p>
<p>Documentation [</p>
<p><b>#oem_valid</b></p>
<p>] in case your OEM wants you to do this in a predefined </p>
<p>manner. </p>
<p><b>4.5.1 </b></p>
<p><b>Proposal A </b></p>
<p>In this concept the validation area is just a flag. This is the simplest way to realize </p>
<p>the validation concept:  </p>
<p><b>F  l  a  s  h    M  e  m  o  r  y</b></p>
<p><b>R  A  M</b></p>
<p><b>F l a s h  M e m o r y</b></p>
<p><b>Memory Map</b></p>
<p><b>F  l  a  s  h    M  e  m  o  r  y</b></p>
<p><b>R  A  M</b></p>
<p><b>F l a s h  M e m o r y</b></p>
<p><b>Memory Map</b></p>
<p>Application</p>
<p><b>Interrupt Vector Table</b></p>
<p><b>[FBL]</b></p>
<p><b>IsValid</b></p>
<p>⏐</p>
<p><b>Invalidate</b></p>
<p>⏐</p>
<p><b>Validate</b></p>
<p><b>Bootloader</b></p>
<p>Transport Protocol,</p>
<p>KWP2000-Services,</p>
<p>CAN Driver</p>
<p><b>Interrupt Vector Table</b></p>
<p><b>[Application]</b></p>
<p><b>FLAG  0 invalid, 1 vaild</b></p>
<p><b>Flash Driver</b></p>
<p> </p>
<p>Figure 4-2 </p>
<p>Using A Flag Only In The Validation Area </p>
<p>The  code  in  the  IsValid  function  has  to  know  the  location  of  the  flag  in  the </p>
<p>Validation  Area.  After  a  reset,  the  content  of  this  flag  shows  the  validity  of  the </p>
<p>application.  If  you  start  flashing  via  CAN  the  function  “Invalidate”  clears  the  flag </p>
<p>before  erasing.  After  flashing,  the  function  “Validate”  sets  the  flag.  Then  after  a </p>
<p>reset,  the  “IsValid”  function  recognizes  the  flag  to  be  set  and  returns  a  positive </p>
<p>value. The application is valid and can be executed.  </p>
<p>If you can guarantee that the flag (or byte) is the first byte to be erased and the last </p>
<p>byte  to  be  written  while  programming,  you  may  leave  the  Invalidate  and  Validate </p>
<p>functions empty.  </p>
<p> </p>
<p>Make sure that the valid indicator differs from the blank, non-existing flash contents.  </p>
<p> </p>
<p>©</p>
<p>2006, Vector Informatik GmbH </p>
<p> </p>
<p>Version: 2.7 </p>
<p> </p>
<p> </p>
<p>based of template version 2.0 </p>
<h1 style="page-break-before:always; "></h1>
<p>User Manual  Flash Bootloader </p>
<p> </p>
<p>20 / 56</p>
<p><b>4.5.2 </b></p>
<p><b>Proposal B  </b></p>
<p>Based upon this concept you can separate the application into separate sections. </p>
<p>See  the  figure  below  for  the  memory  mapping.  The  parts  of  the  application  are </p>
<p>named as <b>Module n</b>. Every module needs a Validation Area of its own.  </p>
<p><b>F  l  a  s  h    M  e  m  o  r  y</b></p>
<p><b>Memory Map</b></p>
<p><b>F  l  a  s  h    M  e  m  o  r  y</b></p>
<p><b>R  A  M</b></p>
<p><b>F l a s h  M e m o r y</b></p>
<p><b>Memory Map</b></p>
<p>Appl Module 1</p>
<p>Validation Area 1</p>
<p><b>R  A  M</b></p>
<p><b>F l a s h  M e m o r y</b></p>
<p><b>Interrupt Vector Table</b></p>
<p><b>[FBL]</b></p>
<p><b>IsValid</b></p>
<p>⏐</p>
<p><b>Invalidate</b></p>
<p>⏐</p>
<p><b>Validate</b></p>
<p><b>Bootloader</b></p>
<p>Transport Protocol,</p>
<p>KWP2000-Services,</p>
<p>CAN Driver</p>
<p><b>Interrupt Vector Table</b></p>
<p><b>[Application]</b></p>
<p><b>Appl Module Table</b></p>
<p>Info about Validation Areas </p>
<p>Checkbyte</p>
<p><b>Flash Driver</b></p>
<p><b>...</b></p>
<p>Appl Module 2</p>
<p>Appl Module 3</p>
<p>Validation Area 2</p>
<p>Validation Area 3</p>
<p> </p>
<p>Figure 4-3 </p>
<p>Separate Your Application Into Several Modules </p>
<p>To know the locations of the modules, their size and the location of their Validation </p>
<p>Area you should add a Module Table. This table contains the latter information and </p>
<p>enables the access to the single Validation Areas of the modules. The access is </p>
<p>done via the known functions IsValid, Validate, and Invalidate. </p>
<p>Before  you  use  the  Module  Table,  make  sure  this  information  is  in  the  memory. </p>
<p>Use e.g. a check byte to ensure this. </p>
<p>The location of this check byte depends on the order of erasing and writing to the </p>
<p>flash  memory.  It  should  be  erased  as  the  first  byte  in  this  module  table  area  and </p>
<p>written only if the complete module table area is valid.  </p>
<p>©</p>
<p>2006, Vector Informatik GmbH </p>
<p> </p>
<p>Version: 2.7 </p>
<p> </p>
<p> </p>
<p>based of template version 2.0 </p>
<h1 style="page-break-before:always; "></h1>
<p>User Manual  Flash Bootloader </p>
<p> </p>
<p>21 / 56</p>
<p> </p>
<p><b>4.5.2.1 </b></p>
<p><b>The Module Table </b></p>
<p>The file FBL_MTAB contains the flash-erase sector table (more about the interrupt </p>
<p>vector  tables  in  the  following).  Whenever  the  sector  selectable  erase  service  is </p>
<p>called, the Bootloader scans this table to get the address and length information of </p>
<p>the sector that has to be erased. </p>
<p>The  flash  erase  sector  table  is  not  required  if  the  Bootloader  configuration  has </p>
<p>been optimized for download of only one module. </p>
<p>The  location  of  FBL_MTAB  provides  great  flexibility.  It  is  possible  to  change  the </p>
<p>memory  size  of  the  modules,  without  modifications  of  the  Bootloader.  To  extend </p>
<p>the number of modules you can add more entries to the table. </p>
<p>If it is not feasible or necessary to change the flash erase table, this table could </p>
<p>also be compiled and linked into the protected area of the Bootloader. This has the </p>
<p>advantage that this table cannot be erased.  </p>
<p>©</p>
<p>2006, Vector Informatik GmbH </p>
<p> </p>
<p>Version: 2.7 </p>
<p> </p>
<p> </p>
<p>based of template version 2.0 </p>
<h1 style="page-break-before:always; "></h1>
<p>User Manual  Flash Bootloader </p>
<p> </p>
<p>22 / 56</p>
<p><b>4.5.3 </b></p>
<p><b>Proposal C </b></p>
<p>The last example uses a validation function instead of just flags as shown in the </p>
<p>two examples above.  </p>
<p>This  validation  function  resides  in  the  application  and  is  compiled  and  linked </p>
<p>together  with  the  application.  Therefore  you  should  take  care  before  calling  this </p>
<p>function, that the code has been flashed correctly. For this demand you can use a </p>
<p>check byte as shown in the Proposal B. </p>
<p><b>F  l  a  s  h    M  e  m  o  r  y</b></p>
<p><b>Memory Map</b></p>
<p><b>F  l  a  s  h    M  e  m  o  r  y</b></p>
<p><b>R  A  M</b></p>
<p><b>F l a s h  M e m o r y</b></p>
<p><b>Memory Map</b></p>
<p><b>R  A  M</b></p>
<p><b>F l a s h  M e m o r y</b></p>
<p><b>Validation Function</b></p>
<p><b>Flash Driver</b></p>
<p><b>...</b></p>
<p><b>Interrupt Vector Table</b></p>
<p><b>[FBL]</b></p>
<p><b>IsValid</b></p>
<p>⏐</p>
<p><b>Invalidate</b></p>
<p>⏐</p>
<p><b>Validate</b></p>
<p><b>Bootloader</b></p>
<p>Transport Protocol,</p>
<p>KWP2000-Services,</p>
<p>CAN Driver</p>
<p> </p>
<p>Figure 4-4 </p>
<p>Using A Validation Function For Validation Your Application </p>
<p> </p>
<p> </p>
<p> </p>
<p>©</p>
<p>2006, Vector Informatik GmbH </p>
<p> </p>
<p>Version: 2.7 </p>
<p> </p>
<p> </p>
<p>based of template version 2.0 </p>
<h1 style="page-break-before:always; "></h1>
<p>User Manual  Flash Bootloader </p>
<p> </p>
<p>23 / 56</p>
<p><b>4.6 </b></p>
<p><b>The Interrupt Vector Tables </b></p>
<p>The </p>
<p>application </p>
<p>and Flash </p>
<p>Bootloader </p>
<p>each have </p>
<p>their own </p>
<p>interrupt </p>
<p>vector table to </p>
<p>use. </p>
<p>Interrupts are handled in a special way for applications with Flash Bootloader.  </p>
<p>When  an  application  uses  the  Flash  Bootloader  it  must  be  guaranteed  that  the </p>
<p>reset </p>
<p>vector </p>
<p>always </p>
<p>points </p>
<p>to </p>
<p>the </p>
<p>Flash </p>
<p>Bootloader. </p>
<p>After </p>
<p>a </p>
<p>reset </p>
<p>the </p>
<p>Flash </p>
<p>Bootloader is started first.  </p>
<p>Usually the ECU vector table is part of the protected area of flash memory, but the </p>
<p>reset  vectors  for  the  application  interrupt  service  function  addresses  have  to  be </p>
<p>changeable. </p>
<p>The solution to this problem lies in using 2 interrupt vector tables as shown in the </p>
<p>figure below. </p>
<p> </p>
<p><b>F  l  a  s  h    M  e  m  o  r  y</b></p>
<p><b>R  A  M</b></p>
<p><b>F l a s h  M e m o r y</b></p>
<p><b>Memory Map</b></p>
<p>Application</p>
<p><b>Interrupt Vector Table [FBL]</b></p>
<p><b>IsValid</b></p>
<p>⏐</p>
<p><b>Invalidate</b></p>
<p>⏐</p>
<p><b>Validate</b></p>
<p><b>Bootloader</b></p>
<p>Transport Protocol,</p>
<p>KWP2000-Services,</p>
<p>CAN Driver</p>
<p><b>Interrupt Vector Table</b></p>
<p><b>[Application]</b></p>
<p><b>Validation Area</b></p>
<p>Application</p>
<p>Data</p>
<p>Interrupt</p>
<p>Service</p>
<p>Functions</p>
<p>Reset</p>
<p>all</p>
<p>Others</p>
<p>Vectors</p>
<p>Jump to </p>
<p>Interrupt</p>
<p>Service </p>
<p>Functions</p>
<p> </p>
<p>Figure 4-5 </p>
<p>Principle Of The Two Interrupt Vector Tables </p>
<p>©</p>
<p>2006, Vector Informatik GmbH </p>
<p> </p>
<p>Version: 2.7 </p>
<p> </p>
<p> </p>
<p>based of template version 2.0 </p>
<h1 style="page-break-before:always; "></h1>
<p>User Manual  Flash Bootloader </p>
<p> </p>
<p>24 / 56</p>
<p>The interrupt vector table at the memory address provided by the hardware is used </p>
<p>by the Flash Bootloader (Interrupt Vector Table [FBL]). Your application must use </p>
<p>its own vector table (Interrupt Vector Table [application]). </p>
<p>Every </p>
<p>interrupt </p>
<p>through Reset </p>
<p>leads directly </p>
<p>into the Flash </p>
<p>Bootloader. </p>
<p>Now if an interrupt occurs which is not a reset, then on the hardware side control </p>
<p>branches to the memory location whose address is at the corresponding location in </p>
<p>the Flash Bootloader<i>‘</i>s interrupt vector table (see Figure 4-5). Any interrupt but the </p>
<p>reset </p>
<p>points </p>
<p>into </p>
<p>the </p>
<p>Interrupt </p>
<p>Vector </p>
<p>Table </p>
<p>of </p>
<p>your </p>
<p>application. </p>
<p>Within </p>
<p>your </p>
<p>application  Vector  Table  control  is  branched  now  to  the  appropriate  interrupt </p>
<p>service function.  </p>
<p>As  a  result,  a  slight  overhead  between  detecting  the  interrupt  and  calling  the </p>
<p>interrupt service function is added to every interrupt service function. The delay is </p>
<p>the duration of a jump instruction. </p>
<p>An exception to this is the reset interrupt. It always points to the Flash Bootloader. </p>
<p>There is no direct path from reset into the application. </p>
<p>The CAN Driver working in the Flash Bootloader needs no interrupts itself, since it is </p>
<p>running  in  polling  mode.  It  checks  cyclically  to  see  if  CAN  messages  have  been </p>
<p>received. Reception is not indicated via an interrupt, as is usually the case. For this </p>
<p>reason no additional interrupt service functions are needed in the vector table for the </p>
<p>Flash Bootloader. </p>
<p>You  will  find  further  particulars  about  the  modifications  you  have  to  deal  with  to </p>
<p>adjust your interrupt vector table in Section 6.2.4. </p>
<p> </p>
<p><b>Refer  to  your  Hardware-specific  Documentation </b></p>
<p><b>[#hw_intvect]</b></p>
<p><b>  to  get  more </b></p>
<p><b>detailed information</b></p>
<p>. </p>
<p> </p>
<p> </p>
<p><b>4.7 </b></p>
<p><b>Label Reference File </b></p>
<p>Some  address  information  need  to  be  shared  between  your  application  and  the </p>
<p>Bootloader. Some files such as the application vector table and the module table </p>
<p>are referenced in both the application and the bootloader. These files are usually </p>
<p>located  in  the  application  area,  since </p>
<p>they  potentially  change  (module  table, </p>
<p>interrupt vector table). </p>
<p>The data contents of these files could be erased at any time because they reside in </p>
<p>the non-protected area. </p>
<p>In special circumstances the Bootloader will eventually use the files. Therefore the </p>
<p>application needs to compile and link these files to the </p>
<p><b>same</b></p>
<p> memory location. The </p>
<p>module with these files should be downloaded as the first module to provide the </p>
<p>data  to  the  Bootloader  whenever  needed.  This  ensures  a  proper  Bootloader </p>
<p>execution.  </p>
<p><b>Refer to OEM-specific documentation </b></p>
<p><b>[#oem_ref]</b></p>
<p><b>. </b></p>
<p>©</p>
<p>2006, Vector Informatik GmbH </p>
<p> </p>
<p>Version: 2.7 </p>
<p> </p>
<p> </p>
<p>based of template version 2.0 </p>
<h1 style="page-break-before:always; "></h1>
<p>User Manual  Flash Bootloader </p>
<p> </p>
<p>25 / 56</p>
<p><b>5 </b></p>
<p><b> FLASHING IN 5 STEPS </b></p>
<p><b>STEP 1 :</b></p>
<p>  </p>
<p><b>DESIGN THE MEMORY LAYOUT</b></p>
<p>  </p>
<p>Figure out which component has to be placed at which memory location. Estimate the </p>
<p>sizes. </p>
<p><b>STEP 2:  </b></p>
<p><b>WRITE A TEST APPLICATION  </b></p>
<p>This  can  be  any  application  or  the  application  you  later  use  for  the  ECU.  It  is  very </p>
<p>important, that this application is running correctly and you can recognize its running. </p>
<p>This application is the evidence for the correct function of the Flash Bootloader. </p>
<p><b>STEP 3:</b></p>
<p> </p>
<p><b>INTEGRATE THE BOOTLOADER  </b></p>
<p>In  this  step  you  have  to  integrate  the  Bootloader,  download  it  via  a  programmer  or </p>
<p>burner and test it with the Flash Tool. This is the major step to be done! </p>
<p>Read the Introduction of this step or go directly to the 8 Bootloader Integration step. </p>
<p><b>STEP 4:  </b></p>
<p><b>ADAPT YOUR TEST APPLICATION FOR THE TESTER</b></p>
<p>To prepare the application hex file for being downloaded via the Tester, it has to be </p>
<p>converted to an OEM-specific format. Do this in this step and refer to the description </p>
<p>provided by your OEM. </p>
<p><b>STEP 5:  </b></p>
<p><b>DOWNLOAD YOUR TEST APPLICATION WITH THE TESTER</b></p>
<p>Now do the download the test application as before but now using the OEM-specific </p>
<p>Tester.  </p>
<p>OEM specific</p>
<p>Tester</p>
<p>/* Test Application */</p>
<p>#include ...</p>
<p>#define ..</p>
<p>main</p>
<p>{</p>
<p>...</p>
<p>}</p>
<p>¯</p>
<p><b>CAN<i></b>fbl</i></p>
<p><b>CAN<i></b>fbl</i></p>
<p>Extract</p>
<p>Adjust</p>
<p>Compile</p>
<p>Link</p>
<p><b>fbl_vect.c</b></p>
<p><b>[FBL]</b></p>
<p><b>IsValid</b></p>
<p>⏐</p>
<p><b>Invalidate</b></p>
<p>⏐</p>
<p><b>Validate</b></p>
<p>Bootloader</p>
<p>Transport Protocol,</p>
<p>KWP2000-Services,</p>
<p>CAN Driver</p>
<p>Test</p>
<p>Application</p>
<p><b>Applvect.c</b></p>
<p><b>[Application]</b></p>
<p><b>Programer</b></p>
<p><b>Burner</b></p>
<p><b>Programer</b></p>
<p><b>Burner</b></p>
<p>Test</p>
<p>Application</p>
<p><b>CAN</b></p>
<p>5</p>
<p>4</p>
<p>2</p>
<p>2</p>
<p>1</p>
<p>3</p>
<p>3</p>
<p>3</p>
<p> </p>
<p>Figure 1:  </p>
<p>5 Steps And You Are Flashing via Flash Tool and OEM-specific Tester </p>
<p> </p>
<p>©</p>
<p>2006, Vector Informatik GmbH </p>
<p> </p>
<p>Version: 2.7 </p>
<p> </p>
<p> </p>
<p>based of template version 2.0 </p>
<h1 style="page-break-before:always; "></h1>
<p>User Manual  Flash Bootloader </p>
<p> </p>
<p>26 / 56</p>
<p><b>5.1 </b></p>
<p><b>STEP 1 Design The Memory Layout </b></p>
<p>As flashing is a memory related activity you first need a basic estimation about the </p>
<p>memory  consumption.  Based  on  the  controller  you  use  and  the  memory  model </p>
<p>start with a basic design for the memory layout.  </p>
<p>Define where your application has its location, define the location of the application </p>
<p>vector table and the Bootloader. Figure out where your controller has its “original” </p>
<p>interrupt vector table. </p>
<p>Refer to the hardware-specific documentation for more information </p>
<p><b>[#hw_mem]</b></p>
<p>. </p>
<p><b>F  l  a  s  h    M  e  m  o  r  y</b></p>
<p><b>R  A  M</b></p>
<p><b>F l a s h  M e m o r y</b></p>
<p><b>Memory Map</b></p>
<p>Application</p>
<p><b>Interrupt Vector Table</b></p>
<p><b>[Application]</b></p>
<p><b>Validation Area</b></p>
<p><b>Interrupt Vector Table</b></p>
<p><b>[FBL]</b></p>
<p><b>IsValid</b></p>
<p>⏐</p>
<p><b>Invalidate</b></p>
<p>⏐</p>
<p><b>Validate</b></p>
<p><b>Bootloader</b></p>
<p>Transport Protocol,</p>
<p>KWP2000-Services,</p>
<p>CAN Driver</p>
<p>Application</p>
<p>Data</p>
<p> </p>
<p>Figure 5-1 </p>
<p>Basic Memory Layout Of An Application with the Flash Bootloader </p>
<p> </p>
<p>Back to 5 Steps overview </p>
<p>©</p>
<p>2006, Vector Informatik GmbH </p>
<p> </p>
<p>Version: 2.7 </p>
<p> </p>
<p> </p>
<p>based of template version 2.0 </p>
<h1 style="page-break-before:always; "></h1>
<p>User Manual  Flash Bootloader </p>
<p> </p>
<p>27 / 56</p>
<p><b>5.2 </b></p>
<p><b>STEP 2 Write A Test Application </b></p>
<p>The Flash Bootloader is designed to download your application via a bus protocol </p>
<p>like  CAN,  LIN,  etc.  To  test  the  correct  function  of  the  Flash  Bootloader  you  first </p>
<p>need a Test Application to verify the work of the Flash Bootloader.  </p>
<p>In this step, write a Test Application. </p>
<p><b>F  l  a  s  h    M  e  m  o  r  y</b></p>
<p><b>R  A  M</b></p>
<p><b>F l a s h  M e m o r y</b></p>
<p><b>Memory Map</b></p>
<p><b>F  l  a  s  h    M  e  m  o  r  y</b></p>
<p><b>R  A  M</b></p>
<p><b>F l a s h  M e m o r y</b></p>
<p><b>Memory Map</b></p>
<p>Application</p>
<p><b>Interrupt Vector Table</b></p>
<p><b>[FBL]</b></p>
<p><b>Interrupt Vector Table</b></p>
<p><b>[Application]</b></p>
<p>Application</p>
<p>Data</p>
<p> </p>
<p>Figure 5-2 </p>
<p>The Test Application In The ECU Memory Using Two Interrupt Vector Tables </p>
<p> </p>
<p>It’s recommended to write the Test Application with at least one interrupt service </p>
<p>function, perhaps a timer to do some cyclic action. Make sure that the application is </p>
<p>showing  its  correct  behavior  e.g.  via  LED  blinking  or  even  the  transmission  of  a </p>
<p>CAN  message.  This  will  be  later  on  the  indicator  for  the  correct  working  Flash </p>
<p>Bootloader.  </p>
<p>Download and test this application via your development environment. </p>
<p> </p>
<p>It’s  recommended  to  work  with  two  interrupt  vector  tables  from  the  beginning.  Just </p>
<p>map all interrupts from the “original” vector table to the interrupt vector table of your </p>
<p>application. </p>
<p>For more information refer to the hardware-specific documentation </p>
<p><b>[#hw_tstappl]</b></p>
<p>. </p>
<p> </p>
<p>Back to 5 Steps overview </p>
<p>©</p>
<p>2006, Vector Informatik GmbH </p>
<p> </p>
<p>Version: 2.7 </p>
<p> </p>
<p> </p>
<p>based of template version 2.0 </p>
<h1 style="page-break-before:always; "></h1>
<p>User Manual  Flash Bootloader </p>
<p> </p>
<p>28 / 56</p>
<p><b>5.3 </b></p>
<p><b>STEP 3 Integrate The Bootloader </b></p>
<p>This  is  the  major  step  for  you  to  do.  You  have  to  unpack  the  delivered  files,  do </p>
<p>some application specific adaptations, compile the Bootloader, and download it.  </p>
<p>In  order  to  test  the  Bootloader,  you  need  to  flash  your  test  application  that  you </p>
<p>created in the previous step. To do so you should configure the Flash Tool properly </p>
<p>prior to testing. </p>
<p>Use  the  Flash  Tool  of  the  Flash  Bootloader  package  to  download  your  test </p>
<p>application. Once you have managed to get your Bootloader to work with the Flash </p>
<p>Tool then you can go on and use the OEM-specific Test Tool. Now the embedded </p>
<p>side is working and you can concentrate on adapting the OEM-specific tester. </p>
<p> </p>
<p>Application</p>
<p>Bootloader</p>
<p>Flash Driver</p>
<p>Interrupt Vector Table</p>
<p>[FBL]</p>
<p>Interrupt Vector Table</p>
<p>[Application]</p>
<p>Interrupt Vector Table</p>
<p>[Application]</p>
<p>Flash</p>
<p>Tool</p>
<p>CAN</p>
<p><b>F  l  a  s  h    M  e  m  o  r  y</b></p>
<p><b>R  A  M</b></p>
<p><b>F l a s h  M e m o r y</b></p>
<p>LIN</p>
<p></p>
<p></p>
<p>OEM specif</p>
<p>TESTER</p>
<p>&lt;application&gt;<b>.hex</b></p>
<p>ic</p>
<p>&lt;application&gt;<b>.&lt;oem-format&gt;</b></p>
<p>Conversion </p>
<p>to OEM specific</p>
<p>format to fulfil </p>
<p>Tester needs</p>
<p>(flash container)</p>
<p> </p>
<p>Figure 5-3 </p>
<p>Flashing via Flash Tool and OEM-specific Tester </p>
<p>The application is compiled to a hex file to be used with the Flash Tool. The Flash </p>
<p>Tool controls the download via the bus system (here CAN) and communicates with </p>
<p>the Bootloader. To be able to flash with an OEM-specific tester, some adaptations </p>
<p>have to be done to the application hex file.  </p>
<p>For more information refer to documentation about this workflow provided by your </p>
<p>OEM. </p>
<p> </p>
<p>Follow the 8 Integration Steps for the Bootloader (see Chapter 6) before continuing </p>
<p>with the next step. </p>
<p> </p>
<p> </p>
<p>Back to 5 Steps overview </p>
<p>Integrate the </p>
<p>Bootloader in </p>
<p>8 Steps </p>
<p>more… (see </p>
<p>Chapter </p>
<p><b>6</b></p>
<p>) </p>
<p>©</p>
<p>2006, Vector Informatik GmbH </p>
<p> </p>
<p>Version: 2.7 </p>
<p> </p>
<p> </p>
<p>based of template version 2.0 </p>
<h1 style="page-break-before:always; "></h1>
<p>User Manual  Flash Bootloader </p>
<p> </p>
<p>29 / 56</p>
<p><b>5.4 </b></p>
<p><b>STEP 4 Adapt Your Test Application For The Tester </b></p>
<p>The </p>
<p>next </p>
<p>step </p>
<p>after </p>
<p>downloading </p>
<p>the </p>
<p>test </p>
<p>application </p>
<p>is </p>
<p>to </p>
<p> </p>
<p>adapt </p>
<p>your </p>
<p>&lt;application.hex&gt; </p>
<p>file </p>
<p>to </p>
<p>be </p>
<p>downloaded </p>
<p>via </p>
<p>the </p>
<p>OEM-specific </p>
<p>tester </p>
<p>(see </p>
<p>explanation in the STEP 3). </p>
<p>To test these adaptations, no change of the Bootloader software is necessary. </p>
<p> </p>
<p>Normally there are several steps necessary to convert the hex file into a file that </p>
<p>can be read and used by the tester. Get more information about this workflow using </p>
<p>the documentation provided by your OEM. </p>
<p> </p>
<p>Back to 5 Steps overview </p>
<p> </p>
<p> </p>
<p><b>5.5 </b></p>
<p><b>STEP 5 Download Your Test Application With The Tester </b></p>
<p>Now  you  can  test  the  Bootloader  using  your  OEM-specific  Tester.  You  can  test </p>
<p>things such as starting a Flash programming triggered via reset, or initiated from </p>
<p>the application, etc.  </p>
<p> </p>
<p>Is it still working?  </p>
<p> </p>
<p>Congratulations, you did it!  </p>
<p> </p>
<p>Back to 5 Steps overview. </p>
<p>Continue with the Background Information. </p>
<p> </p>
<p> </p>
<p>©</p>
<p>2006, Vector Informatik GmbH </p>
<p> </p>
<p>Version: 2.7 </p>
<p> </p>
<p> </p>
<p>based of template version 2.0 </p>
<h1 style="page-break-before:always; "></h1>
<p>User Manual  Flash Bootloader </p>
<p> </p>
<p>30 / 56</p>
<p><b>6 </b></p>
<p><b> Details of Bootloader Integration Step (STEP 3) </b></p>
<p><b>Bootloader STEP 1:</b></p>
<p>  </p>
<p><b>Extract the files to a folder on your PC</b></p>
<p><b>Bootloader STEP 2:   Adjust the files to fit your application  </b></p>
<p><b>Bootloader STEP 3:</b></p>
<p> </p>
<p><b>Now compile the Bootloader  </b></p>
<p><b>Bootloader STEP 4:   Transfer the Bootloader to the target hardware</b></p>
<p><b>Bootloader STEP 5:   Use the Flash Tool to test the Bootloader</b></p>
<p><b>Bootloader STEP 6:   Test the flashing after a reset</b></p>
<p><b>Bootloader STEP 7:   Make your application ready for transition to Bootloader</b></p>
<p><b>Bootloader STEP 8:   Start Bootloader from your application</b></p>
<p><b> </b></p>
<p><b> </b></p>
<p>3</p>
<p>/* Test Application */</p>
<p>#include ...</p>
<p>#define ..</p>
<p>main</p>
<p>{</p>
<p>...</p>
<p>}</p>
<p>¯</p>
<p><b>CAN<i></b>fbl</i></p>
<p><b>CAN<i></b>fbl</i></p>
<p>Extract</p>
<p>Adjust</p>
<p>Compile</p>
<p>Link</p>
<p><b>fbl_vect.c</b></p>
<p><b>[FBL]</b></p>
<p><b>IsValid</b></p>
<p>⏐</p>
<p><b>Invalidate</b></p>
<p>⏐</p>
<p><b>Validate</b></p>
<p>Bootloader</p>
<p>Transport Protocol,</p>
<p>KWP2000-Services,</p>
<p>CAN Driver</p>
<p>8</p>
<p>Details of Step 3</p>
<p>7</p>
<p>5</p>
<p>Test</p>
<p>Application</p>
<p><b>CAN</b></p>
<p>1</p>
<p>2</p>
<p>3</p>
<p><b>Applvect.c</b></p>
<p><b>[Application]</b></p>
<p><b>Programer</b></p>
<p><b>Burner</b></p>
<p>4</p>
<p>6</p>
<p> </p>
<p>Figure 6-1 </p>
<p>Details of Bootloader Integration Step (Step 3) </p>
<p>©</p>
<p>2006, Vector Informatik GmbH </p>
<p> </p>
<p>Version: 2.7 </p>
<p> </p>
<p> </p>
<p>based of template version 2.0 </p>
<h1 style="page-break-before:always; "></h1>
<p>User Manual  Flash Bootloader </p>
<p> </p>
<p>31 / 56</p>
<p><b>6.1 </b></p>
<p><b>Bootloader STEP 1 – Extract the files to a folder on your pc </b></p>
<p>Extract the Flash Bootloader files just by starting the install shield. Per default the </p>
<p>files  are  installed  to  the  folder </p>
<p><b>C:\Programme\Vector\...</b></p>
<p>.  You  can  also  use  the </p>
<p><b>Start\Programme\Vector…</b></p>
<p> to find your installation.  </p>
<p>The files are installed with the following directory structure. </p>
<p><b>Name</b></p>
<p><b>Description</b></p>
<p> StandardECU</p>
<p>Root directory of the delivery, root name may differ.</p>
<p> _Common</p>
<p>Contains common files shared between the application and the </p>
<p>bootloader. </p>
<p><i>[e.g. v_def.h, etc.] </i></p>
<p> _Demo</p>
<p>Contains an example implementation. </p>
<p>      </p>
<p> DemoAppl</p>
<p>An application that is prepared to be downloaded to the micro via the </p>
<p>Flash Bootloader and CANflash. </p>
<p>   </p>
<p> DemoFbl</p>
<p>The bootloader part of the demo. This directory contains an example </p>
<p>of a full functional bootloader (e.g. including in-/validation, transition </p>
<p>from application to bootloader and a comprehensive mapping of the </p>
<p>bootloader sections). </p>
<p> _Doc</p>
<p>Contains documentation and test reports for the bootloader. </p>
<p><i>[e.g. </i></p>
<p><i>UserManual_FlashBootloader.pdf, </i></p>
<p><i>TechnicalReference_FBL_*.pdf, TestReport*.pdf, etc.] </i></p>
<p>   </p>
<p> _FlashScript</p>
<p>CANdito flash scripts provided with the bootloader. This directory </p>
<p>only exists if there are flashscripts available for the SLP. </p>
<p>   </p>
<p> _GenTool</p>
<p>Generation tool for the flash bootloader configuration files. In case of </p>
<p>CANgen, the license file is located here. </p>
<p><i>[e.g. CanGen.exe, license.liz, GENyFramework_*.exe, etc.] </i></p>
<p>      </p>
<p> Components</p>
<p>Directory for GENy component-DLLs. If GENy is used, the license </p>
<p>can be found here. Otherwise, this directory does not exist. </p>
<p><i>[e.g. license.liz, Version.Info, preconfig*.pco, etc.] </i></p>
<p>   </p>
<p> _MakeSupport</p>
<p>Make environment used by demo bootloader and application. This </p>
<p>folder contains the global makefile. </p>
<p><i>[e.g. Global.Makefile.target.make.*, etc.] </i></p>
<p>   </p>
<p>_Misc</p>
<p>Everything that doesn’t fit into the other directories can be placed </p>
<p>here (e. g. little tools, that don’t require an installation procedure) </p>
<p>      </p>
<p> HexView</p>
<p>The best tool to generate, edit and process hex-files. Can build </p>
<p>plenty of flash containers, too. </p>
<p>   </p>
<p> _Setup</p>
<p>Setup files for PC-installable software included in the delivery (e. g. </p>
<p>CANflash) </p>
<p><i>[e.g. CANflashFord25.EXE, etc.] </i></p>
<p>     </p>
<p> DrvEep</p>
<p>EEPROM-driver to be used with the bootloader </p>
<p><i>[e.g. EepDrv.c, EepIO.c, EepCfg.h, etc.] </i></p>
<p>   </p>
<p> DrvFlash</p>
<p>Flash-EEPROM-driver to be used with the bootloader (aka </p>
<p>secondary bootloader). This directory contains the source files of the </p>
<p>©</p>
<p>2006, Vector Informatik GmbH </p>
<p> </p>
<p>Version: 2.7 </p>
<p> </p>
<p> </p>
<p>based of template version 2.0 </p>
<h1 style="page-break-before:always; "></h1>
<p>User Manual  Flash Bootloader </p>
<p> </p>
<p>32 / 56</p>
<p>driver and a ready-to-use function file container for the used SLP.  </p>
<p><i>[e.g. flashdrv.c, flashdrv.h, FlashDrv_V850_f.hex, etc.] </i></p>
<p> Fbl</p>
<p>Contains all bootloader files, except flash-driver and security module </p>
<p><i>[e.g. fbl_main.c, fbl_hw.c, fbl_diag.c, etc.] </i></p>
<p>      </p>
<p> _Template</p>
<p>Contains files that are part of the flash bootloader but need to be </p>
<p>adapted for integration purposes. The files contain a collection of </p>
<p>callback-functions grouped in different files for different purposes. </p>
<p>The functions mainly adapt to the specific needs of the bootloader to </p>
<p>a particular project resp. adapts the hardware requirements of the </p>
<p>Bootloader. </p>
<p><i>[e.g. _fbl_ap.c, _fbl_apdi.c, _fbl_apwd.c, _fbl_apfb.c, etc.] </i></p>
<p>  </p>
<p> SecMod</p>
<p>Security module for the bootloader. </p>
<p><i>[e.g. secmod.c, _secmod.h, etc.] </i></p>
<p> </p>
<p> </p>
<p>The  files  listed  in  the  table  are  installed  to  the  folder </p>
<p><b>Fbl</b></p>
<p>.  The  files  with  the  _ </p>
<p>(underscore) are installed to the folder </p>
<p><b>Fbl\_Template,</b></p>
<p> </p>
<p><b>v_def.h</b></p>
<p> is in the </p>
<p><b>_Common </b></p>
<p>path and the flashdrv.h in the </p>
<p><b>DrvFlash</b></p>
<p> folder.  </p>
<p><b>File Name </b></p>
<p><b>Description </b></p>
<p><b>Status </b></p>
<p>Makfile of project file</p>
<p>Makefile or project file for the build process of the </p>
<p>Bootloader. </p>
<p> </p>
<p>fbl_cfg.h</p>
<p>Global Bootloader configuration. This file is generated </p>
<p>by the configuration tool.  </p>
<p> </p>
<p>_fbl_apxx.c / </p>
<p>_fbl_apxx.h</p>
<p>Hardware and system specific callback functions. </p>
<p> </p>
<p>_ftp_cfg.h</p>
<p>Transport layer configuration file. Very soon, this file </p>
<p>is also generated by configuration tool. </p>
<p>_fbl_inc.h</p>
<p>Include file for the Bootloader. Include additional </p>
<p>header files if necessary. </p>
<p> </p>
<p>_applvect.c / </p>
<p>applvect.h</p>
<p>Application vector table </p>
<p> </p>
<p>fbl_diag.c / fbl_diag.h</p>
<p>General Diagnostic Module that contains the </p>
<p>diagnostic handling (KWP2000) and the basic </p>
<p>bootloader functionalities. </p>
<p> </p>
<p>fbl_can.h</p>
<p>Definitions for CAN interface. </p>
<p> </p>
<p>fbl_def.h </p>
<p>Basic Bootloader definitions. </p>
<p> </p>
<p>fbl_hw.c / fbl_hw.h</p>
<p>Hardware-specific module for CAN and timer. </p>
<p> </p>
<p>fbl_main.c </p>
<p>Main module for Bootloader initialization and idle </p>
<p>loop. </p>
<p> </p>
<p>fbl_tp.c / fbl_tp.h</p>
<p>Transport layer for the FBL. </p>
<p> </p>
<p>Since the </p>
<p>Flash </p>
<p>Bootloader is </p>
<p>an </p>
<p>independent </p>
<p>application, it </p>
<p>must be </p>
<p>possible for </p>
<p>you in most </p>
<p>cases to take </p>
<p>the directory</p>
<p> </p>
<p>structure, as </p>
<p>unpack it. </p>
<p>©</p>
<p>2006, Vector Informatik GmbH </p>
<p> </p>
<p>Version: 2.7 </p>
<p> </p>
<p> </p>
<p>based of template version 2.0 </p>
<h1 style="page-break-before:always; "></h1>
<p>User Manual  Flash Bootloader </p>
<p> </p>
<p>33 / 56</p>
<p>fbl_vect.c</p>
<p>Bootloader vector table. </p>
<p> </p>
<p>fbl_wd. / fbl_wd.h</p>
<p>Watchdog support. </p>
<p> </p>
<p>flashdrv.h</p>
<p>Interface header file for Flash Driver. </p>
<p> </p>
<p>v_def.h</p>
<p>Type definitions from Vector Informatik </p>
<p> </p>
<p><b>Caution </b></p>
<p><b>It is absolutely necessary that YOU </b></p>
<p><b>adapt the startup-code for the Bootloader to your </b></p>
<p><b>specific hardware platform!  </b></p>
<p>Remind that there will be two startup-codes executed subsequently, first the startup-code of the </p>
<p>Bootloader, then the startup-code of your application.  </p>
<p><b>!!! be careful with registers that can be written only once after reset !!!</b></p>
<p><b>OEM specific </b></p>
<p> </p>
<p>You  can  adapt  these  files  according  to  your  application  (fbl_vect  cannot  be </p>
<p>adapted by user). A detailed description of how that is to be handled can be found </p>
<p>in Section 6.2. In your delivery all files that you have to adapt are marked with an </p>
<p>underscore (_&lt;file&gt;) before the name and stored in the </p>
<p><b>_Template</b></p>
<p> folder. Create </p>
<p>an own folder to store the adapted files without the underscore.  </p>
<p> </p>
<p><b>OEM </b></p>
<p><b>specific </b></p>
<p><b>– </b></p>
<p><b>some </b></p>
<p><b>more </b></p>
<p><b>files, </b></p>
<p><b>refer </b></p>
<p><b>to </b></p>
<p><b>your </b></p>
<p><b>OEM </b></p>
<p><b>specific </b></p>
<p><b>reference </b></p>
<p><b>[#oem_files]</b></p>
<p><b>. </b></p>
<p><b> </b></p>
<p>Back to 8 Steps Bootloader integration overview</p>
<p><b> </b></p>
<p>©</p>
<p>2006, Vector Informatik GmbH </p>
<p> </p>
<p>Version: 2.7 </p>
<p> </p>
<p> </p>
<p>based of template version 2.0 </p>
<h1 style="page-break-before:always; "></h1>
<p>User Manual  Flash Bootloader </p>
<p> </p>
<p>34 / 56</p>
<p><b>6.2 </b></p>
<p><b>Bootloader STEP 2 Adjust the marked files to fit your application </b></p>
<p>Now you go through the files pointed to by the hand in the above diagram in detail </p>
<p>and adapt them specifically to your application. </p>
<p> </p>
<p><b>6.2.1 </b></p>
<p><b>Make… Makefile and make.exe </b></p>
<p>To  be  able  to  compile  the  Flash  Bootloader  you  just  have  to  adapt  the  file </p>
<p>makeconf by setting the compiler path to your demands, see an example </p>
<p>e.g. COMPILER_PATH   = c:\uti\hc12\cx32 </p>
<p>Then you can execute the make.exe to compile and link for the first time. Now you </p>
<p>can start upon this basis and adapt the files for your demands. </p>
<p> </p>
<p><b>6.2.2 </b></p>
<p><b>fbl_cfg.h</b></p>
<p> - </p>
<p><b>The Configuration File For The Flash Bootloader </b></p>
<p>If you are using a Generation Tool with the bootloader then the Generation Tool </p>
<p>creates this file. To modify the bootloader you would simply have to trigger the </p>
<p>generation process again. If you are not using the generation tool with the </p>
<p>bootloader then you can manually configure the bootloader by modifying defines </p>
<p>such as clock frequency, CAN baudrate, etc… </p>
<p>See the list of the possible switches below to be changed followed by a brief </p>
<p>description. To get more information refer to the comments in the file fbl_cfg.h. </p>
<p> </p>
<p>CAN_TP_RXID</p>
<p>Receive ID for the transport protocol </p>
<p>CAN_TP_TXID</p>
<p>Send ID for the transport protocol </p>
<p>FBL_ENABLE/DISABLE_DEBUG_STATUS</p>
<p>Additional hints for debugging (if </p>
<p>possible) </p>
<p>FBL_ENABLE/DISABLE_SYSTEM_CHECK</p>
<p>Checks if data buffer will be overwritten</p>
<p>FBL_ENABLE/DISABLE_FLASHBLOCK_CHECK</p>
<p>The pre-defined flashblocks in FBL_AP </p>
<p>are checked and aligned during </p>
<p>download </p>
<p>FBL_ENABLE/DISABLE_APPL_TASK</p>
<p>Enable a cyclic task for some timing </p>
<p>adjustments (call cycle TpCallCycle typ. </p>
<p>1ms). </p>
<p>FBL_MAX_NUMBER_OF_MODULES</p>
<p>Set here the number of modules that </p>
<p>shall be downloaded and programmed. </p>
<p>FBL_ENABLE/DISABLE_SECTOR_ERASE_FCT</p>
<p>Enable the usage of the callback </p>
<p>function ApplFblSectorErase() </p>
<p>FBL_ENABLE/DISABLE_FILECHECKSUM</p>
<p>Enables an internal file checksum </p>
<p>calculation. This checksum is </p>
<p>generated during the download </p>
<p>sequences </p>
<p>©</p>
<p>2006, Vector Informatik GmbH </p>
<p> </p>
<p>Version: 2.7 </p>
<p> </p>
<p> </p>
<p>based of template version 2.0 </p>
<h1 style="page-break-before:always; "></h1>
<p>User Manual  Flash Bootloader </p>
<p> </p>
<p>35 / 56</p>
<p>FBL_ENABLE/DISABLE_ENCRYPTION_MODE</p>
<p>If you enable this switch, further </p>
<p>functions are called to decrypt coded </p>
<p>data. (ApplFblEncryptInit, </p>
<p>ApplFblEncryptData). </p>
<p>FBL_WATCHDOG_ON/OFF</p>
<p>Switch Watchdog on or off </p>
<p>FBL_WATCHDOG_TIME</p>
<p>Setting of the watchdog trigger cycle </p>
<p>FBL_PROCESSOR_40MHZ</p>
<p>Some clock settings may not be </p>
<p>available on all CPUs. Please refer to </p>
<p>fbl_hw.c, FblTimerInit </p>
<p>FBL_ENABLE/DISABLE_STAY_IN_BOOT</p>
<p>Setting </p>
<p>FBL_DISABLE_STAY_IN_BOOT, it is </p>
<p>not possible to force the bootloader not </p>
<p>to start the application. </p>
<p>FBL_DIAG_BUFFER_LENGTH</p>
<p>This is the size of the diagnostic data </p>
<p>buffer used for USDT </p>
<p>reception/transmission </p>
<p>(COMMON_BUFFER mode). </p>
<p>FBL_START</p>
<p>Start address of the FBL. </p>
<p>FLASH_SIZE</p>
<p>Specifies the number of bytes used for </p>
<p>the Flashcode (aka flash driver). </p>
<p> </p>
<p><b>Note</b>: Allocate as much memory as </p>
<p>possible to be able to download a </p>
<p>bigger flash driver in the future. </p>
<p>CAN_BTR01</p>
<p>Bus timing configuration for normal </p>
<p>mode </p>
<p>©</p>
<p>2006, Vector Informatik GmbH </p>
<p> </p>
<p>Version: 2.7 </p>
<p> </p>
<p> </p>
<p>based of template version 2.0 </p>
<h1 style="page-break-before:always; "></h1>
<p>User Manual  Flash Bootloader </p>
<p> </p>
<p>36 / 56</p>
<p><b>6.2.3 </b></p>
<p><b>FBL_apxx.C </b></p>
<p>Set up and </p>
<p>initialize these </p>
<p>functions </p>
<p>according to your </p>
<p>needs. When </p>
<p>doing this, follow </p>
<p>the descriptions </p>
<p>for each and use </p>
<p>Figure 6-2 for a </p>
<p>complete </p>
<p>overview. </p>
<p>The next thing you have to do is adapt the Flash Bootloader to your application and </p>
<p>hardware. The following functions have to be adapted:  </p>
<p> </p>
<p><b>Function Name </b></p>
<p><b>File Name </b></p>
<p>ApplFblInit </p>
<p>fbl_ap </p>
<p>ApplFblStartup </p>
<p>fbl_ap </p>
<p>ApplTrcvrNormalMode </p>
<p>fbl_ap </p>
<p>ApplFblSetVfp </p>
<p>fbl_ap </p>
<p>ApplFblResetVfp </p>
<p>fbl_ap </p>
<p>ApplCanParamInit </p>
<p>fbl_ap </p>
<p>ApplFblFlashBlockNotFound </p>
<p>fbl_ap </p>
<p>ApplFblTask </p>
<p>fbl_ap </p>
<p>ApplFblIsValidApp </p>
<p>fbl_ap </p>
<p>ApplFblInvalidateApp *, ApplFblValidateApp * </p>
<p> </p>
<p>fbl_ap </p>
<p>ApplFblSecuritySeed </p>
<p>fbl_ap </p>
<p>ApplFblSecurityKey </p>
<p>fbl_ap </p>
<p>ApplFblSectorErase </p>
<p>fbl_ap </p>
<p>ApplFblWDInit </p>
<p>fpl_apwd </p>
<p>ApplFblWDShort </p>
<p>fbl_apwd </p>
<p>AplFblWDTrigger  </p>
<p>fbl_apwd </p>
<p>ApplFblWDLong </p>
<p> </p>
<p>fbl_apwd </p>
<p> </p>
<p>You will find these functions again </p>
<p>in Figure 6-2</p>
<p>.</p>
<p> </p>
<p> </p>
<p>©</p>
<p>2006, Vector Informatik GmbH </p>
<p> </p>
<p>Version: 2.7 </p>
<p> </p>
<p> </p>
<p>based of template version 2.0 </p>
<h1 style="page-break-before:always; "></h1>
<p>User Manual  Flash Bootloader </p>
<p> </p>
<p>37 / 56</p>
<p><b>Reset</b></p>
<p><b>ApplFblInit</b></p>
<p><b>ApplFblWDInit</b></p>
<p><b>Optional</b></p>
<p><b>: initialize WD</b></p>
<p><b>and set trigger time </b></p>
<p><b>*</b></p>
<p><b>[End of Initialization Phase]</b></p>
<p><b>ApplTrcvrNormalMode</b></p>
<p><b>Wait for Diagnostic Service to start Flash</b></p>
<p><b>ApplFblSecuritySeed</b></p>
<p><b>[Queried via KWP2000]</b></p>
<p><b>ApplFblSecurityKey</b></p>
<p><b>[Queried via KWP2000]</b></p>
<p><b>Download of Flash Algorithms</b></p>
<p><b>ApplFblSetVfp</b></p>
<p><b>ApplFblInvalidateApp</b></p>
<p><b>Erase Flash Memory</b></p>
<p><b>ApplFblSectorErase (opt.)</b></p>
<p><b>Download Application Data</b></p>
<p><b>ApplFblValidateApp</b></p>
<p><b>ApplFblResetVfp</b></p>
<p><b>ApplFblWDLong</b></p>
<p><b>ApplFblWDShort</b></p>
<p><b>FblStart</b></p>
<p><b>ApplFblIsValidApp</b></p>
<p><b>Optional</b></p>
<p><b>: initialize WD </b></p>
<p><b>and set trigger time </b></p>
<p><b>*</b></p>
<p><b>Application</b></p>
<p><b>Bootloader</b></p>
<p><b>Dependent on OEM</b></p>
<p>OEM specific</p>
<p>wait time</p>
<p><b>ApplFblStartup</b></p>
<p>no</p>
<p>yes</p>
<p><b>ApplFblStartup</b></p>
<p><b>ApplFblFlashBlockNotFound</b></p>
<p><b>ApplFblWDTrigger</b></p>
<p><b>ApplFblCanParamInit</b></p>
<p> </p>
<p>Figure 6-2 </p>
<p>Function Calling Sequence During Flashing </p>
<p>©</p>
<p>2006, Vector Informatik GmbH </p>
<p> </p>
<p>Version: 2.7 </p>
<p> </p>
<p> </p>
<p>based of template version 2.0 </p>
<h1 style="page-break-before:always; "></h1>
<p>User Manual  Flash Bootloader </p>
<p> </p>
<p>38 / 56</p>
<p>The function </p>
<p>ApplFblCanP</p>
<p>aramInit </p>
<p>The function </p>
<p>ApplFblIs </p>
<p>ValidApp</p>
<p>The function </p>
<p>ApplFblStartup </p>
<p>The Watchdog may only be initialized in one of the two optional functions. In most </p>
<p>cases </p>
<p>this  is </p>
<p>the </p>
<p>function </p>
<p><b>ApplFblInit</b>. </p>
<p>Further </p>
<p>details </p>
<p>on </p>
<p>the </p>
<p>background </p>
<p>and </p>
<p>possibilities of Watchdog handling can be found in Section 7.1.  </p>
<p>The </p>
<p>ApplFblInit    </p>
<p>function </p>
<p>Be sure to </p>
<p>only initialize </p>
<p>the watchdog </p>
<p>timer in one </p>
<p>location </p>
<p>The  description  of  the  functions  below  is  done  in  same  order  as  they  are  called </p>
<p>beginning with the reset. </p>
<p> </p>
<p><b>6.2.3.1 </b></p>
<p><b>ApplFblInit </b></p>
<p>The </p>
<p>function </p>
<p>ApplFblInit </p>
<p>is </p>
<p>called </p>
<p>after </p>
<p>every </p>
<p>reset. </p>
<p>You </p>
<p>can </p>
<p>do </p>
<p>your </p>
<p>basic </p>
<p>initializations, such as memory mapping, PLL setup, etc. Usually initialization of the </p>
<p>Watchdog timer is dealt with here. (See 3.3 for more details).  </p>
<p> </p>
<p><b>6.2.3.2 </b></p>
<p><b>ApplFblCanParamInit </b></p>
<p>Callback function for multi ECU support. See 7.2. </p>
<p> </p>
<p><b>6.2.3.3 </b></p>
<p><b>ApplFblIsValidApp </b></p>
<p>Callback function to check the validity of the application. See 4.4.2. </p>
<p> </p>
<p><b>6.2.3.4 </b></p>
<p><b>ApplFblStartup </b></p>
<p>This function is called after </p>
<p><b>ApplFblInit</b></p>
<p> if no valid application was found or the </p>
<p>Bootloader was started by the application (reprogramming request). Use this </p>
<p>function to do initializations, which are needed by the application and the </p>
<p>Bootloader. This is useful if you want to initialize hardware or software explicitly </p>
<p>used for the Bootloader. </p>
<p> </p>
<p><b>6.2.3.5 </b></p>
<p><b>ApplFblWDInit </b></p>
<p>The function ApplFblWDInit is only called if control remains in the Flash Bootloader </p>
<p>after a reset. </p>
<p>You can also initialize your Watchdog here if you have not done this already in the </p>
<p>function </p>
<p><b>ApplFblInit</b></p>
<p> (see 6.2.3.1) (for more details about the watchdog see 3.1). </p>
<p><b>Example: </b></p>
<p> </p>
<p>void ApplFblWDInit(void) </p>
<p>{ </p>
<p>Your code for initializing your Watchdog can go here, or nothing, if you either </p>
<p>won't be using it or you want to initialize it somewhere else. </p>
<p>} </p>
<p> </p>
<p>©</p>
<p>2006, Vector Informatik GmbH </p>
<p> </p>
<p>Version: 2.7 </p>
<p> </p>
<p> </p>
<p>based of template version 2.0 </p>
<h1 style="page-break-before:always; "></h1>
<p>User Manual  Flash Bootloader </p>
<p> </p>
<p>39 / 56</p>
<p><b>6.2.3.6 </b></p>
<p><b>ApplTrcvrNormalMode </b></p>
<p>The function </p>
<p>ApplTrcvNor</p>
<p>malMode </p>
<p>The  name  of  this  function  is  self-explanatory.  To  send  CAN  messages  it  is  first </p>
<p>necessary to setup the transceiver. This can be done here. </p>
<p> </p>
<p><b>Example: </b></p>
<p> </p>
<p>void ApplTrcvrNormalMode(void) </p>
<p>{ </p>
<p> </p>
<p>  DDRCAN  = 0xff; /* set the port direction */ </p>
<p>  PORTCAN = 0x30; /* set the port */ </p>
<p> </p>
<p>} </p>
<p> </p>
<p><b>6.2.3.7 </b></p>
<p><b>ApplFblSecuritySeed / Key </b></p>
<p> </p>
<p><b>Refer  to  your  OEM-specific  Documentation </b></p>
<p><b>[#oem_sec]</b></p>
<p><b>  to  get  the  necessary </b></p>
<p><b>information</b></p>
<p>. </p>
<p> </p>
<p>The function </p>
<p>ApplFblSetVfp </p>
<p><b>6.2.3.8 </b></p>
<p><b>ApplFblSetVfp  </b></p>
<p>Whether  you  need  to  configure  this  function  or  not  depends  on  your  hardware </p>
<p>setup  (some  flash  memories  require  external  programming  voltage  to  erase  and </p>
<p>program). If you have to turn on the voltage for flash programming, you can do that </p>
<p>in this function. </p>
<p>Normally you would set an I/O port to enable an external flash supply. </p>
<p><b>Example: </b></p>
<p> </p>
<p>void ApplFblSetVfp(void) </p>
<p>{ </p>
<p>for example: </p>
<p>  PORTA &amp;= ~0x01; </p>
<p>} </p>
<p> </p>
<p>The function </p>
<p>ApplFblInvalid</p>
<p>ateApp </p>
<p><b>6.2.3.9 </b></p>
<p><b>ApplFblInvalidateApp </b></p>
<p>Callback function to invalidate an application. See 4.4.2. </p>
<p> </p>
<p><b>6.2.3.10 </b></p>
<p><b>ApplFblFlashBlockNotFound </b></p>
<p>The function </p>
<p>ApplFblFlash </p>
<p>BlockNotFoun</p>
<p>This function is called if a TransferData has been received but no address region </p>
<p>was  found  in  the  defined  FlashBlocks.  It  also  allows  you  to  support  out  of  main </p>
<p>memory downloads (for example: Additional Flash or EEPROM). </p>
<p> </p>
<p>©</p>
<p>2006, Vector Informatik GmbH </p>
<p> </p>
<p>Version: 2.7 </p>
<p> </p>
<p> </p>
<p>based of template version 2.0 </p>
<h1 style="page-break-before:always; "></h1>
<p>User Manual  Flash Bootloader </p>
<p> </p>
<p>40 / 56</p>
<p><b>6.2.3.11 </b></p>
<p><b>ApplFblValidateApp </b></p>
<p>The function </p>
<p>ApplFblValida</p>
<p>teApp </p>
<p>Callback function to validate an application. See 4.4.2. </p>
<p> </p>
<p><b>6.2.3.12 </b></p>
<p><b>ApplFblResetVfp </b></p>
<p>The function </p>
<p>ApplFblReset</p>
<p>Vfp </p>
<p>The  function  ApplFblResetVfp  is  the  counterpart  of  the  function  ApplFblSetVfp. </p>
<p>This function allows you to turn off the programming voltage. </p>
<p><b>Example: </b></p>
<p> </p>
<p>void ApplFblResetVfp(void) </p>
<p>{ </p>
<p>For example: </p>
<p>  PORTA |= 0x01; </p>
<p>} </p>
<p> </p>
<p>The function </p>
<p>ApplFblWDLong </p>
<p><b>6.2.3.13 </b></p>
<p><b>ApplFblWDLong </b></p>
<p>Adjusts watchdog timing for application if necessary. </p>
<p>This function is called immediately after flashing, before branching from the Flash </p>
<p>Bootloader  into  your  application.  For  watchdogs  with  changeable  timer  intervals, </p>
<p>switching to the other interval can be done here.  </p>
<p>If you want to use a hardware reset for the transition, implement an infinite loop in this </p>
<p>function. The Watchdog timer will expire and create the desired reset.  </p>
<p><b>Example: </b></p>
<p> </p>
<p>void ApplFblWDLong(void) </p>
<p>{ </p>
<p> Here is the place for your infinite loop or your changeover. If you do not need </p>
<p>this function, simply leave this blank. </p>
<p>} </p>
<p> </p>
<p>Starting  the  flash  process  from  the  application,  the  following  call  back  functions </p>
<p>have to be adapted. </p>
<p>The function </p>
<p>ApplFblWDShort </p>
<p><b>6.2.3.14 </b></p>
<p><b>ApplFblWDShort </b></p>
<p>The  function  ApplFblWDShort  is  called  during  the  transition  from  the  application </p>
<p>into  the  Flash  Bootloader.  With  it  you  can  again  re-adjust  the  watchdog  timer </p>
<p>interval.  </p>
<p>If you have a window watchdog, you can synchronize the watchdog here. </p>
<p><b>Example: </b></p>
<p> </p>
<p>void ApplFblWDShort(void) </p>
<p>{ </p>
<p> Here is the place for your changeover. If you do not need this function, simply </p>
<p>leave this blank. </p>
<p>} </p>
<p> </p>
<p>©</p>
<p>2006, Vector Informatik GmbH </p>
<p> </p>
<p>Version: 2.7 </p>
<p> </p>
<p> </p>
<p>based of template version 2.0 </p>
<h1 style="page-break-before:always; "></h1>
<p>User Manual  Flash Bootloader </p>
<p> </p>
<p>41 / 56</p>
<p><b>6.2.3.15 </b></p>
<p><b>ApplFblWDTrigger  </b></p>
<p>The function </p>
<p>ApplFblWDTrigge</p>
<p>r </p>
<p>If you enable the watchdog timer, then you must refresh it in the function </p>
<p>ApplFblWDTrigger. An example of how this is done follows. </p>
<p><b>Example: </b></p>
<p> </p>
<p>void ApplFblWDTrigger(void) </p>
<p>{ </p>
<p>/* You must operate your Watchdog here. The code could look like this: */ </p>
<p>  PORTB  |=    cWatchdogPin; </p>
<p>  PORTB  &amp;=   ~cWatchdogPin; </p>
<p>} </p>
<p> </p>
<p>©</p>
<p>2006, Vector Informatik GmbH </p>
<p> </p>
<p>Version: 2.7 </p>
<p> </p>
<p> </p>
<p>based of template version 2.0 </p>
<h1 style="page-break-before:always; "></h1>
<p>User Manual  Flash Bootloader </p>
<p> </p>
<p>42 / 56</p>
<p><b>6.2.4 </b></p>
<p><b>Fbl_vect.c / Applvect.c(.h) - The Interrupt Vector Tables </b></p>
<p>There are several files provided for the interrupt vector tables. Fbl_vect.c (.h) is the </p>
<p>vector table for the Bootloader, Applvect.c (.h) for the application. </p>
<p>On some hardware platforms the vector table may also be implemented in assembly </p>
<p>language. The files names will have corresponding extensions in this case. </p>
<p>For the integration of the Bootloader you have to compile and link the provided files </p>
<p>fbl_vect </p>
<p><b>and</b></p>
<p> applvect.c / applvect.h to your Bootloader files. To adjust the location </p>
<p>of  the  application  vector  table,  just  link  the  APPLVECT  segment  to  the  desired </p>
<p>memory location. The location of the application vector table must be fixed and the </p>
<p>same for the bootloader as well as the application.  </p>
<p><b>F  l  a  s  h    M  e  m  o  r  y</b></p>
<p><b>Memory Map</b></p>
<p><b>Applvect.c</b></p>
<p><b>[Application]</b></p>
<p><b>R  A  M</b></p>
<p><b>F l a s h  M e m o r y</b></p>
<p><b>fbl_vect.c</b></p>
<p><b>[FBL]</b></p>
<p><b>IsValid</b></p>
<p>⏐</p>
<p><b>Invalidate</b></p>
<p>⏐</p>
<p><b>Validate</b></p>
<p><b>Bootloader</b></p>
<p>Transport Protocol,</p>
<p>KWP2000-Services,</p>
<p>CAN Driver</p>
<p>Reset</p>
<p> </p>
<p>Figure 6-3 </p>
<p>Situation Directly After The Programming Of The Bootloader Together With The Dummy Application </p>
<p>Vector Table </p>
<p>The </p>
<p>provided </p>
<p>application </p>
<p>vector </p>
<p>table </p>
<p>is </p>
<p>just </p>
<p>a </p>
<p>dummy </p>
<p>table </p>
<p>to </p>
<p>provide </p>
<p>the </p>
<p>Bootloader  with  the  memory  address  of  the  application  vector  table.  All  vectors </p>
<p>within the applvect.c point to the startup code of the Bootloader.  </p>
<p>©</p>
<p>2006, Vector Informatik GmbH </p>
<p> </p>
<p>Version: 2.7 </p>
<p> </p>
<p> </p>
<p>based of template version 2.0 </p>
<h1 style="page-break-before:always; "></h1>
<p>User Manual  Flash Bootloader </p>
<p> </p>
<p>43 / 56</p>
<p>If you now flash your application for the first time, this dummy application interrupt </p>
<p>vector table will be overwritten with your application vector table. Make sure that </p>
<p>the memory location is exactly the same.  </p>
<p>It is recommended to use the applvect.c file from the delivered example application </p>
<p>as basis for your application vector table and insert the name of your interrupt service </p>
<p>functions at the appropriate locations in the file. </p>
<p>.  </p>
<p><b>Refer To hardware-specific Documentation </b></p>
<p><b>[#hw_intvect].</b></p>
<p><b> </b></p>
<p> </p>
<p>Back to 8 Steps Bootloader integration overview </p>
<p> </p>
<p> </p>
<p>©</p>
<p>2006, Vector Informatik GmbH </p>
<p> </p>
<p>Version: 2.7 </p>
<p> </p>
<p> </p>
<p>based of template version 2.0 </p>
<h1 style="page-break-before:always; "></h1>
<p>User Manual  Flash Bootloader </p>
<p> </p>
<p>44 / 56</p>
<p><b>6.3 </b></p>
<p><b>Bootloader STEP 3 Now compile the Flash Bootloader </b></p>
<p>Now all the files and functions have been adapted. Call the file make.exe again to </p>
<p>compile  them.  The  result  is  a  file  XYZ.hex,  that  is,  the  Flash  Bootloader  in  hex </p>
<p>format. </p>
<p> </p>
<p><b>6.4 </b></p>
<p><b>Bootloader STEP 4 Transfer the Bootloader to the target hardware </b></p>
<p>In order to test your result, you now have to load the Bootloader hex file onto your </p>
<p>target platform. </p>
<p> </p>
<p><b>6.5 </b></p>
<p><b>Bootloader STEP 5 Use the Flash Tool to Test the Bootloader </b></p>
<p>Open </p>
<p>the </p>
<p>Flash </p>
<p>Tool </p>
<p>(for </p>
<p>installation </p>
<p>and </p>
<p>how </p>
<p>to </p>
<p>use </p>
<p>it </p>
<p>see </p>
<p>the </p>
<p>FlashTool </p>
<p>Documentation). Go to </p>
<p><b>Options\Paths</b></p>
<p> and set the paths. </p>
<p>Before you start the download, be sure that you have a CAN connection to your ECU.  </p>
<p> </p>
<p>Press the Start-Button to start the Flasher. The Flash Tool will now cyclically send </p>
<p>the CAN Flash messages.  </p>
<p> </p>
<p><b>6.6 </b></p>
<p><b>Bootloader STEP 6 – Test the flashing after a reset  </b></p>
<p>If you do a reset now, the ECU, triggered by the Flash Tool's cyclically sent CAN </p>
<p>messages,  should  start  the  flash  process.  You  can  see  the  flash  process  in  the </p>
<p>window of the Flash Tool.  </p>
<p>Did it work properly?  If so, the main work is already behind you. </p>
<p><b>If not</b>: check the baud rate, the CAN connection and the hardware initializations. </p>
<p> </p>
<p> </p>
<p>Back to 8 Steps Bootloader integration overview </p>
<p>©</p>
<p>2006, Vector Informatik GmbH </p>
<p> </p>
<p>Version: 2.7 </p>
<p> </p>
<p> </p>
<p>based of template version 2.0 </p>
<h1 style="page-break-before:always; "></h1>
<p>User Manual  Flash Bootloader </p>
<p> </p>
<p>45 / 56</p>
<p><b>6.7 </b></p>
<p><b>Bootloader Step 7 – Make your application ready for the transition to </b></p>
<p><b>the Bootloader </b></p>
<p>Another  possible  way  to  start  the  Flash  Bootloader  is  from  the  application.  A </p>
<p>common  way  of  starting  the  bootloader  from  the  application  is  by  receiving  a </p>
<p>certain diagnostic service or because by a special-purpose CAN message. </p>
<p>As you see in the Figure 6-2 the transition from the application to the Bootloader is </p>
<p>done  via  the  function  FblStart.  The  parameter  of  this  function  is  a  hardware </p>
<p>dependent structure that contains e.g. the baud rate, the bit timing, CAN-ID, etc.  </p>
<p>Some OEMs realize the transition from the application to the Bootloader via a reset.  </p>
<p> </p>
<p><b>Refer to your OEM-specific Documentation </b></p>
<p><b>[#oem_trans]</b></p>
<p><b> to get the necessary </b></p>
<p><b>information </b></p>
<p><b>on </b></p>
<p><b>the </b></p>
<p><b>correct </b></p>
<p><b>sequence </b></p>
<p><b>of </b></p>
<p><b>events </b></p>
<p><b>to </b></p>
<p><b>switch </b></p>
<p><b>from </b></p>
<p><b>your </b></p>
<p><b>application to the Bootloader</b></p>
<p>. </p>
<p> </p>
<p><b>6.8 </b></p>
<p><b>Bootloader Step 8 – Start Bootloader from your application </b></p>
<p>Compile your application with the jump to bootloader supported as described in the </p>
<p>previous  step.  Then  load  it  on  your  target  hardware  using  the  flash  tool.  Now </p>
<p>flashing works in cooperation with the flash tool. The final two steps deal with the </p>
<p>preparation of the application hex file for download via an OEM tester. </p>
<p> </p>
<p> </p>
<p>Ok?  It is working?  </p>
<p>If not, go back to the STEP 3, or continue with the STEP 4 if it works. </p>
<p> </p>
<p>©</p>
<p>2006, Vector Informatik GmbH </p>
<p> </p>
<p>Version: 2.7 </p>
<p> </p>
<p> </p>
<p>based of template version 2.0 </p>
<h1 style="page-break-before:always; "></h1>
<p>User Manual  Flash Bootloader </p>
<p> </p>
<p>46 / 56</p>
<p><b>7 </b></p>
<p><b>Background Information </b></p>
<p><b>7.1 </b></p>
<p><b>The Watchdog </b></p>
<p>The </p>
<p>Bootloader </p>
<p>needs </p>
<p>to </p>
<p>trigger </p>
<p>an </p>
<p>on-chip </p>
<p>or </p>
<p>external </p>
<p>watchdog </p>
<p>while </p>
<p>downloading the application. </p>
<p>Refreshing  the  watchdog  is  hardware/application  specific  and  therefore  must  be </p>
<p>implemented by the user. There are two watchdog functions: </p>
<p></p>
<p> </p>
<p><b>FblLookForWatchdog:</b></p>
<p>  Internal  function  to  generate  the  time  base  for </p>
<p>triggering the watchdog (must not be changed by the user) </p>
<p></p>
<p> </p>
<p><b>ApplFblWDTrigger:</b></p>
<p> </p>
<p>Hardware/application </p>
<p>specific </p>
<p>call-back </p>
<p>function </p>
<p>for </p>
<p>refreshing the watchdog </p>
<p> </p>
<p><b>F  l  a  s  h    M  e  m  o  r  y</b></p>
<p><b>Memory Map</b></p>
<p><b>F  l  a  s  h    M  e  m  o  r  y</b></p>
<p><b>R  A  M</b></p>
<p><b>F l a s h  M e m o r y</b></p>
<p><b>Memory Map</b></p>
<p>Application</p>
<p><b>Interrupt Vector Table</b></p>
<p><b>[Application]</b></p>
<p><b>Validation Area</b></p>
<p><b>R  A  M</b></p>
<p><b>F l a s h  M e m o r y</b></p>
<p><b>Interrupt Vector Table</b></p>
<p><b>[FBL]</b></p>
<p><b>IsValid</b></p>
<p>⏐</p>
<p><b>Invalidate</b></p>
<p>⏐</p>
<p><b>Validate</b></p>
<p><b>Bootloader</b></p>
<p>Transport Protocol,</p>
<p>KWP2000-Services,</p>
<p>CAN Driver</p>
<p><b>Flash Driver</b></p>
<p><b>Flash Driver</b></p>
<p><b>ApplFblWDTrigger</b></p>
<p><b>ApplFblWDTrigger</b></p>
<p><b>FblLookForWatchdog</b></p>
<p><b>FblLookForWatchdog</b></p>
<p><b>ApplFblWDTrigger</b></p>
<p><b>ApplFblWDTrigger</b></p>
<p><b>FblLookForWatchdog</b></p>
<p><b>FblLookForWatchdog</b></p>
<p>copy before</p>
<p>flashing</p>
<p> </p>
<p>Figure 7-1 </p>
<p>Memory Layout Of The Watchdog Trigger Functions </p>
<p> </p>
<p>©</p>
<p>2006, Vector Informatik GmbH </p>
<p> </p>
<p>Version: 2.7 </p>
<p> </p>
<p> </p>
<p>based of template version 2.0 </p>
<h1 style="page-break-before:always; "></h1>
<p>User Manual  Flash Bootloader </p>
<p> </p>
<p>47 / 56</p>
<p>Both  functions  are  copied  into  RAM  while  programming  the  Flash,  as  it’s  not </p>
<p>possible on most MCUs to execute an application from Flash while reprogramming </p>
<p>parts  of  the  Flash.  Copying  the  functions  into  RAM  is  either  accomplished  by  a </p>
<p>copy function of the Bootloader (</p>
<p><b>FblCopyWatchdog</b></p>
<p>) or by the startup function. In </p>
<p>the first case, the watchdog trigger functions must be re-locatable (not really)! </p>
<p>The watchdog </p>
<p>trigger functions </p>
<p>have to be </p>
<p>relocatable! </p>
<p> </p>
<p>You  are  already  familiar  with  Figure  7-2.  The  main  attention  is  now  on  those </p>
<p>functions in which handling or manipulating the watchdog timer can take place. </p>
<p>  </p>
<p>©</p>
<p>2006, Vector Informatik GmbH </p>
<p> </p>
<p>Version: 2.7 </p>
<p> </p>
<p> </p>
<p>based of template version 2.0 </p>
<h1 style="page-break-before:always; "></h1>
<p>User Manual  Flash Bootloader </p>
<p> </p>
<p>48 / 56</p>
<p><b>Reset</b></p>
<p><b>ApplFblInit</b></p>
<p><b>ApplFblWDInit</b></p>
<p><b>Optional</b></p>
<p><b>: initialize WD</b></p>
<p><b>and set trigger time </b></p>
<p><b>*</b></p>
<p><b>[End of Initialization Phase]</b></p>
<p><b>ApplTrcvrNormalMode</b></p>
<p><b>Wait for Diagnostic Service to start Flash</b></p>
<p><b>ApplFblSecuritySeed</b></p>
<p><b>[Queried via KWP2000]</b></p>
<p><b>ApplFblSecurityKey</b></p>
<p><b>[Queried via KWP2000]</b></p>
<p>Download of flash algorithms</p>
<p><b>ApplFblSetVfp</b></p>
<p><b>ApplFblInvalidateApp</b></p>
<p><b>Erase Flash Memory</b></p>
<p><b>ApplFblSectorErase (opt.)</b></p>
<p><b>Download Application Data</b></p>
<p><b>ApplFblValidateApp</b></p>
<p><b>ApplFblResetVfp</b></p>
<p><b>ApplFblWDLong</b></p>
<p><b>ApplFblWDShort</b></p>
<p><b>FblStart</b></p>
<p><b>ApplFblIsValidApp</b></p>
<p><b>Optional</b></p>
<p><b>: initialize WD </b></p>
<p><b>and set trigger time </b></p>
<p><b>*</b></p>
<p><b>Application</b></p>
<p><b>Bootloader</b></p>
<p><b>Dependent on OEM</b></p>
<p>no</p>
<p>yes</p>
<p>OEM specific</p>
<p>wait time</p>
<p><b>ApplFblStartup</b></p>
<p><b>ApplFblCanParamInit</b></p>
<p><b>ApplFblWDTrigger</b></p>
<p><b>ApplFblFlashBlockNotFound</b></p>
<p> </p>
<p>Figure 7-2 </p>
<p>Functions For Manipulating The Watchdog </p>
<p>©</p>
<p>2006, Vector Informatik GmbH </p>
<p> </p>
<p>Version: 2.7 </p>
<p> </p>
<p> </p>
<p>based of template version 2.0 </p>
<h1 style="page-break-before:always; "></h1>
<p>User Manual  Flash Bootloader </p>
<p> </p>
<p>49 / 56</p>
<p><b>7.1.1 </b></p>
<p><b>Initializing The Watchdog </b></p>
<p>With some </p>
<p>watchdogs </p>
<p>double </p>
<p>initialization can </p>
<p>lead to a reset. </p>
<p>You can initialize the watchdog in one of two different places: either in the function </p>
<p><b>ApplFblInit</b></p>
<p> or in the function </p>
<p><b>ApplFblWDInit</b></p>
<p>. If you want to enable the watchdog </p>
<p>within the Stay-In-Boot time where the bootloader waits 50ms (default) to receive </p>
<p>the CAN message, then you have to do the initialization in the function </p>
<p><b>ApplFblInit</b></p>
<p>. </p>
<p>In that case the function </p>
<p><b>ApplFblWDInit</b></p>
<p> MUST remain empty.  </p>
<p>On  the  other  hand  it  is  also  true,  of  course,  that  if  you  initialize  in  the  function </p>
<p><b>ApplFblWDInit</b></p>
<p> you must not initialize in the function </p>
<p><b>ApplFblInit</b></p>
<p>. </p>
<p>Use WDTimer [in </p>
<p>ms] to easily set </p>
<p>your Watchdog </p>
<p>operating times. </p>
<p>The user should initialize the watchdog since this is hardware dependent. To find </p>
<p>your  register  settings  to  initialize  the  watchdog,  please  refer  to  the  controller </p>
<p>manual. </p>
<p>You can however use </p>
<p><b>WDTimer </b></p>
<p>for triggering. If you set </p>
<p><b>WDTimer</b></p>
<p> to </p>
<p><b>0</b></p>
<p>, then the </p>
<p>Watchdog will timeout immediately. The unit for </p>
<p><b>WDTimer</b></p>
<p> is ms. The Watchdog is </p>
<p>operated via the function ApplFblWDTrigger, which you have already adapted to </p>
<p>your needs (see 6.2.3.5 and 6.2.3.15). </p>
<p><b>Example: </b></p>
<p> </p>
<p>/* Initializing the WD, hardware-specific */ </p>
<p>WDTimer = 250/*ms*/;  /* in this way the Watchdog is triggered after 250ms.</p>
<p> </p>
<p> </p>
<p>Changing  the  value    of  WDTimer  will  only  influence  the  time  of  refreshing  the </p>
<p>watchdog for that particular cycle. The watchdog refresh rate will then be reinitialized </p>
<p>to the value set in fbl_cfg.h as soon as the watchdog is serviced. (see 2.4.2). </p>
<p>If your watchdog is a window watchdog, or at least supports different monitoring </p>
<p>windows and you want to use these as well, then you can use both of the functions </p>
<p><b>ApplFblWDLong</b></p>
<p> and </p>
<p><b>ApplFblWDShort</b></p>
<p> for toggling the monitoring times.  </p>
<p>Refer to the hardware-specific documentation </p>
<p><b>[#oem_wd]</b></p>
<p> for more information about </p>
<p>the watchdog. </p>
<p><b>7.2 </b></p>
<p><b>Multiple ECU Support </b></p>
<p>The  Flash  Bootloader  supports  multiple  ECUs  (When  similar  ECUs  are  used </p>
<p>multiple times in a vehicle, and their CAN identifiers are configurable). </p>
<p>This feature can be activated by setting the  </p>
<p>#define ‘FBL_ENABLE_MULTIPLE_NODES’ in the file fbl_cfg.h or via the </p>
<p>Generation Tool depending on your OEM. </p>
<p><b> </b></p>
<p><b>Refer to your OEM-specific Documentation </b></p>
<p><b>[#oem_multi]</b></p>
<p><b> to get the necessary </b></p>
<p><b>information</b></p>
<p>. </p>
<p> </p>
<p>©</p>
<p>2006, Vector Informatik GmbH </p>
<p> </p>
<p>Version: 2.7 </p>
<p> </p>
<p> </p>
<p>based of template version 2.0 </p>
<h1 style="page-break-before:always; "></h1>
<p>User Manual  Flash Bootloader </p>
<p> </p>
<p>50 / 56</p>
<p>If </p>
<p>multiple </p>
<p>ECUs </p>
<p>are </p>
<p>supported, </p>
<p>the </p>
<p>FBL </p>
<p>will </p>
<p>call </p>
<p>the </p>
<p>function </p>
<p><b>ApplFblCanParamInit()</b></p>
<p>, where the user has to decide which set of CAN identifiers </p>
<p>are used. Some OEMs set additional information, e.g. like identification of the ECU. </p>
<p><b>7.3 </b></p>
<p><b>Validation Ok – Application Faulty </b></p>
<p>As mentioned in the earlier chapter 4.3.1 the validity check may result in a positive </p>
<p>response and sign the application valid, even if the application itself is faulty. In that </p>
<p>case  every  reset  will  lead  to  an  application  that  does  not  work  properly  (for </p>
<p>example: The CAN communication of the application does not work anymore). </p>
<p>The  validation  process  does  not  recognize  the  problems  in  the  application  (e.g.  a </p>
<p>damaged byte in flash, etc.). </p>
<p> </p>
<p>How can you flash an error free application in that case?  </p>
<p>To do this it must be possible to react on a CAN message during the transition from </p>
<p>a reset to the application. Using the switch FBL_ENABLE_STAY_IN_BOOT in the </p>
<p>fbl_cfg.h</p>
<p> file (see 6.2.1) you get the following modified function calling sequence. </p>
<p> </p>
<p><b>Reset</b></p>
<p><b>ApplFblInit</b></p>
<p><b>ApplFblWDShort</b></p>
<p><b>ApplFblIsValidApp</b></p>
<p><b>Optional</b></p>
<p><b>: initialize</b></p>
<p><b>WD and set trigger </b></p>
<p><b>time</b></p>
<p><b>*</b></p>
<p><b>Application</b></p>
<p><b>Bootloader</b></p>
<p><b>FblStart</b></p>
<p><b>Stay in Boot Mode</b></p>
<p><b>ApplFblStartup</b></p>
<p>no</p>
<p><b>OEM specific</b></p>
<p><b>wait time</b></p>
<p>Timer expired</p>
<p>ForceBootMode</p>
<p>Message received</p>
<p>yes</p>
<p> </p>
<p>Figure 7-3 </p>
<p>Modified Function Calling Sequence </p>
<p>After  the  application  is  checked  to  be  valid  a  timer  is  started.  The  FBL  waits  a </p>
<p>default time (refer to OEM-Specific Documentation </p>
<p><b>[#oem_time]</b></p>
<p> ) to receive a CAN </p>
<p>message (ForceBootMode Message) as a trigger to stay in the boot mode. Now a </p>
<p>new flash process can be triggered. </p>
<p>©</p>
<p>2006, Vector Informatik GmbH </p>
<p> </p>
<p>Version: 2.7 </p>
<p> </p>
<p> </p>
<p>based of template version 2.0 </p>
<h1 style="page-break-before:always; "></h1>
<p>User Manual  Flash Bootloader </p>
<p> </p>
<p>51 / 56</p>
<p>If the timer expires with no receive message the application will be executed.  </p>
<p>With this mechanism it is now possible to flash an application, which had been set </p>
<p>valid erroneously. </p>
<p>The disadvantage is that the startup time will be longer (watchdog). </p>
<p><b>7.4 </b></p>
<p><b>FlashSegmentSize </b></p>
<p>The Flash Segment Size is a configurable parameter in the Flash Tool. </p>
<p>FlashSegment-</p>
<p>Size gives the </p>
<p>minimal size of </p>
<p>the data in bytes </p>
<p>which the </p>
<p>CANflasher can </p>
<p>write to at once. </p>
<p>Thus at least this </p>
<p>much data must </p>
<p>be written </p>
<p>simultaneously. </p>
<p>The size of </p>
<p>FlashSegment-</p>
<p>Size depends on </p>
<p>your hardware.</p>
<p>When  you  are  modifying  the </p>
<p><b>FlashSegmentSize</b></p>
<p>,  enter  the  smallest  segment  of </p>
<p>flash </p>
<p>memory </p>
<p>that </p>
<p>can </p>
<p>be </p>
<p>programmed </p>
<p>by </p>
<p>the </p>
<p>Flash </p>
<p>Bootloader </p>
<p>(hardware </p>
<p>dependent information </p>
<p><b>[#hw_size]</b></p>
<p>).  </p>
<p>In other words, a block must start at the beginning of a flash segment, for Flash </p>
<p>Bootloader to write to it. This specification depends on your hardware. The Flash </p>
<p>Tool needs this information in order to optimize the write process. The tool must </p>
<p>optimize exactly if area boundaries do not fall on flash block boundaries. </p>
<p>Enter the value for your Segment Size in the flash tool in the Flash File window. </p>
<p>(See FlashTool Documentation) </p>
<p><b>7.4.1 </b></p>
<p><b>Why Does The Tool Have To Know This Block Length? </b></p>
<p>In the following example let us take a Flash Bootloader that can write a minimum of </p>
<p>64 bytes; this corresponds to 40 in hexadecimal representation.  </p>
<p>0</p>
<p>40</p>
<p>80</p>
<p>C0</p>
<p>100</p>
<p>0</p>
<p>40</p>
<p>80</p>
<p>C0</p>
<p>100</p>
<p>0</p>
<p>40</p>
<p>80</p>
<p>C0</p>
<p>100</p>
<p>0</p>
<p>40</p>
<p>80</p>
<p>C0</p>
<p>100</p>
<p>0</p>
<p>40</p>
<p>80</p>
<p>C0</p>
<p>100</p>
<p>0</p>
<p>40</p>
<p>80</p>
<p>C0</p>
<p>100</p>
<p>Area of Application Data</p>
<p>Dummy Values</p>
<p> </p>
<p>Figure 7-4 </p>
<p>Segmenting During Flashing </p>
<p>In  the  first  example  the  data  area  to  be  written  to  (red)  is  distributed  over  3 </p>
<p>consecutive segments and does not start precisely at the beginning of a segment. </p>
<p>The Flash Bootloader then fills this gap with dummy values (gray) and in this way a </p>
<p>segment consisting of 3x64 bytes can be written to memory at once. The gap at the </p>
<p>end will be filled with the values that are already in the flash memory. </p>
<p>In the second example two data segments lay one after the other, but there is a </p>
<p>gap  between  them.  To  prevent  the  Flash  Bootloader  from  having  to  write  to  the </p>
<p>segment from 0x80 to 0xC0 twice, it also fills up the gap here and the region up to </p>
<p>the  next  segment  boundary  with  dummy  values,  and  now  a  segment  with  the </p>
<p>length of 4X64 bytes can be written to at once. The gap at the end will be filled with </p>
<p>the values that are already in the flash memory. </p>
<p>©</p>
<p>2006, Vector Informatik GmbH </p>
<p> </p>
<p>Version: 2.7 </p>
<p> </p>
<p> </p>
<p>based of template version 2.0 </p>
<h1 style="page-break-before:always; "></h1>
<p>User Manual  Flash Bootloader </p>
<p> </p>
<p>52 / 56</p>
<p>In the third example two data segments have to be written to here, too, but the gap </p>
<p>between them is greater than one segment. In this case, in order to not have to </p>
<p>write  to  a  completely  unused  segment,  the  Flash  Bootloader  now  divides  up  the </p>
<p>task  differently.  For  this  reason  the  segment  between  0x40  and  0x80  remains </p>
<p>empty here. </p>
<p><b>7.5 </b></p>
<p><b>Frequently Asked Questions </b></p>
<p>A list of frequently encountered problems is provided here to facilitate </p>
<p>troubleshooting. </p>
<p>  </p>
<p><b>7.5.1 </b></p>
<p><b>Bootloader Crashes </b></p>
<p> </p>
<p><b>Q: </b></p>
<p>The Bootloader simply crashes after reset </p>
<p><b>A: </b></p>
<p>Check if the Bootloader accidentally started the application – check </p>
<p>validity information by setting a breakpoint at </p>
<p><b>ApplFblIsValidApp</b></p>
<p>. </p>
<p>Also verify that the Bootloader and application locate the Application </p>
<p>Vector Table to the same address. </p>
<p> </p>
<p><b>Q: </b></p>
<p>I  can  start  the  download  but  the  software  crashes  when  the  Flash  is </p>
<p>erased </p>
<p><b>A: </b></p>
<p>The Bootloader may crash for several reasons: </p>
<p>1. </p>
<p>The Flash Driver was not correctly copied from ROM to RAM. Check if </p>
<p>the byte-array (</p>
<p><b>flashCode</b></p>
<p>) for the Flash Driver is large enough to hold </p>
<p>it. </p>
<p>1. </p>
<p>Check your watchdog routine. Check if the byte-array for the watchdog </p>
<p>function (</p>
<p><b>WDTriggerBuffer</b></p>
<p>) is large enough to hold the watchdog </p>
<p>function. </p>
<p>2. </p>
<p>Check that the watchdog trigger function is relocatable. </p>
<p>3. </p>
<p>Check the </p>
<p><b>FlashBlock</b></p>
<p> structure in the “fbl_apfb.c” file. Make sure that </p>
<p>the memory area occupied by the Bootloader is excluded from the </p>
<p><b>FlashBlock</b></p>
<p> structure. </p>
<p> </p>
<p><b>Q: </b></p>
<p>The Flash is erased, but the Bootloader crashes before the application is </p>
<p>downloaded. </p>
<p><b>A: </b></p>
<p>Check the </p>
<p><b>FlashBlock</b></p>
<p> structure in the “fbl_apfb.c” file. Make sure that the </p>
<p>memory area occupied by the Bootloader is excluded from the </p>
<p><b>FlashBlock</b></p>
<p> structure. </p>
<p> </p>
<p><b>Q: </b></p>
<p>I  can  start  the  Bootloader  software  but  after  some  time,  the  Bootloader </p>
<p>crashes </p>
<p>©</p>
<p>2006, Vector Informatik GmbH </p>
<p> </p>
<p>Version: 2.7 </p>
<p> </p>
<p> </p>
<p>based of template version 2.0 </p>
<h1 style="page-break-before:always; "></h1>
<p>User Manual  Flash Bootloader </p>
<p> </p>
<p>53 / 56</p>
<p><b>A: </b></p>
<p>4. </p>
<p>Check your watchdog routine. Check if the byte-array for the watchdog </p>
<p>function (</p>
<p><b>WDTriggerBuffer</b></p>
<p>) is large enough to hold the watchdog </p>
<p>function. </p>
<p>5. </p>
<p>Check that the watchdog trigger function is relocatable. </p>
<p>Disable watchdog for testing purpose. </p>
<p> </p>
<p><b>Q: </b></p>
<p>The Bootloader crashes when programming a specific Logical Block </p>
<p><b>A: </b></p>
<p>Check the </p>
<p><b>FlashBlock</b></p>
<p> structure in the “fbl_apfb.c” file. Make sure that the </p>
<p>memory area occupied by the Bootloader is excluded from the </p>
<p><b>FlashBlock</b></p>
<p> structure. Also make sure to exclude non-Flash (RAM, </p>
<p>Registers, EEPROM) areas from the </p>
<p><b>FlashBlock</b></p>
<p> structure. </p>
<p> </p>
<p><b>Q: </b></p>
<p>The Bootloader is cyclically restarted </p>
<p><b>A: </b></p>
<p>1. </p>
<p>Check your watchdog routine. Check if the hardware watchdog is </p>
<p>serviced correctly. Disable watchdog for testing purpose. </p>
<p>2. </p>
<p>Maybe the application was started and didn’t trigger the watchdog. </p>
<p>Check validity information. </p>
<p> </p>
<p> </p>
<p><b>Q: </b></p>
<p>I  can  start  the  download  but  sometimes,  the  transfer  is  aborted  with  a </p>
<p>timeout. </p>
<p><b>A: </b></p>
<p>1. </p>
<p>Check the watchdog timeout and watchdog trigger </p>
<p>2. </p>
<p>Check the setting of the FBL_DIAG_TIME_P3MAX and the diagnostic </p>
<p>response timeout of your Tester/the Flash programming tool. The </p>
<p>Bootloader must transmit cyclic “Response Pending” messages on the </p>
<p>bus. You may check this with a CANoe/CANalyzer tool. </p>
<p> </p>
<p><b>7.5.2 </b></p>
<p><b>Application Is Not Started </b></p>
<p> </p>
<p><b>Q: </b></p>
<p>I  can  download  the  application,  but  after  a  reset  the  Bootloader  is  still </p>
<p>active </p>
<p><b>A: </b></p>
<p>There could be different reasons for this: </p>
<p></p>
<p> </p>
<p>Check the validity information. Set a breakpoint in </p>
<p><b>ApplFblIsValidApp</b></p>
<p> </p>
<p>and verify it. Did you download all necessary parts of the application?   </p>
<p> </p>
<p><b>Q: </b></p>
<p>When I download the application for the first time and restart the ECU, the </p>
<p>application  is  running.  If  I  reprogram  the  application,  the  Bootloader  is </p>
<p>active after reset. </p>
<p>©</p>
<p>2006, Vector Informatik GmbH </p>
<p> </p>
<p>Version: 2.7 </p>
<p> </p>
<p> </p>
<p>based of template version 2.0 </p>
<h1 style="page-break-before:always; "></h1>
<p>User Manual  Flash Bootloader </p>
<p> </p>
<p>54 / 56</p>
<p><b>A: </b></p>
<p>Check if the reprogramming flag for the Bootloader is correctly reset after </p>
<p>starting the Bootloader. </p>
<p> </p>
<p> </p>
<p><b>7.5.3 </b></p>
<p><b>Bootloader Is Not Started </b></p>
<p> </p>
<p><b>Q: </b></p>
<p>I can download the application and the application is running, but I cannot </p>
<p>reprogram the application </p>
<p><b>A: </b></p>
<p>Check if the reprogramming flag for the Bootloader is set.  </p>
<p> </p>
<p><b>7.5.4 </b></p>
<p><b>The Flash Tool's Error Codes </b></p>
<p><b>Q: </b></p>
<p>How can I interpret the error codes of the Flash Tool?  </p>
<p><b>A: </b></p>
<p>Find the error code that occurred during flashing from the table in </p>
<p>fbl_diag.h to be help narrow down your search for the cause. </p>
<p> </p>
<p> </p>
<p> </p>
<p>©</p>
<p>2006, Vector Informatik GmbH </p>
<p> </p>
<p>Version: 2.7 </p>
<p> </p>
<p> </p>
<p>based of template version 2.0 </p>
<h1 style="page-break-before:always; "></h1>
<p>User Manual  Flash Bootloader </p>
<p> </p>
<p>2 / 56</p>
<p><b>8 </b></p>
<p><b>Index </b></p>
<p>ApplFblInit................................................... 51 </p>
<p>ApplFblInvalidateApp...................... 19, 20, 41 </p>
<p>ApplFblIsValidApp .................... 18, 19, 20, 40 </p>
<p>ApplFblValidateApp ........................ 19, 20, 42 </p>
<p>ApplFblWDInit............................................. 51 </p>
<p>Bootloader . 11, 12, 13, 14, 17, 18, 19, 20, 21, </p>
<p>25, 26, 33, 36, 38, 40, 42, 46, 47, 51, 53, </p>
<p>54 </p>
<p>Call-Back Functions </p>
<p>ApplFblStartup........................................ 40 </p>
<p>Call-Back Functions </p>
<p>AplFblWDTrigger.................................... 38 </p>
<p>ApplCanParamInit .................................. 38 </p>
<p>ApplFblFlashBlockNotFound.................. 38 </p>
<p>ApplFblInit............................................... 38 </p>
<p>ApplFblInvalidateBlock........................... 38 </p>
<p>ApplFblIsValidApp.................................. 38 </p>
<p>ApplFblResetVfp .................................... 38 </p>
<p>ApplFblSetVfp ........................................ 38 </p>
<p>ApplFblStartup........................................ 38 </p>
<p>ApplFblTask ........................................... 38 </p>
<p>ApplFblWDInit ........................................ 38 </p>
<p>ApplFblWDLong ..................................... 38 </p>
<p>ApplFblWDShort..................................... 38 </p>
<p>ApplTrcvrNormalMode ........................... 38 </p>
<p>FBL_MTAB ................................................. 23 </p>
<p>Flash Tool ................................................... 11 </p>
<p>Flashcode ................................................... 19 </p>
<p>Flashing....................................................... 13 </p>
<p>FlashSegmentSize...................................... 53 </p>
<p>Initializing .................................................... 51 </p>
<p>interrupt vector tables.................................. 25 </p>
<p>Interrupt Vector Tables ............................... 25 </p>
<p>Invalidate.........................................19, 21, 22 </p>
<p>IsValid .............................................19, 21, 22 </p>
<p>KWP2000.................................................... 13 </p>
<p>Label Reference File................................... 26 </p>
<p>Module Table .............................................. 23 </p>
<p>Motivation...................................................... 3 </p>
<p>Proposal..........................................21, 22, 24 </p>
<p>RAM ......................................................15, 19 </p>
<p>Reset...............................................18, 26, 46 </p>
<p>Segment Boundary ..................................... 53 </p>
<p>Step.......................................................46, 47 </p>
<p>The Interrupt Vector Table .......................... 44 </p>
<p>valid...........................................19, 20, 21, 22 </p>
<p>Validate ...........................................19, 21, 22 </p>
<p>Validation Area..........................19, 20, 21, 22 </p>
<p>validity ...................................................20, 21 </p>
<p>vectortable.c................................................ 44 </p>
<p>Watchdog..................................40, 42, 43, 51 </p>
<p>ApplFblWDTrigger .................................. 48 </p>
<p>FblCopyWatchdog .................................. 49 </p>
<p>FblLookForWatchdog ............................. 48 </p>
<p>Watchdogs ............................................40, 49 </p>
<p>WDTimer ..................................................... 51 </p>
<p> </p>
<p>©</p>
<p>2006, Vector Informatik GmbH </p>
<p> </p>
<p>Version: 2.7 </p>
<p> </p>
<p> </p>
<p>based of template version 2.0 </p>
</body>
</html>
{% endraw %}