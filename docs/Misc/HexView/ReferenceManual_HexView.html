---
layout: default
title: ReferenceManual_HexView
nav_order: 1
parent: Misc
---
{% raw %}
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
     "http://www.w3.org/TR/html4/transitional.dtd">
<html>
<head>

  <meta http-equiv="content-type" content="text/html; charset=utf-8"/>
  <title></title>
  <meta name="generator" content="LibreOffice 24.2.7.2 (Linux)"/>
  <meta name="created" content="00:00:00"/>
  <meta name="changed" content="00:00:00"/>
</head>
<body>
<h1></h1>
<p>Reference Manual HexView </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 1.12.02 </p>
<p>1 </p>
<p>based on template version 5.1.0 </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p><b>HexView </b></p>
<p>Reference Manual </p>
<p> </p>
<p>  </p>
<p>Version 1.12.02 </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>Vector Informatik GmbH is furnishing this item “as is” and free of charge. Vector </p>
<p>Informatik  GmbH  does  not </p>
<p>provide  any </p>
<p>warranty  of  the  item  whatsoever, </p>
<p>whether express, implied, or statutory, including, but not limited to, any warranty </p>
<p>of  merchantability  or  fitness  for  a  particular  purpose  or  any  warranty  that  the </p>
<p>contents of the item will be error-free. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p> </p>
<p>Authors </p>
<p>Armin Happel </p>
<p>Status </p>
<p>Released </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Reference Manual HexView </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 1.12.02 </p>
<p>2 </p>
<p>based on template version 5.1.0 </p>
<p><b>Document Information </b></p>
<p><b>History </b></p>
<p><b>Author </b></p>
<p><b>Date </b></p>
<p><b>Version </b></p>
<p><b>Remarks </b></p>
<p>Vishp </p>
<p>2018-05-10 </p>
<p>1.12.02 </p>
<p><b>&gt; </b></p>
<p>Fiat container files not generated correctly </p>
<p><b>&gt; </b></p>
<p>Neg. Hex-values not accepted </p>
<p><b>&gt; </b></p>
<p>Public key hash overwritten when merging </p>
<p>VBF </p>
<p><b>&gt; </b></p>
<p>Sw_signature may written with no contents. </p>
<p>Vishp </p>
<p>2018-02-13 </p>
<p>1.12.01 </p>
<p><b>&gt; </b></p>
<p>Fill operation with random data failed </p>
<p><b>&gt; </b></p>
<p>Improve handling of LoadAddress for s-rec. </p>
<p>Vishp </p>
<p>2018-02-05 </p>
<p>1.12.00 </p>
<p><b>&gt; </b></p>
<p>Fix range operation issues in V1.11 if not </p>
<p>starting on block start address. </p>
<p><b>&gt; </b></p>
<p>Fix checksum calculation issues of V1.11 for </p>
<p>restricted ranges or checksum target </p>
<p>address is located inside the csum data. </p>
<p><b>&gt; </b></p>
<p>Remove BAFA restrictions to crypto </p>
<p>operations. </p>
<p><b>&gt; </b></p>
<p>Restricting compression/decompression to </p>
<p>non-streaming operations. </p>
<p><b>&gt; </b></p>
<p>Fixing verification_structure_address output </p>
<p>for Ford-VBF V3.1. </p>
<p><b>&gt; </b></p>
<p>Fix startup issue on some Windows10 PCs </p>
<p><b>&gt; </b></p>
<p>Improved Hexview return codes </p>
<p>Vishp </p>
<p>2017-08-03 </p>
<p>1.11.01 </p>
<p><b>&gt; </b></p>
<p>Performance improvements for large files </p>
<p>operation (compared to 1.11.00). </p>
<p><b>&gt; </b></p>
<p>Fix VBF generation issue. </p>
<p><b>&gt; </b></p>
<p>Substitute binaries for VBF without changing </p>
<p>the VBF header (/xvbfsubst). </p>
<p>Vishp </p>
<p>2017-06-09 </p>
<p>1.11.00 </p>
<p><b>&gt; </b></p>
<p>Switches /gmal and /gmad for separate GM </p>
<p>header alignment operations </p>
<p><b>&gt; </b></p>
<p>Support for further VCC VBF version. </p>
<p><b>&gt; </b></p>
<p>Support for further Ford VBF version. </p>
<p><b>&gt; </b></p>
<p>Support for ed25519 signature </p>
<p><b>&gt; </b></p>
<p>Remove encryption from standard package </p>
<p>due to BAFA export restrictions. </p>
<p><b>&gt; </b></p>
<p>Support for GM compression (0302) and </p>
<p>BDL (0601) envelope types. </p>
<p><b>&gt; </b></p>
<p>Support for signature verification </p>
<p><b>&gt; </b></p>
<p>Support large files (see release notes). </p>
<p>Vishp </p>
<p>2017-03-09 </p>
<p>1.10.04 </p>
<p><b>&gt; </b></p>
<p>Tag length calculation for validation structure </p>
<p>corrected. </p>
<p><b>&gt; </b></p>
<p>GM SLP5: Extend use of of cal-files from 20 </p>
<h1 style="page-break-before:always; "></h1>
<p>Reference Manual HexView </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 1.12.02 </p>
<p>3 </p>
<p>based on template version 5.1.0 </p>
<p>to 128. </p>
<p><b>&gt; </b></p>
<p>Extend number of regions from 32 to 256. </p>
<p><b>&gt; </b></p>
<p>Extend number of partitions from 20 to 128. </p>
<p><b>&gt; </b></p>
<p>Allow usage of CAL module IDs from 51 to </p>
<p>70. Removed them as application modules. </p>
<p>Vishp </p>
<p>2016-09-05 </p>
<p>1.10.01 </p>
<p><b>&gt; </b></p>
<p>Fixing dialog problem with HEX ASCII export </p>
<p><b>&gt; </b></p>
<p>Allow long lines for HEX ASCII exports </p>
<p><b>&gt; </b></p>
<p>Introduce /CSR for reverse csum output </p>
<p><b>&gt; </b></p>
<p>Multiple modules for GM SLP4 export </p>
<p><b>&gt; </b></p>
<p>DataTypes can be specified for GM cmpr. </p>
<p>Sign. (envelope 3) </p>
<p><b>&gt; </b></p>
<p>Value input with leading 0 no longer leads to </p>
<p>interpretation of octal values. </p>
<p>Vishp </p>
<p>2016-03-18 </p>
<p>1.10.00 </p>
<p><b>&gt; </b></p>
<p>MISRA and strict ANSI for C-File generation </p>
<p>improved. </p>
<p><b>&gt; </b></p>
<p>Extensions to expdatproc (RSA-PSS, RSA-</p>
<p>OAEP) </p>
<p><b>&gt; </b></p>
<p>Hexview returned error codes even if no </p>
<p>error was detected. </p>
<p><b>&gt; </b></p>
<p>Checksum calculation over holes revised. </p>
<p><b>&gt; </b></p>
<p>Support PKCS#1, PKCS#8 and X.509 </p>
<p>certificates as file input for RSA operations </p>
<p>(without passwords). </p>
<p>Vishp </p>
<p>2016-01-21 </p>
<p>1.09.04 </p>
<p><b>&gt; </b></p>
<p>Correcting data processing operations. </p>
<p>Vishp </p>
<p>2015-08-28 </p>
<p>1.09.03 </p>
<p><b>&gt; </b></p>
<p>Allow sw_version in VBF V2.5 with no char. </p>
<p><b>&gt; </b></p>
<p>RSA operation with public key only fails. </p>
<p><b>&gt; </b></p>
<p>16-Bit Intel import doesn’t allow segment </p>
<p>wrapping. </p>
<p>Vishp </p>
<p>2015-07-25 </p>
<p>1.09.02 </p>
<p><b>&gt; </b></p>
<p>Limited RSA operation with private key </p>
<p><b>&gt; </b></p>
<p>Importing binary data over commandline </p>
<p><b>&gt; </b></p>
<p>Improved ASCII import. </p>
<p><b>&gt; </b></p>
<p>Hexview version reported in logfile. </p>
<p><b>&gt; </b></p>
<p>Unknown commandline options reported in </p>
<p>logfile. </p>
<p><b>&gt; </b></p>
<p>Referencing alternative expdatproc.dll </p>
<p>Vishp </p>
<p>2015-04-13 </p>
<p>1.09.01 </p>
<p><b>&gt; </b></p>
<p>Validation struct inserted as separate block. </p>
<p><b>&gt; </b></p>
<p>Support for VBF V4.0 </p>
<p><b>&gt; </b></p>
<p>Support splitting big block into smaller junks </p>
<p>Vishp </p>
<p>2014-01-16 </p>
<p>1.09.00 </p>
<p><b>&gt; </b></p>
<p>Import and Export of MIME coded files </p>
<p>(BASE64) </p>
<p><b>&gt; </b></p>
<p>Correct description of /remap in the </p>
<p>commandline overview  </p>
<p><b>&gt; </b></p>
<p>New expdatproc included, rework RSA </p>
<h1 style="page-break-before:always; "></h1>
<p>Reference Manual HexView </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 1.12.02 </p>
<p>4 </p>
<p>based on template version 5.1.0 </p>
<p>encryption/decryption, crypto-library </p>
<p>replaced with Vector crypto-lib.. </p>
<p><b>&gt; </b></p>
<p>ARLE compression/decompression added. </p>
<p><b>&gt; </b></p>
<p>Support GM compressed envelope </p>
<p><b>&gt; </b></p>
<p>Incorrect length of imported MIME data </p>
<p><b>&gt; </b></p>
<p>Wrong update of erase information in ini file </p>
<p>for VBF </p>
<p><b>&gt; </b></p>
<p>Message &quot;out of memory&quot; displayed when </p>
<p>opening BIN-files </p>
<p><b>&gt; </b></p>
<p>File type recognition failure with files that </p>
<p>have no extensions </p>
<p><b>&gt; </b></p>
<p>Checksum calculation over a fixed range, </p>
<p>even if there are wholes in the internal data </p>
<p>Commandline: /cs&lt;csum-method-</p>
<p>number&gt;:@&lt;address&gt;;!&lt;range&gt;|&lt;fillpattern&gt; </p>
<p>Example: /cs9:@0x8000;!0x9000-</p>
<p>0xBFFF|CAFÉ </p>
<p>Vishp </p>
<p>2014-05-19 </p>
<p>1.08.06 </p>
<p><b>&gt; </b></p>
<p>Export/Import of GAC binary files </p>
<p>Vishp </p>
<p>2014-04-07 </p>
<p>1.08.05 </p>
<p><b>&gt; </b></p>
<p>Commandline option to export MIME coded </p>
<p>files </p>
<p>Vishp </p>
<p>2014-03-11 </p>
<p>1.08.04 </p>
<p><b>&gt; </b></p>
<p>Correcting padding mode for AES </p>
<p><b>&gt; </b></p>
<p>Add support for IV-Vector w/ AES-CBC </p>
<p><b>&gt; </b></p>
<p>Support for VBF V3.0 (Ford) </p>
<p><b>&gt; </b></p>
<p>Improvements for the GM-header signature </p>
<p>generation for cyber security. </p>
<p><b>&gt; </b></p>
<p>Corrections on address range definition for </p>
<p>data processing. </p>
<p><b>&gt; </b></p>
<p>Ford-VBF allows now to omit the erase </p>
<p>table. Editable now in the GUI. </p>
<p><b>&gt; </b></p>
<p>Call to CANflash removed. </p>
<p><b>&gt; </b></p>
<p>Description for validation structure </p>
<p>generation added. </p>
<p><b>&gt; </b></p>
<p>Support multiple part numbers for VBF </p>
<p><b>&gt; </b></p>
<p>Merging files over commandline supports </p>
<p>now wildcards. </p>
<p><b>&gt; </b></p>
<p>Order of identifiers for VBF corrected. </p>
<p><b>&gt; </b></p>
<p>Expdatproc V1.08.04 added </p>
<p><b>&gt; </b></p>
<p>RSA encryption/decryption byte order </p>
<p>corrected. </p>
<p><b>&gt; </b></p>
<p>Padding mode for AES corrected </p>
<p><b>&gt; </b></p>
<p>IV can be specified explicitly for AES </p>
<p>CBC in the parameter </p>
<p>Vishp </p>
<p>2012-09-15 </p>
<p>1.08.00 </p>
<p><b>&gt; </b></p>
<p>Solving further Win7 problems in dialogs. </p>
<p><b>&gt; </b></p>
<p>Adding SHA256 in checksum and data </p>
<h1 style="page-break-before:always; "></h1>
<p>Reference Manual HexView </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 1.12.02 </p>
<p>5 </p>
<p>based on template version 5.1.0 </p>
<p>processing DLL </p>
<p><b>&gt; </b></p>
<p>Record type specifier in the commandline for </p>
<p>Intel-HEX and Motorola S-Records. </p>
<p><b>&gt; </b></p>
<p>Add import and Export for HEX ASCII data </p>
<p>through commandline </p>
<p><b>&gt; </b></p>
<p>Generate signature header for GM </p>
<p><b>&gt; </b></p>
<p>Support for VBF V2.5 (Volvo) </p>
<p>Vishp </p>
<p>2011-12-05 </p>
<p>1.07.00 </p>
<p><b>&gt; </b></p>
<p>Fixing Windows7 problems in dialogs. </p>
<p><b>&gt; </b></p>
<p>Faster HEX read operation </p>
<p><b>&gt; </b></p>
<p>Support dsPIC copy and ghost byte </p>
<p>clearance </p>
<p><b>&gt; </b></p>
<p>Export splitted binary data files per segment </p>
<p><b>&gt; </b></p>
<p>Add checksum to last data bytes (@end) </p>
<p><b>&gt; </b></p>
<p>Further support for compress+sign  </p>
<p><b>&gt; </b></p>
<p>Padding for data encryption </p>
<p><b>&gt; </b></p>
<p>Scanning memory for EepM data (for </p>
<p>development) </p>
<p><b>&gt; </b></p>
<p>S5 records are now tolerated. </p>
<p><b>&gt; </b></p>
<p>Swapping words or longwords </p>
<p>Vishp </p>
<p>2010-10-11 </p>
<p>1.06.04 </p>
<p><b>&gt; </b></p>
<p>AccessParameter for Fiat export now </p>
<p>editable. </p>
<p><b>&gt; </b></p>
<p>Export binary blocks from commandline </p>
<p>interface </p>
<p>Vishp </p>
<p>2009-11-27 </p>
<p>1.06.01 </p>
<p><b>&gt; </b></p>
<p>Fixing problems with path names using a </p>
<p>colon, e.g. “D:” </p>
<p><b>&gt; </b></p>
<p>Minor corrections in the documentation </p>
<p>(CRC calculation algorithms) </p>
<p>Vishp </p>
<p>2009-05-19 </p>
<p>1.6 </p>
<p><b>&gt; </b></p>
<p>Description of new features for V1.6 </p>
<p><b>&gt; </b></p>
<p>Fixing problem when HEX-file contain </p>
<p>addresses until 0xFFFF.FFFF </p>
<p><b>&gt; </b></p>
<p>Extend expdatproc interface to allow </p>
<p>insertion of data processing results into </p>
<p>HEX-file </p>
<p><b>&gt; </b></p>
<p>Now browse for data processing parameter </p>
<p>file </p>
<p><b>&gt; </b></p>
<p>Intel-HEX record length now adjustable </p>
<p><b>&gt; </b></p>
<p>This document can now be opened from </p>
<p>Help menu </p>
<p><b>&gt; </b></p>
<p>Allow to select multiple post build files </p>
<p><b>&gt; </b></p>
<p>Generate structured hex file from Eeprom </p>
<p>data set </p>
<p><b>&gt; </b></p>
<p>C-array generation supports structured list, </p>
<p>Ansi-C and memmap. </p>
<p>Vishp </p>
<p>2008-01-31 </p>
<p>1.5 </p>
<p><b>&gt; </b></p>
<p>Fixing wrong description of checksum </p>
<h1 style="page-break-before:always; "></h1>
<p>Reference Manual HexView </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 1.12.02 </p>
<p>6 </p>
<p>based on template version 5.1.0 </p>
<p>calculation for method 8 (see Table 3-3, </p>
<p>index 8) </p>
<p>Vishp </p>
<p>2007-09-19 </p>
<p>1.4 </p>
<p><b>&gt; </b></p>
<p>Description of new features for V1.5 </p>
<p><b>&gt; </b></p>
<p>Start CANflash from within Hexview </p>
<p><b>&gt; </b></p>
<p>Create partial datafiles for Fiat-export </p>
<p><b>&gt; </b></p>
<p>Support VBF V2.4 for Ford </p>
<p><b>&gt; </b></p>
<p>Support Align Erase (/AE) </p>
<p><b>&gt; </b></p>
<p>Use ranges instead of start and end address </p>
<p><b>&gt; </b></p>
<p>Creation of a validation structure </p>
<p><b>&gt; </b></p>
<p>New About-dialog with personalized license </p>
<p>info </p>
<p>Vishp </p>
<p>2007-07-09 </p>
<p>1.31 </p>
<p><b>&gt; </b></p>
<p>Description of new features for V1.4.6 </p>
<p><b>&gt; </b></p>
<p>Support part number in GM-files (option /pn) </p>
<p>from the commandline and reading the file </p>
<p>Vishp </p>
<p>2006-12-07 </p>
<p>1.3 </p>
<p><b>&gt; </b></p>
<p>Description of new features for V1.4.0 </p>
<p><b>&gt; </b></p>
<p>Commandline: Checksum operates on </p>
<p>selected section. Multiple checksum areas </p>
<p>can be specified from the commandline. </p>
<p><b>&gt; </b></p>
<p>Postbuild operation added </p>
<p><b>&gt; </b></p>
<p>Fixing Ford IHex configuration problem for </p>
<p>flashindicator and File-Browse in the dialog </p>
<p><b>&gt; </b></p>
<p>Option /CR (cut-section) added to the </p>
<p>commandline </p>
<p><b>&gt; </b></p>
<p>Delete and  Cut&amp;paste with internal </p>
<p>clipboard added. </p>
<p><b>&gt; </b></p>
<p>Description of the commandline processing </p>
<p>order added to the document </p>
<p><b>&gt; </b></p>
<p>Program returns a value depending on the </p>
<p>status of operation </p>
<p><b>&gt; </b></p>
<p>New option combination /XG with /MPFH to </p>
<p>re-position existing NOAM to adjusted </p>
<p>NOAR-fields </p>
<p><b>&gt; </b></p>
<p>Goto start of a block (double-click to block </p>
<p>descriptor)  </p>
<p><b>&gt; </b></p>
<p>Find ASCII string in data was added </p>
<p>Vishp </p>
<p>2006-09-27 </p>
<p>1.2 </p>
<p><b>&gt; </b></p>
<p>Description of new features for V1.3.0 </p>
<p><b>&gt; </b></p>
<p>Merge and compare uses now the auto-</p>
<p>filetype detection </p>
<p><b>&gt; </b></p>
<p>Merge operation available from </p>
<p>commandline </p>
<p><b>&gt; </b></p>
<p>Address calculation from banked to linear </p>
<p>addresses from commandline </p>
<p><b>&gt; </b></p>
<p>Checksum calculation feature from </p>
<p>commandline places results into file or data. </p>
<h1 style="page-break-before:always; "></h1>
<p>Reference Manual HexView </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 1.12.02 </p>
<p>7 </p>
<p>based on template version 5.1.0 </p>
<p>Vishp </p>
<p>2006-07-14 </p>
<p>1.1 </p>
<p><b>&gt; </b></p>
<p>Description of new features for V1.2.0 </p>
<p><b>&gt; </b></p>
<p>Main features are: </p>
<p><b>&gt; </b></p>
<p>Support for Ford-VBF and Ford-IHex in </p>
<p>dialogs </p>
<p><b>&gt; </b></p>
<p>Compare-Feature </p>
<p><b>&gt; </b></p>
<p>Auto-detect file format on file open/save </p>
<p>Vishp </p>
<p>2006-02-21 </p>
<p>1.0 </p>
<p><b>&gt; </b></p>
<p>Creation </p>
<p><b>Reference Documents </b></p>
<p><b>No. </b></p>
<p><b>Title </b></p>
<p>[1] </p>
<p>Fiat-Specification 07284-01, dated 2003-05-15 </p>
<p>[2] </p>
<p>Ford/Volvo: Versatile Binary Format V2.2, V2.3, V2.4, V2.5, V2.6, V3.0, V3.1, JLR3.0 </p>
<p>[3] </p>
<p>Ford: Module programming and Design specification, V2003.0 </p>
<p>[4] </p>
<p>GM: GMW3110, V1.5, chapter 11 </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p><b> </b></p>
<h1 style="page-break-before:always; "></h1>
<p>Reference Manual HexView </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 1.12.02 </p>
<p>8 </p>
<p>based on template version 5.1.0 </p>
<p><b>Contents </b></p>
<p><b>1</b></p>
<p> </p>
<p><b>Introduction .................................................................................................................. 14</b></p>
<p> </p>
<p>1.1</p>
<p> </p>
<p>Important notes ...................................................................................................... 15</p>
<p> </p>
<p>1.2</p>
<p> </p>
<p>Release notes ........................................................................................................ 15</p>
<p> </p>
<p>1.2.1</p>
<p> </p>
<p>Hexview 1.12.00 ............................................................................................ 15</p>
<p> </p>
<p>1.2.2</p>
<p> </p>
<p>Hexview V1.11.00 ......................................................................................... 15</p>
<p> </p>
<p><b>2</b></p>
<p> </p>
<p><b>User Interface ............................................................................................................... 17</b></p>
<p> </p>
<p>2.1</p>
<p> </p>
<p>A Double Click into the main window ...................................................................... 18</p>
<p> </p>
<p>2.1.1</p>
<p> </p>
<p>Edit a HEX data line ...................................................................................... 18</p>
<p> </p>
<p>2.1.2</p>
<p> </p>
<p>Change the base address of a data block, erase it or jump directly to the </p>
<p>beginning of the block data............................................................................ 18</p>
<p> </p>
<p>2.2</p>
<p> </p>
<p>Menu ...................................................................................................................... 19</p>
<p> </p>
<p>2.2.1</p>
<p> </p>
<p>Menu: “File” ................................................................................................... 19</p>
<p> </p>
<p>2.2.1.1</p>
<p> </p>
<p>New ........................................................................................................ 19</p>
<p> </p>
<p>2.2.1.2</p>
<p> </p>
<p>Open ...................................................................................................... 19</p>
<p> </p>
<p>2.2.1.2.1</p>
<p> </p>
<p>Auto-file format analysing process ................................................... 19</p>
<p> </p>
<p>2.2.1.3</p>
<p> </p>
<p>Merge ..................................................................................................... 20</p>
<p> </p>
<p>2.2.1.4</p>
<p> </p>
<p>Compare ................................................................................................ 21</p>
<p> </p>
<p>2.2.1.5</p>
<p> </p>
<p>Save ....................................................................................................... 22</p>
<p> </p>
<p>2.2.1.6</p>
<p> </p>
<p>Save as .................................................................................................. 22</p>
<p> </p>
<p>2.2.1.7</p>
<p> </p>
<p>Log Commands ...................................................................................... 22</p>
<p> </p>
<p>2.2.1.8</p>
<p> </p>
<p>Import ..................................................................................................... 22</p>
<p> </p>
<p>2.2.1.8.1</p>
<p> </p>
<p>Import Intel-Hex/Motorola S-Record ................................................ 23</p>
<p> </p>
<p>2.2.1.8.2</p>
<p> </p>
<p>Read 16-Bit Intel Hex....................................................................... 23</p>
<p> </p>
<p>2.2.1.8.3</p>
<p> </p>
<p>Import binary data ............................................................................ 23</p>
<p> </p>
<p>2.2.1.8.4</p>
<p> </p>
<p>Import HEX ASCII ............................................................................ 23</p>
<p> </p>
<p>2.2.1.8.5</p>
<p> </p>
<p>Import GM data................................................................................ 23</p>
<p> </p>
<p>2.2.1.8.6</p>
<p> </p>
<p>Import Fiat data ............................................................................... 23</p>
<p> </p>
<p>2.2.1.8.7</p>
<p> </p>
<p>Import Ford Ihex data ...................................................................... 23</p>
<p> </p>
<p>2.2.1.8.8</p>
<p> </p>
<p>Import Ford VBF data ...................................................................... 23</p>
<p> </p>
<p>2.2.1.8.9</p>
<p> </p>
<p>Import GAC binary file ..................................................................... 23</p>
<p> </p>
<p>2.2.1.9</p>
<p> </p>
<p>Export ..................................................................................................... 24</p>
<p> </p>
<p>2.2.1.9.1</p>
<p> </p>
<p>Export as S-Record ......................................................................... 24</p>
<p> </p>
<p>2.2.1.9.2</p>
<p> </p>
<p>Export as Intel-HEX ......................................................................... 25</p>
<p> </p>
<p>2.2.1.9.3</p>
<p> </p>
<p>Export as HEX-ASCII....................................................................... 25</p>
<p> </p>
<p>2.2.1.9.4</p>
<p> </p>
<p>Export as CCP Flashkernel .............................................................. 26</p>
<p> </p>
<p>2.2.1.9.5</p>
<p> </p>
<p>Export as C-Array ............................................................................ 28</p>
<p> </p>
<p>2.2.1.9.6</p>
<p> </p>
<p>Export Mime coded data .................................................................. 31</p>
<p> </p>
<p>2.2.1.9.7</p>
<p> </p>
<p>Export Binary data ........................................................................... 31</p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Reference Manual HexView </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 1.12.02 </p>
<p>9 </p>
<p>based on template version 5.1.0 </p>
<p>2.2.1.9.8</p>
<p> </p>
<p>Export binary block data .................................................................. 32</p>
<p> </p>
<p>2.2.1.9.9</p>
<p> </p>
<p>Export Fiat Binary File ..................................................................... 32</p>
<p> </p>
<p>2.2.1.9.10</p>
<p> </p>
<p>Export Ford Ihex data container ....................................................... 33</p>
<p> </p>
<p>2.2.1.9.11</p>
<p> </p>
<p>Export Ford VBF data container ...................................................... 34</p>
<p> </p>
<p>2.2.1.9.12</p>
<p> </p>
<p>Export GM data ............................................................................... 35</p>
<p> </p>
<p>2.2.1.9.13</p>
<p> </p>
<p>Export GM-FBL header info ............................................................. 36</p>
<p> </p>
<p>2.2.1.9.14</p>
<p> </p>
<p>Export VAG data container .............................................................. 37</p>
<p> </p>
<p>2.2.1.9.15</p>
<p> </p>
<p>Export GAC binary files ................................................................... 40</p>
<p> </p>
<p>2.2.1.10</p>
<p> </p>
<p>Print / Print Preview / Printer Setup ........................................................ 40</p>
<p> </p>
<p>2.2.1.11</p>
<p> </p>
<p>Exit ......................................................................................................... 40</p>
<p> </p>
<p>2.2.2</p>
<p> </p>
<p>Edit ................................................................................................................ 40</p>
<p> </p>
<p>2.2.2.1</p>
<p> </p>
<p>Undo ...................................................................................................... 40</p>
<p> </p>
<p>2.2.2.2</p>
<p> </p>
<p>Cut / Copy / Paste .................................................................................. 41</p>
<p> </p>
<p>2.2.2.3</p>
<p> </p>
<p>Copy dsPIC like data .............................................................................. 43</p>
<p> </p>
<p>2.2.2.4</p>
<p> </p>
<p>Data Alignment ....................................................................................... 44</p>
<p> </p>
<p>2.2.2.5</p>
<p> </p>
<p>Fill block data ......................................................................................... 45</p>
<p> </p>
<p>2.2.2.6</p>
<p> </p>
<p>Create Checksum ................................................................................... 46</p>
<p> </p>
<p>2.2.2.7</p>
<p> </p>
<p>Run Data Processing.............................................................................. 47</p>
<p> </p>
<p>2.2.2.8</p>
<p> </p>
<p>Signature verification .............................................................................. 48</p>
<p> </p>
<p>2.2.2.9</p>
<p> </p>
<p>Edit/Create OEM Container-Info ............................................................. 49</p>
<p> </p>
<p>2.2.2.10</p>
<p> </p>
<p>Remap S12 Phys-&gt;Lin ........................................................................... 49</p>
<p> </p>
<p>2.2.2.11</p>
<p> </p>
<p>Remap S12x Phys-&gt;Lin .......................................................................... 49</p>
<p> </p>
<p>2.2.2.12</p>
<p> </p>
<p>General Remapping ............................................................................... 49</p>
<p> </p>
<p>2.2.2.13</p>
<p> </p>
<p>Generate file validation structure ............................................................ 50</p>
<p> </p>
<p>2.2.2.14</p>
<p> </p>
<p>Run Postbuild ......................................................................................... 53</p>
<p> </p>
<p>2.2.2.15</p>
<p> </p>
<p>Options ................................................................................................... 54</p>
<p> </p>
<p>2.2.3</p>
<p> </p>
<p>View .............................................................................................................. 55</p>
<p> </p>
<p>2.2.3.1</p>
<p> </p>
<p>Goto address… ...................................................................................... 55</p>
<p> </p>
<p>2.2.3.2</p>
<p> </p>
<p>Find record ............................................................................................. 55</p>
<p> </p>
<p>2.2.3.3</p>
<p> </p>
<p>Repeat last find ...................................................................................... 56</p>
<p> </p>
<p>2.2.3.4</p>
<p> </p>
<p>View OEM container info ........................................................................ 56</p>
<p> </p>
<p>2.2.4</p>
<p> </p>
<p>Flash Programming ....................................................................................... 56</p>
<p> </p>
<p>2.2.4.1</p>
<p> </p>
<p>Scan CANoe trace log ............................................................................ 56</p>
<p> </p>
<p>2.2.4.2</p>
<p> </p>
<p>Build ID based EEP download file. ......................................................... 58</p>
<p> </p>
<p>2.2.4.3</p>
<p> </p>
<p>Scan EepM data section ......................................................................... 59</p>
<p> </p>
<p>2.2.5</p>
<p> </p>
<p>Info operation (?) ........................................................................................... 60</p>
<p> </p>
<p>2.3</p>
<p> </p>
<p>Hexview return values ............................................................................................ 61</p>
<p> </p>
<p>2.4</p>
<p> </p>
<p>Accelerator Keys (short-cut keys) ........................................................................... 62</p>
<p> </p>
<p><b>3</b></p>
<p> </p>
<p><b>Command line arguments description ....................................................................... 63</b></p>
<p> </p>
<p>3.1</p>
<p> </p>
<p>Command line options summary ............................................................................ 63</p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Reference Manual HexView </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 1.12.02 </p>
<p>10 </p>
<p>based on template version 5.1.0 </p>
<p>3.2</p>
<p> </p>
<p>General command line operation order .................................................................. 70</p>
<p> </p>
<p>3.2.1</p>
<p> </p>
<p>Align Data (/ADxx or /AD:yy) ......................................................................... 71</p>
<p> </p>
<p>3.2.2</p>
<p> </p>
<p>Align length (/AL[:length]) .............................................................................. 71</p>
<p> </p>
<p>3.2.3</p>
<p> </p>
<p>Specify erase alignment value (/AE:xxx) ....................................................... 71</p>
<p> </p>
<p>3.2.4</p>
<p> </p>
<p>Specify fill character (/AF:xx, /AFxx) .............................................................. 72</p>
<p> </p>
<p>3.2.5</p>
<p> </p>
<p>Address range reduction (/AR:’range’) .......................................................... 72</p>
<p> </p>
<p>3.2.6</p>
<p> </p>
<p>Big hex-file conversion threshold (/BHFCT=xxx) ........................................... 72</p>
<p> </p>
<p>3.2.7</p>
<p> </p>
<p>Buffer to file threshold (/BTFST=xxx) ............................................................. 73</p>
<p> </p>
<p>3.2.8</p>
<p> </p>
<p>Temporary buffer size (/BTBS=xxx) ............................................................... 73</p>
<p> </p>
<p>3.2.9</p>
<p> </p>
<p>Cut out data from loaded file (/CR:’range1[:’range2’:…] ................................ 73</p>
<p> </p>
<p>3.2.10</p>
<p> </p>
<p>Checksum calculation method (/CS[R]x[:target[;!Forced-range[#fill </p>
<p>pattern]][;limited_range][/no_range]) .............................................................. 74</p>
<p> </p>
<p>3.2.11</p>
<p> </p>
<p>Run Data Processing interface (/DPn:param[,section,key][;outfilename]) ...... 80</p>
<p> </p>
<p>3.2.12</p>
<p> </p>
<p>Specify an alternative data processing DLL (/expdat:&lt;path-to-</p>
<p>expdatproc.dll&gt;) ............................................................................................ 87</p>
<p> </p>
<p>3.2.13</p>
<p> </p>
<p>Create error log file (/E:errorfile.err) ............................................................... 87</p>
<p> </p>
<p>3.2.14</p>
<p> </p>
<p>Create single region file (/FA) ........................................................................ 88</p>
<p> </p>
<p>3.2.15</p>
<p> </p>
<p>Fill region (/FR:’range1’:’range2’:…) .............................................................. 88</p>
<p> </p>
<p>3.2.16</p>
<p> </p>
<p>Specify fill pattern (/FP:xxyyzz…) .................................................................. 88</p>
<p> </p>
<p>3.2.17</p>
<p> </p>
<p>Import HEX-ASCII data (/IA:filename[;AddressOffset]) .................................. 88</p>
<p> </p>
<p>3.2.18</p>
<p> </p>
<p>Import Binary data (/IN:filename[;AddressOffset]) ......................................... 88</p>
<p> </p>
<p>3.2.19</p>
<p> </p>
<p>Execute logfile (/L:logfile) .............................................................................. 88</p>
<p> </p>
<p>3.2.20</p>
<p> </p>
<p>Merging files (/MO, /MT) ................................................................................ 89</p>
<p> </p>
<p>3.2.21</p>
<p> </p>
<p>Merge two VBF files (/MVBF:vbf_file.vbf) ...................................................... 90</p>
<p> </p>
<p>3.2.22</p>
<p> </p>
<p>Run postbuild operation (/pb=postbuild-file) .................................................. 90</p>
<p> </p>
<p>3.2.22.1</p>
<p> </p>
<p>OpenPBFile ............................................................................................ 91</p>
<p> </p>
<p>3.2.22.2</p>
<p> </p>
<p>ClosePBFile ........................................................................................... 91</p>
<p> </p>
<p>3.2.22.3</p>
<p> </p>
<p>ClosePBFile ........................................................................................... 91</p>
<p> </p>
<p>3.2.22.4</p>
<p> </p>
<p>GetPBData ............................................................................................. 92</p>
<p> </p>
<p>3.2.23</p>
<p> </p>
<p>Specify output filename (-o outfilename) ....................................................... 93</p>
<p> </p>
<p>3.2.24</p>
<p> </p>
<p>Run in silent mode (/s) .................................................................................. 93</p>
<p> </p>
<p>3.2.25</p>
<p> </p>
<p>Split blocks (/sb:maxblocksize) ...................................................................... 93</p>
<p> </p>
<p>3.2.26</p>
<p> </p>
<p>Run signature verification (/SVn:keyinfo!signatureinfo) .................................. 93</p>
<p> </p>
<p>3.2.27</p>
<p> </p>
<p>Specify an INI-file for additional parameters (/P:ini-file) ................................. 95</p>
<p> </p>
<p>3.2.28</p>
<p> </p>
<p>Remapping address information (/remap) ..................................................... 95</p>
<p> </p>
<p>3.2.29</p>
<p> </p>
<p>Write version string to error log file (/v) .......................................................... 97</p>
<p> </p>
<p>3.2.30</p>
<p> </p>
<p>Create validation structure (/vs) ..................................................................... 97</p>
<p> </p>
<p>3.3</p>
<p> </p>
<p>Output-control command line options (/Xx) ............................................................. 98</p>
<p> </p>
<p>3.3.1</p>
<p> </p>
<p>Output of HEX ASCII data (/XA[:linelen[:separator]]) ..................................... 99</p>
<p> </p>
<p>3.3.2</p>
<p> </p>
<p>Output a Fiat specific data file (/XB) .............................................................. 99</p>
<p> </p>
<p>3.3.3</p>
<p> </p>
<p>Output data into C-Code array (/XC) ........................................................... 101</p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Reference Manual HexView </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 1.12.02 </p>
<p>11 </p>
<p>based on template version 5.1.0 </p>
<p>3.3.4</p>
<p> </p>
<p>Output Ford files in Intel-HEX format (/XF) .................................................. 101</p>
<p> </p>
<p>3.3.5</p>
<p> </p>
<p>Output Files in VBF format (/XVBF) ............................................................. 105</p>
<p> </p>
<p>3.3.6</p>
<p> </p>
<p>Exchange the binary portion of a VBF (/xvbfsubst=&lt;&lt;file&gt;&gt;[;DFI=xx]) ......... 113</p>
<p> </p>
<p>3.3.7</p>
<p> </p>
<p>Output a GM-specific data file ..................................................................... 113</p>
<p> </p>
<p>3.3.7.1</p>
<p> </p>
<p>Manipulating Checksum and address/Length field within an existing </p>
<p>header (/XG) ........................................................................................ 114</p>
<p> </p>
<p>3.3.7.2</p>
<p> </p>
<p>Creating the GM file header for the operating software </p>
<p>(/XGC[:address]) .................................................................................. 116</p>
<p> </p>
<p>3.3.7.3</p>
<p> </p>
<p>Creating the GM file header for the calibration software </p>
<p>(/XGCC[:address]) ................................................................................ 116</p>
<p> </p>
<p>3.3.7.4</p>
<p> </p>
<p>Creating the GM file header with 1-byte HFI (/XGCS[:address]) ........... 117</p>
<p> </p>
<p>3.3.7.5</p>
<p> </p>
<p>Specify the SWMI data (/SWMI=xxxx) .................................................. 117</p>
<p> </p>
<p>3.3.7.6</p>
<p> </p>
<p>Adding the part number to the header (/PN) ......................................... 117</p>
<p> </p>
<p>3.3.7.7</p>
<p> </p>
<p>Specify the DLS values (/DLS=xx) ........................................................ 118</p>
<p> </p>
<p>3.3.7.8</p>
<p> </p>
<p>Specify the Module-ID parameter (/MODID=value)............................... 118</p>
<p> </p>
<p>3.3.7.9</p>
<p> </p>
<p>Specify the DCID-field (/DCID=value) ................................................... 118</p>
<p> </p>
<p>3.3.7.10</p>
<p> </p>
<p>Specify the MPFH field (/MPFH[=file1+file2+…] ................................... 118</p>
<p> </p>
<p>3.3.7.11</p>
<p> </p>
<p>GM header alignment (/GMAD=val, /GMAL[=val]) ................................ 119</p>
<p> </p>
<p>3.3.7.12</p>
<p> </p>
<p>Signature version (/sigver=value) ......................................................... 119</p>
<p> </p>
<p>3.3.7.13</p>
<p> </p>
<p>Signature Key ID (/sigkeyid=value) ....................................................... 120</p>
<p> </p>
<p>3.3.7.14</p>
<p> </p>
<p>Generate Routine header (/XGCR[:header-address]) ........................... 120</p>
<p> </p>
<p>3.3.7.15</p>
<p> </p>
<p>Generate key exchange header (/XGCK) ............................................. 120</p>
<p> </p>
<p>3.3.8</p>
<p> </p>
<p>Output a VAG specific data file (/XV) ........................................................... 120</p>
<p> </p>
<p>3.3.9</p>
<p> </p>
<p>Output data as Intel-HEX (/XI[:reclinelen[:rectype]]) .................................... 120</p>
<p> </p>
<p>3.3.10</p>
<p> </p>
<p>Output data as Motorola S-Record (/XS[:reclinelen[:rectype]]) .................... 121</p>
<p> </p>
<p>3.3.11</p>
<p> </p>
<p>Outputs to a CCP/XCP kernel file (/XK) ....................................................... 121</p>
<p> </p>
<p>3.3.12</p>
<p> </p>
<p>Output to a GAC binary file (/XGAC, /XGACSWIL) ...................................... 122</p>
<p> </p>
<p><b>4</b></p>
<p> </p>
<p><b>EXPDATPROC ............................................................................................................ 123</b></p>
<p> </p>
<p>4.1</p>
<p> </p>
<p>Interface function for checksum calculation .......................................................... 123</p>
<p> </p>
<p>4.2</p>
<p> </p>
<p>Interface function for data processing ................................................................... 124</p>
<p> </p>
<p><b>5</b></p>
<p> </p>
<p><b>Glossary and Abbreviations ...................................................................................... 126</b></p>
<p> </p>
<p>5.1</p>
<p> </p>
<p>Glossary ............................................................................................................... 126</p>
<p> </p>
<p>5.2</p>
<p> </p>
<p>Abbreviations ....................................................................................................... 126</p>
<p> </p>
<p><b>6</b></p>
<p> </p>
<p><b>Contact........................................................................................................................ 127</b></p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Reference Manual HexView </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 1.12.02 </p>
<p>12 </p>
<p>based on template version 5.1.0 </p>
<p><b>Illustrations </b></p>
<p>Figure 1-1: Typical use-case for Hexview in an embedded system environment .................. 14</p>
<p> </p>
<p>Figure 2-1</p>
<p> </p>
<p>Main Menu of HexView ............................................................................. 17</p>
<p> </p>
<p>Figure 2-2</p>
<p> </p>
<p>Edit-Line dialog ......................................................................................... 18</p>
<p> </p>
<p>Figure 2-3</p>
<p> </p>
<p>Change the base address of a segment ................................................... 18</p>
<p> </p>
<p>Figure 2-4:</p>
<p> </p>
<p>Customizing merge data in the merge dialog ............................................ 20</p>
<p> </p>
<p>Figure 2-5</p>
<p> </p>
<p>Overlapping data when merging a file ....................................................... 20</p>
<p> </p>
<p>Figure 2-6</p>
<p> </p>
<p>Compare Info dialog ................................................................................. 21</p>
<p> </p>
<p>Figure 2-7</p>
<p> </p>
<p>Export data in the Motorola S-Record format ............................................ 24</p>
<p> </p>
<p>Figure 2-8</p>
<p> </p>
<p>Export dialog for the Intel-Hex output ........................................................ 25</p>
<p> </p>
<p>Figure 2-9</p>
<p> </p>
<p>Export HEX ASCII data ............................................................................. 26</p>
<p> </p>
<p>Figure 2-10</p>
<p> </p>
<p>Export flashkernel data for CCP/XCP ....................................................... 26</p>
<p> </p>
<p>Figure 2-11</p>
<p> </p>
<p>Export data into a C-Array ........................................................................ 28</p>
<p> </p>
<p>Figure 2-12</p>
<p> </p>
<p>Export binary block data ........................................................................... 32</p>
<p> </p>
<p>Figure 2-13:</p>
<p> </p>
<p>Export dialog for the FIAT binary file ......................................................... 32</p>
<p> </p>
<p>Figure 2-14:</p>
<p> </p>
<p>Export dialog for Ford I-Hex output file...................................................... 34</p>
<p> </p>
<p>Figure 2-15:</p>
<p> </p>
<p>Export dialog for the Ford/VolvoCars-VBF data file format ........................ 35</p>
<p> </p>
<p>Figure 2-16:</p>
<p> </p>
<p>The output information for the GM data export .......................................... 36</p>
<p> </p>
<p>Figure 2-17:</p>
<p> </p>
<p>Export dialog to generate the GM-FBL header information for GENy ........ 36</p>
<p> </p>
<p>Figure 2-18</p>
<p> </p>
<p>Exports data into a VAG-compatible data container .................................. 37</p>
<p> </p>
<p>Figure 2-19</p>
<p> </p>
<p>Example of ‘Copy window’ when Ctrl-C or “Paste” pressed using start- </p>
<p>and end-address ....................................................................................... 42</p>
<p> </p>
<p>Figure 2-20</p>
<p> </p>
<p>Example of cut-data using start-address and length as a parameter ......... 42</p>
<p> </p>
<p>Figure 2-21:</p>
<p> </p>
<p>Pasting the clipboard data into the document specifying the target </p>
<p>address ..................................................................................................... 43</p>
<p> </p>
<p>Figure 2-22:</p>
<p> </p>
<p>Copy dsPIC like data ................................................................................ 44</p>
<p> </p>
<p>Figure 2-23</p>
<p> </p>
<p>Data alignment option ............................................................................... 45</p>
<p> </p>
<p>Figure 2-24</p>
<p> </p>
<p>Dialog that allows to fill data ..................................................................... 46</p>
<p> </p>
<p>Figure 2-25</p>
<p> </p>
<p>Dialog to operate the checksum calculation .............................................. 47</p>
<p> </p>
<p>Figure 2-26</p>
<p> </p>
<p>Dialog for Data Processing ....................................................................... 47</p>
<p> </p>
<p>Figure 2-27</p>
<p> </p>
<p>Running signature verification from the dialog. ......................................... 48</p>
<p> </p>
<p>Figure 2-28:</p>
<p> </p>
<p>Configuration window for general remapping ............................................ 50</p>
<p> </p>
<p>Figure 2-29</p>
<p> </p>
<p>Figure 2-30 Generate the validation structure for your target memory. ...... 51</p>
<p> </p>
<p>Figure 2-31</p>
<p> </p>
<p>Hexview configuration options to change the memory thresholds ............. 54</p>
<p> </p>
<p>Figure 2-32:</p>
<p> </p>
<p>Jump to a specific address in the display window ..................................... 55</p>
<p> </p>
<p>Figure 2-33:</p>
<p> </p>
<p>Find a string or pattern within the document ............................................. 56</p>
<p> </p>
<p>Figure 2-34: </p>
<p> </p>
<p>Dialog to run a CANoe trace ..................................................................... 57</p>
<p> </p>
<p>Figure 2-35: </p>
<p> </p>
<p>Example output for building ID based download files. ............................... 59</p>
<p> </p>
<p>Figure 2-36:</p>
<p> </p>
<p>Scan EepM dialog and example ............................................................... 59</p>
<p> </p>
<p>Figure 3-1</p>
<p> </p>
<p>Order of commandline operations within Hexview. .................................... 70</p>
<p> </p>
<p>Figure 3-2</p>
<p> </p>
<p>Example on how to select the checksum calculation methods in the Edit </p>
<p>-&gt; “Create Checksum” operation ............................................................... 74</p>
<p> </p>
<p>Figure 3-3: Various checksum calculation options using forced and limited ranges .............. 75</p>
<p> </p>
<p>Figure 3-4: Various options for checksum calculation using excluded ranges (no range) ..... 75</p>
<p> </p>
<p>Figure 3-5:</p>
<p> </p>
<p>Calling sequence of the post-build  functions ............................................ 90</p>
<p> </p>
<p>Figure 3-6:</p>
<p> </p>
<p>Mapping pysical to linear address spaces ................................................. 96</p>
<p> </p>
<p>Figure 4-1</p>
<p> </p>
<p>Build the list box entries for the GUI ........................................................ 123</p>
<p> </p>
<p>Figure 4-2</p>
<p> </p>
<p>Function calls when running checksum calculation ................................. 124</p>
<p> </p>
<p><b> </b></p>
<p><b>Tables </b></p>
<p>Table 2-1 </p>
<p> </p>
<p>Auto-file format detection .......................................................................... 20</p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Reference Manual HexView </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 1.12.02 </p>
<p>13 </p>
<p>based on template version 5.1.0 </p>
<p>Table 2-2 </p>
<p> </p>
<p>Currently available commands in the log-file ............................................. 22</p>
<p> </p>
<p>Table 2-3 </p>
<p> </p>
<p>Description of the elements for the VAG SGML output container .............. 39</p>
<p> </p>
<p>Table 2-4:</p>
<p> </p>
<p>Description of Hexview options. ................................................................ 54</p>
<p> </p>
<p>Table 2-5:</p>
<p> </p>
<p>Hexview return values. ............................................................................. 61</p>
<p> </p>
<p>Table 2-6 </p>
<p> </p>
<p>Accelerator keys (short-cut keys)  available in Hexview ............................ 62</p>
<p> </p>
<p>Table 3-1 </p>
<p> </p>
<p>Command line options summary ............................................................... 69</p>
<p> </p>
<p>Table 3-2 </p>
<p> </p>
<p>Checksum location operators used in the commandline ........................... 77</p>
<p> </p>
<p>Table 3-3:</p>
<p> </p>
<p>Functional overview of checksum calculation methods in “expdatproc.dll” 80</p>
<p> </p>
<p>Table 3-4 </p>
<p> </p>
<p>Functional overview of data processing methods in “expdatproc.dll” ......... 86</p>
<p> </p>
<p>Table 3-5 </p>
<p> </p>
<p>OpenPBFile .............................................................................................. 91</p>
<p> </p>
<p>Table 3-6 </p>
<p> </p>
<p>OpenPBFile .............................................................................................. 91</p>
<p> </p>
<p>Table 3-7 </p>
<p> </p>
<p>ClosePBFile .............................................................................................. 92</p>
<p> </p>
<p>Table 3-8 </p>
<p> </p>
<p>GetPBData ............................................................................................... 92</p>
<p> </p>
<p>Table 3-9: </p>
<p> </p>
<p>Correspondence table of signature generation and verification ................. 94</p>
<p> </p>
<p>Table 3-10 </p>
<p> </p>
<p>INI-file information fort he Fiat file container generation .......................... 101</p>
<p> </p>
<p>Table 3-11 </p>
<p> </p>
<p>INI-File definition fort he C-Code array export function ........................... 101</p>
<p> </p>
<p>Table 3-12 </p>
<p> </p>
<p>INI-file description for Ford I-Hex file generation ..................................... 103</p>
<p> </p>
<p>Table 3-13: </p>
<p> </p>
<p>VBF versions known by Hexview and associated companies ................. 106</p>
<p> </p>
<p>Table 3-14 </p>
<p> </p>
<p>INI-File description for VBF export configuration ..................................... 109</p>
<p> </p>
<p>Table 3-15 </p>
<p> </p>
<p>An example for the Ford VBF V3.1 format to generate a signed VBF file. 110</p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Reference Manual HexView </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 1.12.02 </p>
<p>14 </p>
<p>based on template version 5.1.0 </p>
<p><b>1 </b></p>
<p><b>Introduction </b></p>
<p>This document describes the usage of the PC-Tool “HexView”. It can show the contents of </p>
<p>different </p>
<p>file </p>
<p>formats, </p>
<p>mainly </p>
<p>Intel-HEX, </p>
<p>Motorola </p>
<p>S-record </p>
<p>binaries </p>
<p>or </p>
<p>other </p>
<p>car </p>
<p>manufacturer  specific  file  formats.  Furthermore,  it  can  perform  several  data  processing </p>
<p>operation  like  checksum  calculation,  signature  generation,  data  encryption/decryption  or </p>
<p>compression/decompression, but also re-arrange the data contents of a file.  </p>
<p>Some of the features of Hexview can be used by the graphical user interface. But there </p>
<p>are also powerful features available via a command line interface. Some features are even </p>
<p>just accessible via the command lines. </p>
<p> </p>
<p> </p>
<p> </p>
<p>Figure 1-1: Typical use-case for Hexview in an embedded system environment </p>
<p>The resulting modified file might be transferred to a microcontroller by programming the </p>
<p>output of Hexview into its flash memory for execution. The results file may go to </p>
<p>production. Therefore, it is VERY important that you check and test the results carefully if </p>
<p>the resulting output is still correct. <b>This is your task</b>. One way to do this is a verification, </p>
<p>what has been changed by the tool. The other is a careful test operation of the results to </p>
<p>verify that no hidden changes have been made by the tool. </p>
<p>It should be noted, that Hexview is not following the standard development processes at </p>
<p>Vector. Even though the source code is fully under version control, issues are captured in </p>
<p>a tracking system and also basic regression tests are performed before a release the tool </p>
<p>is not classified for a confidence level resp. has the confidence level 0.  </p>
<p>  </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Reference Manual HexView </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 1.12.02 </p>
<p>15 </p>
<p>based on template version 5.1.0 </p>
<p><b>1.1 </b></p>
<p><b>Important notes </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>The application of this product can be dangerous. Please use it with care. </p>
<p><b> </b></p>
<p><b> </b></p>
<p>Note that this tool may be used to alter the program or data intended to be downloaded </p>
<p>into an ECU for series production. The results of this data manipulation must be observed </p>
<p>very carefully and thoroughly tested. </p>
<p> </p>
<p><b>In  no  respect  shall  Vector  Informatik  GmbH  incur  any  liability  for  any  damages, </b></p>
<p><b>including, but limited to, direct, indirect, special, or consequential damages arising </b></p>
<p><b>out of, resulting from, or any way connected to the use of the item, whether or not </b></p>
<p><b>based </b></p>
<p><b>upon </b></p>
<p><b>warranty, </b></p>
<p><b>contract, </b></p>
<p><b>tort, </b></p>
<p><b>or </b></p>
<p><b>otherwise; </b></p>
<p><b>whether </b></p>
<p><b>or </b></p>
<p><b>not </b></p>
<p><b>injury </b></p>
<p><b>was </b></p>
<p><b>sustained  by  persons  or  property  or  otherwise;  and  whether  or  not  loss  was </b></p>
<p><b>sustained from, or arose out of, the results of, the item, or any services that may be </b></p>
<p><b>provided by Vector Informatik GmbH. </b></p>
<p><b> </b></p>
<p><b>1.2 </b></p>
<p><b>Release notes </b></p>
<p><b>1.2.1 </b></p>
<p><b>Hexview 1.12.00 </b></p>
<p>The  version  contains some bug fixes  to  V1.11. especially  problems  with  the  segmented </p>
<p>operations on files such as merge parts of data into a file, extracting data out of a middle of </p>
<p>a block, data processing operation on big files e.g. for signature generation. Performance </p>
<p>parameters can now be specified on command line to make operations transparent and </p>
<p>portable. </p>
<p>Note  that  all  compression  algorithm  still  do  not  support  streaming  interfaces.  Thus,  if  a </p>
<p>block is too large and cannot be handled in memory but on a hard disc, compression of </p>
<p>this file is not possible. Same applies for decompression, unless “Vector decompression 0” </p>
<p>is  used.    Possible  workaround  is  the  increase  of  the  “Buffer  to  file  size  threshold” </p>
<p>(/BTFST). </p>
<p>Older version experienced problems with some Windows10 PCs. This version aims to fix </p>
<p>the problems. </p>
<p>Hexview  return  codes  have  been  approved. A  list  of  return  values  are  provided  in  this </p>
<p>document.  </p>
<p> </p>
<p><b>1.2.2 </b></p>
<p><b>Hexview V1.11.00 </b></p>
<p>This  version  supports  operation  on  large  hexfiles  up  to  2  GB.  Previous  versions  were </p>
<p>handling  all  data  in  memory.  By  default,  HEX-files  greater  than  16  MB  are  parsed </p>
<p>differently and flash blocks larger than 4 MB will be stored in temporary files. This allows to </p>
<p>operate on files that are even larger than the internal memory capabilities. The thresholds </p>
<p>can be adjusted, see section 2.2.2.15 for details. As a drawback, operations on such files </p>
<p>is a bit slower. So, please be patient if you want to operate on large files. </p>
<h1 style="page-break-before:always; "></h1>
<p>Reference Manual HexView </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 1.12.02 </p>
<p>16 </p>
<p>based on template version 5.1.0 </p>
<p>Please note, that data compression and most of the decompression algorithms cannot be </p>
<p>applied if the  </p>
<h1 style="page-break-before:always; "></h1>
<p>Reference Manual HexView </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 1.12.02 </p>
<p>17 </p>
<p>based on template version 5.1.0 </p>
<p><b>2 </b></p>
<p><b>User Interface </b></p>
<p>This chapter describes the user interface and menu items of the program. </p>
<p>To understand the user interface, some basics of file contents need to be clarified. </p>
<p>First, an Intel-HEX or Motorola S-Record consists of data assigned to specific addresses. </p>
<p>The  data  can  be  continuous  from  a  specific  start  address.  A  continuous  data  block  is </p>
<p>named as a section or segment. Such files can contain one or more data sections. </p>
<p> </p>
<p>Figure 2-1 </p>
<p>Main Menu of HexView </p>
<p>The figure above shows the main menu of HexView after a HEX-.File has been loaded. In </p>
<p>the upper part of the tool the sections of the file are listed. In the example above, the file </p>
<p>consists of 2 section2, named “Block 0..1”. For each block the start and end address is </p>
<p>given, as well as the length in hexadecimal and decimal value. </p>
<p>After the block section description, the data itself are displayed. Two adjacent blocks are </p>
<p>separated by a blank line (between 00000190 and 0009000). </p>
<p>A HEX-display line consists of the start address and its data. On the right side, the data is </p>
<p>partly interpreted as characters if possible (if the data is lower 32, the character is shown </p>
<p>as a ‘.’). </p>
<p>Any mouse click with the left button restores the display in the window. </p>
<p>On the bottom of the window some status information is displayed.  </p>
<p>From left to right: </p>
<p><b></b></p>
<p><b> </b></p>
<p>Information about the selected menu option </p>
<p><b></b></p>
<p><b> </b></p>
<p>Total number of bytes (decimal) 17ndian currently loaded file (Size=Xxxxx) </p>
<p><b></b></p>
<p><b> </b></p>
<p>The file format 17ndian data file that is currently loaded (see section 2.2.1.2.1 for </p>
<p>possible values). </p>
<h1 style="page-break-before:always; "></h1>
<p>Reference Manual HexView </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 1.12.02 </p>
<p>18 </p>
<p>based on template version 5.1.0 </p>
<p><b>2.1 </b></p>
<p><b>A Double Click into the main window </b></p>
<p>To edit a hex-line, make a double click on the corresponding line you want to edit. This will </p>
<p>open the Edit-Line dialog. </p>
<p><b>2.1.1 </b></p>
<p><b>Edit a HEX data line  </b></p>
<p>You can edit the line in two different modes. In the upper line the data can be entered in </p>
<p>hexadecimal mode. In the lower line, the data can be entered as ASCII-characters. The left </p>
<p>field shows which base address the line is assigned to. </p>
<p> </p>
<p>Figure 2-2 </p>
<p>Edit-Line dialog </p>
<p>If only a few characters or hex values are entered, HexView will only change these lines. </p>
<p>All others will remain. </p>
<p><b>2.1.2 </b></p>
<p><b>Change the base address of a data block, erase it or jump directly to the </b></p>
<p><b>beginning of the block data </b></p>
<p>It is also possible to make a double click onto the block info which is on top of the main </p>
<p>menu. This opens the block shift address menu: </p>
<p> </p>
<p>Figure 2-3 </p>
<p>Change the base address of a segment </p>
<p>This  dialog  allows  you  to  change  the  address  of  a  block.  Simply  enter  the  new  base </p>
<p>address. </p>
<h1 style="page-break-before:always; "></h1>
<p>Reference Manual HexView </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 1.12.02 </p>
<p>19 </p>
<p>based on template version 5.1.0 </p>
<p>You can also ues that to jump to the beginning of the specified block to display the data by </p>
<p>selecting the “Goto”-button (Note that it may also shift the address if another value in “New </p>
<p>Address will be specified). </p>
<p>It  is  also  possible  to  delete  the  whole  block  from  the  list  by  pushing  the  button  “Erase </p>
<p>entire block” button. </p>
<p><b>2.2 </b></p>
<p><b>Menu </b></p>
<p>The main menu is grouped into the categories  </p>
<p><b></b></p>
<p><b> </b></p>
<p>File </p>
<p><b></b></p>
<p><b> </b></p>
<p>Edit </p>
<p><b></b></p>
<p><b> </b></p>
<p>View </p>
<p><b></b></p>
<p><b> </b></p>
<p>Flash Programming </p>
<p>The  file  menu  operates  directly  on  complete  files.  The  view  menu  allows  searching  for </p>
<p>options and the Edit menu can operate on the data. </p>
<p>Each of the elements of the menu will be described now.  </p>
<p><b>2.2.1 </b></p>
<p><b>Menu: “File” </b></p>
<p><b>2.2.1.1 </b></p>
<p><b>New </b></p>
<p>Closes the current file and restarts a new session </p>
<p><b>2.2.1.2 </b></p>
<p><b>Open </b></p>
<p>This dialog allows to open a data file. Hexview analyses the data container and checks for </p>
<p>a known format. The resulting data format is displayed in the status line in the bottom area. </p>
<p><b>2.2.1.2.1 </b></p>
<p><b>Auto-file format analysing process </b></p>
<p>The format analyse process uses the following method and order: </p>
<p><b>File-format detection </b></p>
<p><b>Scan process and order during file-read operation </b></p>
<p><b>&gt; </b></p>
<p>Fiat File </p>
<p>Check the filename extension if it is a “.prm” – file, and try to read it as a </p>
<p>Fiat parameter and BIN-File combination. </p>
<p><b>&gt; </b></p>
<p>GM binary files </p>
<p>(GBF) </p>
<p>Check the filename extension if it is a “.gbf” – or “.bin” – file, and try to </p>
<p>load it in the GM-binary file format. </p>
<p><b>&gt; </b></p>
<p>Binary file, if no </p>
<p>ASCII is found </p>
<p>Read the first line with non-zero length and check if it contains non-</p>
<p>ASCII characters. If so, read the file as a binary block </p>
<p><b>&gt; </b></p>
<p>I-Hex if the line </p>
<p>begins with ‘:’ </p>
<p>If the first 25 lines of the file corresponds to an ASCII string and starts </p>
<p>with a ‘:’, the data are read as Intel-HEX. </p>
<p><b>&gt; </b></p>
<p>S-Rec if the line </p>
<p>begins with ‘S’ </p>
<p>If the ASCII-string starts with the character ‘S’ it  will be read as Motorola </p>
<p>S-Record </p>
<p><b>&gt; </b></p>
<p>Ford VBF-File </p>
<p>Check, if the contains the string “vbf_version”. Load it as VBF-file in that </p>
<p>case. </p>
<p><b>&gt; </b></p>
<p>Ford I-Hex </p>
<p>Check if the file contains one of the Ford’s Intel-HEX header information </p>
<p>and read it as Ford-Ihex file. </p>
<p><b>&gt; </b></p>
<p>Binary file in all </p>
<p>In all other cases, read the file as a binary data input with the base </p>
<h1 style="page-break-before:always; "></h1>
<p>Reference Manual HexView </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 1.12.02 </p>
<p>20 </p>
<p>based on template version 5.1.0 </p>
<p><b>File-format detection </b></p>
<p><b>Scan process and order during file-read operation </b></p>
<p>other cases </p>
<p>address of 0. </p>
<p>Table 2-1  </p>
<p>Auto-file format detection </p>
<p><b>2.2.1.3 </b></p>
<p><b>Merge </b></p>
<p>This item reads a file and adds the data to the current document data. After selecting this </p>
<p>item,  a  file-select  dialog  will  open.  You  can  select  any  of  the  files  in  the  format  of  the </p>
<p>autofile-type selections (see section 2.2.1.2.1). After selsecting the file and pressing OK, </p>
<p>the following dialog will appear: </p>
<p> </p>
<p>Figure 2-4: </p>
<p>Customizing merge data in the merge dialog </p>
<p>The specified range shows the area of data from the merge file. A smaller range can be </p>
<p>selected that shall be merged to the current document. An offset can be specified that will </p>
<p>be applied to each segment that will be merged. The offset can be positive or negative and </p>
<p>will be added or subtracted. Use a minus-sign to subtract the offset from the base address </p>
<p>of each segment. </p>
<p>If the data of the merged file overlaps with the file data, a warning will be displayed. </p>
<p> </p>
<p>Figure 2-5 </p>
<p>Overlapping data when merging a file </p>
<h1 style="page-break-before:always; "></h1>
<p>Reference Manual HexView </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 1.12.02 </p>
<p>21 </p>
<p>based on template version 5.1.0 </p>
<p>If “Overwriting existing data” is accepted, the newly read data will overwrite the data that is </p>
<p>internally present. If this is not accepted, the internal data is kept and just the surrounding </p>
<p>data is read into the internal memory. </p>
<p>All filetypes can be merged that are also supported with the automatic filetype detection </p>
<p>method. </p>
<p><b>2.2.1.4 </b></p>
<p><b>Compare </b></p>
<p>This item provides the means to compare the internal data against the data in an external </p>
<p>file. The compare option can load the same filetypes as supported with “File open”.  </p>
<p>After selecting this item, a file select dialog will open. Select the file that contains the data </p>
<p>you want to compare. Afterwards, the file compare dialog will be opened. </p>
<p> </p>
<p>Figure 2-6 </p>
<p>Compare Info dialog </p>
<p>The  left  window  displays  the  internal  data,  whereas  the  right  window  displays  the  data </p>
<p>from  the  external  file.  All  differences  are  marked  in  colors.  Data  sections  that  are  not </p>
<p>present in the internal or external document are marked with ‘-‘. </p>
<p>The  green  up-  and  down  arrows  in  the  upper  middle  can  be  used  to  search  for further </p>
<p>differences in the file. The next/previous search procedure starts always from the first line </p>
<p>displayed in the window. </p>
<p>As mentioned above, the next/prev search algorithm starts from the top line of the window. </p>
<p>It uses the next/previous line and searches for the next equal data. If equal data found, it </p>
<p>searches  for  the  next  difference  or  non-presence  of  data.  If  this  is  found,  the  first </p>
<p>appearance will be displayed on top of the window. </p>
<h1 style="page-break-before:always; "></h1>
<p>Reference Manual HexView </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 1.12.02 </p>
<p>22 </p>
<p>based on template version 5.1.0 </p>
<p><b>2.2.1.5 </b></p>
<p><b>Save </b></p>
<p>After any modification of the data (e.g. modifying a hexline or the base address of a block), </p>
<p>the  save  option  will  be  enabled.  This  indicates,  that  the  file  has  been  modified.  In  that </p>
<p>case, the “Save” option enables you to store the data to  the current file name. Hexview </p>
<p>writes the data in the current file format. The current file format is displayed in the status </p>
<p>line. </p>
<p><b>2.2.1.6 </b></p>
<p><b>Save as </b></p>
<p>Enables you to store the internal data to a file with a different filename. Hexview uses the </p>
<p>current file format displayed in the status line. If a file format cannot be stored (e.g. the </p>
<p>Intel-Hex/Motorola S-Record “Mixed” file type), a warning will be shown and no data can </p>
<p>be saved. Use the export function of Hexview to store the data in a different format. </p>
<p><b>2.2.1.7 </b></p>
<p><b>Log Commands </b></p>
<p>This option is reserved for future use. It is intended as a certain kind of macro recorder. If </p>
<p>selected, the “save as” dialog will open. Within it, a log file can be selected. HexView will </p>
<p>create a new file or delete the contents of an existing file. Once this has been selected, </p>
<p>some commands will be stored within it.  </p>
<p>The following commands are implemented at the moment: </p>
<p> </p>
<p><b>Command name </b></p>
<p><b>Command option </b></p>
<p><b>Description </b></p>
<p>FileOpen </p>
<p>filename </p>
<p>Opens a file. </p>
<p>FileClose </p>
<p>- </p>
<p>Close the file </p>
<p>FileNew </p>
<p>- </p>
<p>Deletes the current file and creates a new </p>
<p>object </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>Table 2-2  </p>
<p>Currently available commands in the log-file </p>
<p>This might be extended in the future. </p>
<p>The LOG-File commands can be executed through the command line options. </p>
<p><b>2.2.1.8 </b></p>
<p><b>Import </b></p>
<p>The  Import  option  allows  to  read  files  in  different  other  file  formats.  The  following  file </p>
<p>formats are supported: </p>
<p><b></b></p>
<p><b> </b></p>
<p>Motorola S-Record or Intel-Hex data </p>
<p><b></b></p>
<p><b> </b></p>
<p>Binary data </p>
<p><b></b></p>
<p><b> </b></p>
<p>GM data </p>
<p><b></b></p>
<p><b> </b></p>
<p>Fiat data </p>
<p><b></b></p>
<p><b> </b></p>
<p>Ford Intel-HEX data </p>
<p><b></b></p>
<p><b> </b></p>
<p>Ford VBF-Data </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Reference Manual HexView </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 1.12.02 </p>
<p>23 </p>
<p>based on template version 5.1.0 </p>
<p><b>2.2.1.8.1 </b></p>
<p><b>Import Intel-Hex/Motorola S-Record </b></p>
<p>This item is used to provide backward compatibility to the File-&gt;Open function available in </p>
<p>previous versions of Hexview (V1.1.2 or lower). It scans a textfile and analyses each line if </p>
<p>it is an Intel-HEX or a Motorola S-Record line and reads the data. </p>
<p>The resulting file type will be displayed in the filetype-area of the status line (‘S-Record’, </p>
<p>‘Intel-Hex’ or ‘Mixed’) </p>
<p><b>2.2.1.8.2 </b></p>
<p><b>Read 16-Bit Intel Hex </b></p>
<p>This option reads an Intel-hex file and treats the address and data as 16-bit values. Every </p>
<p>address information is multiplied by two. Then the data is read into the buffer.  </p>
<p><b>2.2.1.8.3 </b></p>
<p><b>Import binary data </b></p>
<p>Reads a data file content as a binary. The data is treated as one binary block starting at </p>
<p>address 0. The base address can be changed by a double click to the block info line at the </p>
<p>top of the file. </p>
<p><b>2.2.1.8.4 </b></p>
<p><b>Import HEX ASCII </b></p>
<p>This option provides the ability to read text information in HEX ASCII format. Every byte </p>
<p>will be represented as a pair or single HEX characters, e.g. 34, 5, F3. All non-HEX-ASCII </p>
<p>characters like spaces or carriage returns will be dropped and treated as separators. </p>
<p>The base address of the read operation is always set to 0. </p>
<p>Note: The current file in the editor is not deleted. So, the HEX ASCII is rather merged to </p>
<p>the existing one. Use “File -&gt; New” to read in only the ASCII data. </p>
<p><b>2.2.1.8.5 </b></p>
<p><b>Import GM data </b></p>
<p>Reads  a  binary  file  that  contains  the  GM  header  information.  Since  the  header  should </p>
<p>contain address and length information, all sections can be restored from the file. Note that </p>
<p>this option can only be used if the file actually contains a GM binary header. </p>
<p><b>2.2.1.8.6 </b></p>
<p><b>Import Fiat data </b></p>
<p>This option reads the file in the Fiat binary format. The Fiat files are split into two files, the </p>
<p>parameter  file  (*.prm)  and  the  binary  file  (*.bin).  The  parameter  file  contains  section </p>
<p>information, the checksum, etc. The binary file contains the actual data. HexView reads the </p>
<p>PRM  file  and  interprets  the  section  information.  Then  it  reads  the  actual  data  from  the </p>
<p>binary file. </p>
<p><b>2.2.1.8.7 </b></p>
<p><b>Import Ford Ihex data </b></p>
<p>Reads </p>
<p>the </p>
<p>header </p>
<p>container </p>
<p>information </p>
<p>used </p>
<p>by </p>
<p>Ford </p>
<p>and </p>
<p>the </p>
<p>following </p>
<p>Intel-HEX </p>
<p>information from the file. </p>
<p>All information from the Ford header will be stored in an INI-file. </p>
<p><b>2.2.1.8.8 </b></p>
<p><b>Import Ford VBF data </b></p>
<p>Reads the Ford VBF data file. This version of Hexview manages the vbf-version V2.2.  </p>
<p>All information from the header will be stored in an INI-File. </p>
<p><b>2.2.1.8.9 </b></p>
<p><b>Import GAC binary file </b></p>
<p>Allows to read in GAC binary files. The header information like DCID, S/W version etc. are </p>
<p>stored  in  an  internal  buffer  and  are  hidden  from  the  user.  The  address  and  length </p>
<p>information from the binary will be taken to re-construct the memory representation of the </p>
<h1 style="page-break-before:always; "></h1>
<p>Reference Manual HexView </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 1.12.02 </p>
<p>24 </p>
<p>based on template version 5.1.0 </p>
<p>binary data. Hence, the GAC binary files without address information (e.g. for the SWIL) </p>
<p>will not displayed as GAC files and must be handled like binaries. </p>
<p> </p>
<p><b>2.2.1.9 </b></p>
<p><b>Export </b></p>
<p>This item groups a number of different options to store the internal data into different file </p>
<p>formats. Each export can contain some options to adjust the output information. </p>
<p><b>2.2.1.9.1 </b></p>
<p><b>Export as S-Record </b></p>
<p>This item exports the data in the Motorola S-Record format. </p>
<p> </p>
<p>Figure 2-7 </p>
<p>Export data in the Motorola S-Record format </p>
<p>The  record  type  will  be  selected  automatically  depending  on  the  length  of  the  highest </p>
<p>address information. </p>
<p>The  default  values  for  start  and  end  address  will  be  the  lowest  respectively  the  highest </p>
<p>address of the file. The Output range specifier can be used if just a portion of the internal </p>
<p>data  shall  be  exported.  The  range  can  be  specified  using  the  start  and  end  address </p>
<p>separated by a ‘-‘, or can be specified using the start address and length separated by a </p>
<p>comma.  Several  ranges  can  be  separated  by  a  colon  ‘:’.  Address  and  length  can  be </p>
<p>specified in hexadecimal with a preceding ‘0x’. Otherwise it is treated as a decimal value. </p>
<p>Examples:     0x190,0x20:0x9020-0x903f </p>
<p>The option “Max. bytes per record line” specifies the number of bytes per block for the S-</p>
<p>Record file. The <b>[Browse] </b>option allows to locate the file with the file dialog. </p>
<h1 style="page-break-before:always; "></h1>
<p>Reference Manual HexView </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 1.12.02 </p>
<p>25 </p>
<p>based on template version 5.1.0 </p>
<p><b>2.2.1.9.2 </b></p>
<p><b>Export as Intel-HEX </b></p>
<p> </p>
<p>Figure 2-8 </p>
<p>Export dialog for the Intel-Hex output </p>
<p>Exports the data in Intel-HEX record format. This opens the following dialog for the export: </p>
<p>The  address  range  of  the  output  can  be  limited  (see  2.2.1.9.1  for  a  description  on  the </p>
<p>format and how to use the range specifier).  </p>
<p>Hexview supports two different types of output on the Intel-HEX file format, the extended </p>
<p>linear segment and the extended segment. The extended linear segment can store data </p>
<p>with  address  ranges  up  to  20  bits,  whereas  the  extended  linear  segment  format  can </p>
<p>support  address  ranges  with  up  to  32  bits  (address  ranges  with  up  to  16  bit  length  of </p>
<p>addresses are not using any extended segments). </p>
<p>In the auto-mode, the used segment mode depends on the address length of each line. If </p>
<p>the address length of a line that shall be written exceeds 16 bits, but is lower or equal than </p>
<p>20 bits, the extended segment will be used. If the size of the address is larger than 20 bits, </p>
<p>the extended linear segment type will be used. </p>
<p>Sometimes it is necessary to restrict the number of bytes per record line in the output file. </p>
<p>This can be adjusted with the “Max bytes per record line” parameter. </p>
<p><b>2.2.1.9.3 </b></p>
<p><b>Export as HEX-ASCII </b></p>
<p>The  internal  data  will  be  exported  as  HEX-ASCII.  Each  byte  will  be  written  as  a  pair of </p>
<p>characters. A separator between bytes can be specified as well as the number of bytes </p>
<p>that shall be written per line before a newline will be inserted. </p>
<p>The number of characters per line can be entered in decimal or hexadecimal value. To use </p>
<p>hexadecimal values, the value must start with ‘0x’, e.g. 0x20 will output 32 bytes per line. </p>
<h1 style="page-break-before:always; "></h1>
<p>Reference Manual HexView </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 1.12.02 </p>
<p>26 </p>
<p>based on template version 5.1.0 </p>
<p> </p>
<p>Figure 2-9 </p>
<p>Export HEX ASCII data </p>
<p><b>2.2.1.9.4 </b></p>
<p><b>Export as CCP Flashkernel </b></p>
<p>This option  generates  the  internal data  into  an  Intel-HEX  file,  including  the  data  section </p>
<p>necessary for the CCP/XCP flash kernel. </p>
<p> </p>
<p>Figure 2-10 </p>
<p>Export flashkernel data for CCP/XCP </p>
<p>The section information is directly copied into the FKL-header section. </p>
<h1 style="page-break-before:always; "></h1>
<p>Reference Manual HexView </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 1.12.02 </p>
<p>27 </p>
<p>based on template version 5.1.0 </p>
<p>The  kernel  header  contains  a  few  information  about  the  kernel  file  name,  both  the </p>
<p>addresses of the RAM and the start address of the main application in the flash kernel.  </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>The main application of each flash kernel starts with the function: </p>
<p>ccpBootLoaderStartup(), ensure FLASH_KERNEL_RAM_START has got the right </p>
<p>function address. Sometimes the flash kernel location is at the same address like a </p>
<p>vector interrupt table, to prove this, the developer must add the size of the kernel to the </p>
<p>FLASH_KERNEL_RAM_START address. For Example here </p>
<p>FLASH_KERNEL_RAM_START + FLASH_KERNEL_SIZE = 1533. That mean the </p>
<p>RAM area from 0x1000 – 0x1533 must be clear. </p>
<p><b> </b></p>
<p><b> </b></p>
<p>FLASH_KERNEL_NAME=”xxxxx.fkl” </p>
<p>FLASH_KERNEL_COMMENT=”Flash Kernel for xxxxxx” </p>
<p>FLASH_KERNEL_FILE_ADDR=0x1000 </p>
<p>FLASH_KERNEL_SIZE=0x0533 </p>
<p>FLASH_KERNEL_RAM_ADDR=0x1000 </p>
<p>FLASH_KERNEL_RAM_START=0x1000 </p>
<p>The parameters of the flash kernel reflect directly the input of the dialog. </p>
<p>These parameters are also written to an INI-file, so that it can be retrieved the next time </p>
<p>when this dialog will be opened. An example of the INI-file is shown below: </p>
<p>[FLASH_KERNEL_CONFIG] </p>
<p>;FLASH_KERNEL_NAME=”S12D64kernel.fkl” </p>
<p>FLASH_KERNEL_COMMENT=”CCP Flash Kernel for Star12D64@16Mhz Version </p>
<p>1.0.0” </p>
<p>;FLASH_KERNEL_FILE_ADDR=0x039A </p>
<p>;FLASH_KERNEL_SIZE=0x0426 </p>
<p>;FLASH_KERNEL_RAM_ADDR=0x039A </p>
<p>FLASH_KERNEL_RAM_START=0x039A </p>
<p>; or: FLASH_KERNEL_RAM_START=@S12D64Kernel.map:  </p>
<p>ccpBootLoaderStartup                      %lx </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>FLASH_KERNEL_NAME: If omitted, HexView will use the filename of the loaded file. </p>
<p>FLASH_KERNEL_ADDR: If omitted, HexView will use the lowest address of the block </p>
<p>FLASH_KERNEL_SIZE: If omitted, HexView will use the total size of the block </p>
<p>FLASH_KERNEL_RAM_START: If omitted, HexView will use the lowest address of the </p>
<p>block. See also description below. </p>
<p><b> </b></p>
<p><b> </b></p>
<p>Usually, the value of FLASH_KERNEL_RAM_START must specify the address location of </p>
<p>the function </p>
<p>ccpBootLoaderStartup()</p>
<p> in the flash kernel. Since this value can change </p>
<p>after  changing  the  CCP-kernel  files,  a  special  feature  has  been  added  to  extract  the </p>
<p>address information from a MAP-file. Even though the implementation is very basic, it can </p>
<p>be  very  helpful. A  special  syntax  enables  this  feature.  The  line  must  start  with  the <b> ‘@’ </b></p>
<p>followed by the MAP-file. A <b>‘:’ </b>separates this information from the following line. This line is </p>
<p>used for a scan process of the MAP-file. HexView reads every line and tries to interpret the </p>
<h1 style="page-break-before:always; "></h1>
<p>Reference Manual HexView </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 1.12.02 </p>
<p>28 </p>
<p>based on template version 5.1.0 </p>
<p>MAP-file </p>
<p>line </p>
<p>by </p>
<p>using </p>
<p>the </p>
<p>remaining </p>
<p>parameter </p>
<p>in </p>
<p>an </p>
<p>SSCANF </p>
<p>function </p>
<p>call. </p>
<p>The </p>
<p>parameter <b>“%lx” </b>must represent the address value of the function ccpBootLoaderStartup. </p>
<p>If  the  scan  process  was  not  successful,  HexView  will  add  the  complete  line  to  the </p>
<p>parameter. </p>
<p>The  example  above  extracts  successfully  the  information  from  the  following  map-file </p>
<p>(extract of a Metrowerks compiler output): </p>
<p>MODULE:                 -- boot_ccp.obj – </p>
<p>- PROCEDURES: </p>
<p>     ccpBootLoaderStartup                      38EB      1E      </p>
<p>30       0   .text        </p>
<p> </p>
<p><b>2.2.1.9.5 </b></p>
<p><b>Export as C-Array </b></p>
<p>This option writes the data into a C-style file format: </p>
<p> </p>
<p>Figure 2-11 </p>
<p>Export data into a C-Array </p>
<p>The array size can be either 8-, 16- or 32-bit. If 16-bit or 32-bit is selected, the output can </p>
<p>be chosen as either Motorola (big-endian) or Intel (little-endian) style. </p>
<p>The  array  can  be  exported  as  plain  C-data.  But  it  is  also  possible  to  encrypt  it.  The </p>
<p>encryption </p>
<p>will </p>
<p>be </p>
<p>an </p>
<p>XOR </p>
<p>operation </p>
<p>with </p>
<p>the </p>
<p>specified </p>
<p>parameter. </p>
<p>The </p>
<p>decryption </p>
<p>parameter is also given in C-style. </p>
<p>The data is written into a C-array. The array name will use the prefix given from the dialog. </p>
<p>If the block contains several blocks, the data will be written into several C-Arrays. Each </p>
<p>block will contain the block number as a postfix. </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Reference Manual HexView </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 1.12.02 </p>
<p>29 </p>
<p>based on template version 5.1.0 </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Example for the C-File </b></p>
<p>/**************************************************************** </p>
<p>*  Filename:      D:\Usr\Armin\VC\HexView\_page4a.C </p>
<p>*  Project:       C-Array of Flash-Driver </p>
<p>*  File created:  Sun Jan 15 20:59:35 2006 </p>
<p>****************************************************************/ </p>
<p> </p>
<p>#include &lt;fbl_inc.h&gt; </p>
<p>#include &lt;_page4a.h&gt; </p>
<p> </p>
<p>#if (FLASHDRV_GEN_RAND!=1739) </p>
<p># error “Generated header and C-File inconsistent!!” </p>
<p>#endif </p>
<p> </p>
<p>V_MEMROM0 MEMORY_ROM unsigned char flashDrvBlk0[FLASHDRV_BLOCK0_LENGTH] = { </p>
<p>  0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, </p>
<p>0x0E, 0x0F, </p>
<p>  0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, </p>
<p>0x1E, 0x1F, </p>
<p>  0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, </p>
<p>0x2E, 0x2F, </p>
<p>  0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, </p>
<p>0x3E, 0x3F, </p>
<p>  0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, </p>
<p>0x4E, 0x4F, </p>
<p>  0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x5B, 0x5C, 0x5D, </p>
<p>0x5E, 0x5F, </p>
<p>  0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, </p>
<p>0x6E, 0x6F, </p>
<p>  0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x7B, 0x7C, 0x7D, </p>
<p>0x7E, 0x7F, </p>
<p>  0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8A, 0x8B, 0x8C, 0x8D, </p>
<p>0x8E, 0x8F, </p>
<p>  0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9A, 0x9B, 0x9C, 0x9D, </p>
<p>0x9E, 0x9F, </p>
<p>  0xA0, 0xA1, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6, 0xA7, 0xA8, 0xA9, 0xAA, 0xAB, 0xAC, 0xAD, </p>
<p>0xAE, 0xAF, </p>
<p>  0xB0, 0xB1, 0xB2, 0xB3, 0xB4, 0xB5, 0xB6, 0xB7, 0xB8, 0xB9, 0xBA, 0xBB, 0xBC, 0xBD, </p>
<p>0xBE, 0xBF, </p>
<p>  0xC0, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, </p>
<p>0xCE, 0xCF, </p>
<p>  0xD0, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7, 0xD8, 0xD9, 0xDA, 0xDB, 0xDC, 0xDD, </p>
<p>0xDE, 0xDF, </p>
<p>  0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, </p>
<p>0xEE, 0xEF, </p>
<p>  0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, </p>
<p>0xFE, 0xFF </p>
<p>}; </p>
<p> </p>
<p>Example of the Header-File: </p>
<p>/**************************************************************** </p>
<p>* </p>
<p>*  Filename:      D:\Usr\Armin\VC\HexView\_page4a.h </p>
<p>*  Project:       Exported definition of C-Array Flash-Driver </p>
<p>*  File created:  Sun Jan 15 20:59:35 2006 </p>
<p> </p>
<p>* </p>
<p>****************************************************************/ </p>
<p> </p>
<p>#define FLASHDRV_GEN_RAND 1739 </p>
<p> </p>
<p>#define FLASHDRV_DECRYPTDATA(a)   (unsigned char)a </p>
<p>#define FLASHDRV_BLOCK0_ADDRESS  0x9000 </p>
<p>#define FLASHDRV_BLOCK0_LENGTH 0x100 </p>
<p>#define FLASHDRV_BLOCK0_CHECKSUM 0x7F80u </p>
<p> </p>
<p>extern V_MEMROM0 MEMORY_ROM unsigned char flashDrvBlk0[FLASHDRV_BLOCK0_LENGTH]; </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Reference Manual HexView </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 1.12.02 </p>
<p>30 </p>
<p>based on template version 5.1.0 </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Example for the C-File </b></p>
<p>/**************************************************************** </p>
<p>*  Filename:      D:\Usr\Armin\VC\HexView\_page4a.C </p>
<p>*  Project:       C-Array of Flash-Driver </p>
<p>*  File created:  Sun Jan 15 20:59:35 2006 </p>
<p>****************************************************************/ </p>
<p> </p>
<p>#include &lt;fbl_inc.h&gt; </p>
<p>#include &lt;_page4a.h&gt; </p>
<p> </p>
<p>#if (FLASHDRV_GEN_RAND!=1739) </p>
<p># error “Generated header and C-File inconsistent!!” </p>
<p>#endif </p>
<p> </p>
<p>V_MEMROM0 MEMORY_ROM unsigned char flashDrvBlk0[FLASHDRV_BLOCK0_LENGTH] = { </p>
<p> </p>
<p>0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, </p>
<p>0x0E, 0x0F, </p>
<p> </p>
<p>0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, </p>
<p>0x1E, 0x1F, </p>
<p> </p>
<p>0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, </p>
<p>0x2E, 0x2F, </p>
<p> </p>
<p>0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, </p>
<p>0x3E, 0x3F, </p>
<p> </p>
<p>0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, </p>
<p>0x4E, 0x4F, </p>
<p> </p>
<p>0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x5B, 0x5C, 0x5D, </p>
<p>0x5E, 0x5F, </p>
<p> </p>
<p>0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, </p>
<p>0x6E, 0x6F, </p>
<p> </p>
<p>0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x7B, 0x7C, 0x7D, </p>
<p>0x7E, 0x7F, </p>
<p> </p>
<p>0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8A, 0x8B, 0x8C, 0x8D, </p>
<p>0x8E, 0x8F, </p>
<p> </p>
<p>0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9A, 0x9B, 0x9C, 0x9D, </p>
<p>0x9E, 0x9F, </p>
<p> </p>
<p>0xA0, 0xA1, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6, 0xA7, 0xA8, 0xA9, 0xAA, 0xAB, 0xAC, 0xAD, </p>
<p>0xAE, 0xAF, </p>
<p> </p>
<p>0xB0, 0xB1, 0xB2, 0xB3, 0xB4, 0xB5, 0xB6, 0xB7, 0xB8, 0xB9, 0xBA, 0xBB, 0xBC, 0xBD, </p>
<p>0xBE, 0xBF, </p>
<p> </p>
<p>0xC0, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, </p>
<p>0xCE, 0xCF, </p>
<p> </p>
<p>0xD0, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7, 0xD8, 0xD9, 0xDA, 0xDB, 0xDC, 0xDD, </p>
<p>0xDE, 0xDF, </p>
<p> </p>
<p>0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, </p>
<p>0xEE, 0xEF, </p>
<p> </p>
<p>0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, </p>
<p>0xFE, 0xFF </p>
<p>};</p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Reference Manual HexView </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 1.12.02 </p>
<p>31 </p>
<p>based on template version 5.1.0 </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Example of the Header-File</b> </p>
<p>/**************************************************************** </p>
<p>* </p>
<p>*  Filename:      D:\Usr\Armin\VC\HexView\_page4a.h </p>
<p>*  Project:       Exported definition of C-Array Flash-Driver </p>
<p>*  File created:  Sun Jan 15 20:59:35 2006 </p>
<p> </p>
<p>* </p>
<p>****************************************************************/ </p>
<p> </p>
<p>#define FLASHDRV_GEN_RAND 1739 </p>
<p> </p>
<p>#define FLASHDRV_DECRYPTDATA(a)   (unsigned char)a </p>
<p>#define FLASHDRV_BLOCK0_ADDRESS  0x9000 </p>
<p>#define FLASHDRV_BLOCK0_LENGTH 0x100 </p>
<p>#define FLASHDRV_BLOCK0_CHECKSUM 0x7F80u </p>
<p> </p>
<p>extern V_MEMROM0 MEMORY_ROM unsigned char flashDrvBlk0[FLASHDRV_BLOCK0_LENGTH];</p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p>The macro [Prefix-name]_DECRYPTDATA() can be used to extract and encrypt the data. It </p>
<p>will be generated according to the encryption option and value. </p>
<p>The  output  can  also  generated  via  the  command  line.  Refer  to  section  3.3.3  for  further </p>
<p>information. </p>
<p>The declaration of the C-arrays are dedicated to the Vector 31ootloader. In some cases, it </p>
<p>might  be  necessary  to  use  these  structures  in  a  pure  C-environment  without  compiler </p>
<p>abstraction used by Vector’s naming convention. Use the “Use strict Ansi-C declaration” in </p>
<p>this case. </p>
<p>Another option is to use so-called memmap-statements. Hexview will generate statements </p>
<p>to delare a define and then include the file memmap.h: </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Example</b> </p>
<p>Memmap declarations generated by Hexview: </p>
<p>#define FLASHDRV_START_SEC_CONST </p>
<p>#include “memmap.h” </p>
<p> </p>
<p>The file memmap.h may look like this: </p>
<p>#ifdef FLASHDRV_START_SEC_CONST </p>
<p>#undef FLASHDRV_START_SEC_CONST </p>
<p>#pragma section .flashdrv </p>
<p>#endif </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>2.2.1.9.6 </b></p>
<p><b>Export Mime coded data </b></p>
<p>This item exports the data file in MIME-coded format with BASE64 coding. </p>
<p><b>2.2.1.9.7 </b></p>
<p><b>Export Binary data </b></p>
<p>This item will write all data contents in the order of their appearance into a binary file. </p>
<p>All segments will be written linear into the data block </p>
<h1 style="page-break-before:always; "></h1>
<p>Reference Manual HexView </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 1.12.02 </p>
<p>32 </p>
<p>based on template version 5.1.0 </p>
<p><b>2.2.1.9.8 </b></p>
<p><b>Export binary block data </b></p>
<p>This item will export the data into a binary file. However, if the internal data file contains </p>
<p>several  blocks,  the  data  is  written  to  different  files.  Each  filename  will  have  the  base </p>
<p>address as a postfix. </p>
<p> </p>
<p>Figure 2-12 </p>
<p>Export binary block data </p>
<p>File output names: </p>
<p><b></b></p>
<p><b> </b></p>
<p>_page3_overlap_fe2.bin </p>
<p><b></b></p>
<p><b> </b></p>
<p>_page3_overlap_4020.bin </p>
<p><b></b></p>
<p><b> </b></p>
<p>_page3_overlap_9000.bin </p>
<p> </p>
<p><b>2.2.1.9.9 </b></p>
<p><b>Export Fiat Binary File </b></p>
<p>This exports data in the FIAT file format. </p>
<p> </p>
<p>Figure 2-13: Export dialog for the FIAT binary file </p>
<h1 style="page-break-before:always; "></h1>
<p>Reference Manual HexView </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 1.12.02 </p>
<p>33 </p>
<p>based on template version 5.1.0 </p>
<p>The  dialog  shown  above  can  only  be  understood  if  the  Fiat  file  format  is  known.  This </p>
<p>document  does  not  intend  to  explain  this  file  format.  Refer  to  0728401.pdf  for  further </p>
<p>explanation. </p>
<p>During the export, an INI-file will be updated or generated. If the INI-File was specified by </p>
<p>the commandline, this file will be used. Otherwise, an existing file will be updated or new </p>
<p>file will be generated with the same name and location as the export filename. For the INI-</p>
<p>file format, refer to section 3.3.2, “Output a Fiat specific data file (/XB)”. </p>
<p><b>2.2.1.9.10 </b></p>
<p><b>Export Ford Ihex data container </b></p>
<p>The  file  format  generated  with  this  output  is  based  on  the  Ford-specification  “Module </p>
<p>Programming  &amp;  Configuration  Design  Specification”,  V  2003.0,  dated:  25  April  2005, </p>
<p>Annex C. </p>
<p>Besides the download data itself, there are some optional and mandatory values added to </p>
<p>the output file. The optional fields can be selected/unselected with the option checkbox. </p>
<p>All values entered in the dialog below will be written to the INI-File. The INI-file can also be </p>
<p>used for the command line option to generate the output without the needs of a user input. </p>
<p>For detailed description of each item of the data fields, refer to the document mentioned </p>
<p>above. Further information can be found in section  3.3.4, “Output Ford files in Intel-HEX </p>
<p>format”. </p>
<p>Information: The file format has been replaced by VBF. </p>
<h1 style="page-break-before:always; "></h1>
<p>Reference Manual HexView </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 1.12.02 </p>
<p>34 </p>
<p>based on template version 5.1.0 </p>
<p> </p>
<p>Figure 2-14: Export dialog for Ford I-Hex output file </p>
<p><b>2.2.1.9.11 </b></p>
<p><b>Export Ford VBF data container </b></p>
<p>The  VBF  file  format  is  the  Versatile  Binary  Format  used  by  Ford  and  VolvoCars.  The </p>
<p>output of this file is based on the specification “Versatile Binary Format”, V2.2 until V2.5. </p>
<p>All values entered in the dialog below will be written to the INI-File. The INI-file can also be </p>
<p>used for the command line option to generate the output without the needs of a user input. </p>
<p>Refer to section 3.3.5, “Output Files in VBF format” for further information. </p>
<h1 style="page-break-before:always; "></h1>
<p>Reference Manual HexView </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 1.12.02 </p>
<p>35 </p>
<p>based on template version 5.1.0 </p>
<p> </p>
<p>Figure 2-15: Export dialog for the Ford/VolvoCars-VBF data file format </p>
<p><b>2.2.1.9.12 </b></p>
<p><b>Export GM data </b></p>
<p>This item is just present to indicate, that the tool also supports GM-data export. In fact, the </p>
<p>GM data preparation must be done through the commandline option. More information can </p>
<p>be found in section 3.3.7. </p>
<p>The GM data container is simply a binary file stream. It can be exported through the binary </p>
<p>export. </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Reference Manual HexView </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 1.12.02 </p>
<p>36 </p>
<p>based on template version 5.1.0 </p>
<p>Figure 2-16: The output information for the GM data export </p>
<p><b>2.2.1.9.13 </b></p>
<p><b>Export GM-FBL header info </b></p>
<p>This option provides the possibility to export the address and length information of each </p>
<p>segment into an XML-File. Also, the number of segments and the checksum value will be </p>
<p>written  into  the  XML-file.  If  the  checksum  target  address  is  located  within  the  segment </p>
<p>array,  the  tool  will  automatically  split  this  region  into  two  to  spare  the  location  of  the </p>
<p>checksum. Thus, the checksum can be re-calculated. </p>
<p>The purpose of this output is to read the XML-file into the configuration and generation tool </p>
<p>“Geny”. It is used to generate the GM-header info for the GM flash Bootloader. It allows the </p>
<p>Bootloader to calculate the checksum on its own data.  </p>
<p>It  may  require  two  rounds  (generate  the  configuration,  compile  and  link  the  Bootloader, </p>
<p>generate the XML-file with Hexview) for a valid header. </p>
<p> </p>
<p>Figure 2-17: Export dialog to generate the GM-FBL header information for GENy </p>
<p>The XML-file has the following format: </p>
<p><i>&lt;!—Created by HexView v2006 (Vector Informatik GmbH) </i></p>
<p></p>
<p> </p>
<p>&lt;<b>ECU</b> xmlns:xsi<b>=</b>”http://www.w3.org/2001/XMLSchema-instance” </p>
<p>xsi:noNamespaceSchemaLocation<b>=</b>”FBLConfiguration.xsd”&gt; </p>
<p>    &lt;<b>FBLConfiguration</b>&gt; </p>
<p>        &lt;<b>PMA</b> <b>ID=</b>”1”&gt; </p>
<p>            &lt;<b>Checksum</b> Value<b>=</b>”51434”/&gt; </p>
<p>            &lt;<b>NumberOfPMA</b> Value<b>=</b>”2”/&gt; </p>
<p>            &lt;<b>PMAField</b>&gt; </p>
<p>              &lt;<b>Address</b> Value<b>=</b>”8380416”/&gt; </p>
<p>              &lt;<b>Length</b> Value<b>=</b>”1932”/&gt; </p>
<p>            &lt;/<b>PMAField</b>&gt; </p>
<p>            &lt;<b>PMAField</b>&gt; </p>
<p>              &lt;<b>Address</b> Value<b>=</b>”8388368”/&gt; </p>
<p>              &lt;<b>Length</b> Value<b>=</b>”240”/&gt; </p>
<p>            &lt;/<b>PMAField</b>&gt; </p>
<p>        &lt;/<b>PMA</b>&gt; </p>
<h1 style="page-break-before:always; "></h1>
<p>Reference Manual HexView </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 1.12.02 </p>
<p>37 </p>
<p>based on template version 5.1.0 </p>
<p>    &lt;/<b>FBLConfiguration</b>&gt; </p>
<p>&lt;/<b>ECU</b>&gt; </p>
<p><b>2.2.1.9.14 </b></p>
<p><b>Export VAG data container </b></p>
<p>This item exports the data into a VAG-compatible data container format. </p>
<p> </p>
<p>Figure 2-18 </p>
<p>Exports data into a VAG-compatible data container </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>The generated VAG data file is NOT compatible with the ODX-F format used for UDS. </p>
<p><b> </b></p>
<p><b> </b></p>
<p>The  VAG  data  container  is  a  SGML-file  that  can  be  divided  into  five  sections.  Three </p>
<p>sections are merged from external files, two others are generated. </p>
<p><b>Section 1: </b></p>
<p>&lt;!DOCTYPE SW-CNT PUBLIC “-//Volkswagen AG//DTD </p>
<p>Datencontainer fuer die SG-Programmierung </p>
<h1 style="page-break-before:always; "></h1>
<p>Reference Manual HexView </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 1.12.02 </p>
<p>38 </p>
<p>based on template version 5.1.0 </p>
<p> “SGM pre-header file”. </p>
<p>HexView parses this file and checks, if the fields </p>
<p>in [1], [2] or [3] are blank. If not blank, it will copy </p>
<p>the contents as is from the file. But if the fields </p>
<p>are left blank, it will be filled with parameters </p>
<p>from the dialog box: </p>
<p>[1] = filename from “destination file” without the </p>
<p>path </p>
<p>[2] = the value from “S/W version” </p>
<p>[3] = the value from “Part number” </p>
<p>V00.80:MiniDC08.DTD//GE” “minidc08.dtd”&gt; </p>
<p>&lt;SW-CNT&gt; </p>
<p>&lt;IDENT&gt; </p>
<p>    &lt;CNT-DATEI&gt;  <b>[1]</b> &lt;/CNT-DATEI&gt; </p>
<p>    &lt;CNT-VERSION-TYP&gt;cvt_pfu_01&lt;/CNT-VERSION-</p>
<p>TYP&gt; </p>
<p>    &lt;CNT-VERSION-INHALT&gt;0.80&lt;/CNT-VERSION-</p>
<p>INHALT&gt; </p>
<p>    &lt;CNT-IDENT-TEXT&gt;MyProject&lt;/CNT-IDENT-TEXT&gt; </p>
<p>    &lt;SW-VERSION-KURZ&gt; <b>[2]</b> &lt;/SW-VERSION-KURZ&gt; </p>
<p>    &lt;SW-VERSION-LANG&gt; <b>[3]</b> &lt;/SW-VERSION-LANG&gt; </p>
<p>&lt;/IDENT&gt; </p>
<p>&lt;INFO&gt; </p>
<p>    &lt;ADRESSEN&gt; </p>
<p>      &lt;ADRESSE&gt; </p>
<p>        &lt;FIRMENNAME&gt;S/W-Development </p>
<p>GmbH&lt;/FIRMENNAME&gt; </p>
<p>        &lt;ROLLE&gt;Entwicklung VAG-Software&lt;/ROLLE&gt; </p>
<p>        &lt;ABTEILUNG&gt;ESVG&lt;/ABTEILUNG&gt; </p>
<p>        &lt;PERSON&gt;Klaus Mustermann&lt;/PERSON&gt; </p>
<p>        &lt;ANSCHRIFT&gt;Gewerbestrasse 40, D-03421 </p>
<p>Ingolsheim&lt;/ANSCHRIFT&gt; </p>
<p>        &lt;TELEFON&gt;+49-6234-123-456&lt;/TELEFON&gt; </p>
<p>        &lt;FAX&gt;+49-6234-123-200&lt;/FAX&gt; </p>
<p>        &lt;EMAIL&gt;Klaus.Mustermann@sw-</p>
<p>develop.de&lt;/EMAIL&gt; </p>
<p>      &lt;/ADRESSE&gt; </p>
<p>    &lt;/ADRESSEN&gt; </p>
<p>    &lt;REVISIONEN&gt; </p>
<p>      &lt;REVISION&gt; </p>
<p>        &lt;WANN&gt;&lt;/WANN&gt; </p>
<p>        &lt;WER&gt;&lt;/WER&gt; </p>
<p>        &lt;WAS&gt;&lt;/WAS&gt; </p>
<p>        &lt;WARUM&gt;&lt;/WARUM&gt; </p>
<p>        &lt;VERSION&gt;&lt;/VERSION&gt; </p>
<p>      &lt;/REVISION&gt; </p>
<p>    &lt;/REVISIONEN&gt; </p>
<p>&lt;/INFO&gt; </p>
<p>&lt;ABLAEUFE&gt; </p>
<p>    &lt;ABLAUF&gt; </p>
<p>      &lt;ABLAUF-NAME&gt;abn_pfu&lt;/ABLAUF-NAME&gt; </p>
<p>      &lt;KWP-2000&gt; </p>
<p>        &lt;KWP-2000-TGT&gt;0x62&lt;/KWP-2000-TGT&gt; </p>
<p>        &lt;KWP-2000-REI&gt; </p>
<p>          &lt;KWP-2000-PSTAT-BIT0&gt;255&lt;/KWP-2000-</p>
<p>PSTAT-BIT0&gt; </p>
<p>          &lt;KWP-2000-PSTAT-BIT1&gt;6&lt;/KWP-2000-</p>
<p>PSTAT-BIT1&gt; </p>
<p>          &lt;KWP-2000-PSTAT-BIT2&gt;10&lt;/KWP-2000-</p>
<p>PSTAT-BIT2&gt; </p>
<p>          &lt;KWP-2000-PSTAT-BIT3&gt;0&lt;/KWP-2000-</p>
<p>PSTAT-BIT3&gt; </p>
<p>          &lt;KWP-2000-PSTAT-BIT4&gt;0&lt;/KWP-2000-</p>
<p>PSTAT-BIT4&gt; </p>
<p>          &lt;KWP-2000-PSTAT-BIT5&gt;0&lt;/KWP-2000-</p>
<p>PSTAT-BIT5&gt; </p>
<p>          &lt;KWP-2000-PSTAT-BIT6&gt;0&lt;/KWP-2000-</p>
<p>PSTAT-BIT6&gt; </p>
<p>          &lt;KWP-2000-PSTAT-BIT7&gt;0&lt;/KWP-2000-</p>
<p>PSTAT-BIT7&gt; </p>
<p>        &lt;/KWP-2000-REI&gt; </p>
<p>        &lt;KWP-2000-ACP&gt; </p>
<p>          &lt;KWP-2000-P2MIN&gt;0xFF&lt;/KWP-2000-P2MIN&gt;  </p>
<p>          &lt;KWP-2000-P2MAX&gt;0xFF&lt;/KWP-2000-P2MAX&gt;  </p>
<p>          &lt;KWP-2000-P3MIN&gt;0xFF&lt;/KWP-2000-P3MIN&gt;  </p>
<p>          &lt;KWP-2000-P3MAX&gt;0xFF&lt;/KWP-2000-P3MAX&gt;  </p>
<p>          &lt;KWP-2000-P4MIN&gt;0xFF&lt;/KWP-2000-P4MIN&gt;  </p>
<p>        &lt;/KWP-2000-ACP&gt; </p>
<p>        &lt;KWP-2000-</p>
<p>SA2&gt;0x12,0x23,0x23,0x34,0x45,0x56C&lt;/KWP-2000-</p>
<p>SA2&gt; </p>
<p>      &lt;/KWP-2000&gt; </p>
<p><b>Section 2: </b></p>
<p>      &lt;DATEN-VERWEISE&gt; </p>
<p>        &lt;DATEN-VERWEIS&gt;FLASHDRV&lt;/DATEN-VERWEIS&gt; </p>
<p>        &lt;DATEN-VERWEIS&gt;dav_pfu_01&lt;/DATEN-</p>
<h1 style="page-break-before:always; "></h1>
<p>Reference Manual HexView </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 1.12.02 </p>
<p>39 </p>
<p>based on template version 5.1.0 </p>
<p>Generated “Data Reference section” </p>
<p>The reference section contains a reference to </p>
<p>each segment or block. An external Hex-file can </p>
<p>be added for reference, e.g. a HIS-flash driver.  It </p>
<p>is necessary that this hex field contains only one </p>
<p>segment or block. </p>
<p>VERWEIS&gt; </p>
<p>      &lt;/DATEN-VERWEISE&gt; </p>
<p><b>Section 3: </b></p>
<p> “SGM post-header file”. </p>
<p>    &lt;/ABLAUF&gt; </p>
<p>&lt;/ABLAEUFE&gt; </p>
<p><b>Section 4: </b></p>
<p>Generated “data section”. </p>
<p>This section contains the current data. On the </p>
<p>right side an example of the output is shown. </p>
<p>Start and end address is taken from the block </p>
<p>information. The checksum is calculated with the </p>
<p>given checksum method (see section 2.2.2.6 or </p>
<p>3.2.10 for further details on  checksum </p>
<p>calculation). The erase section is calculated out </p>
<p>of the section length. The value of </p>
<p>&lt;DATENBLOCK-FORMAT&gt; is taken from the </p>
<p>“Data Format ID” field in the dialog box. </p>
<p>The &lt;DATENBLOCK-DATEN&gt; contains the data </p>
<p>of the block or segment in a MIME-coded format. </p>
<p>        &lt;DATENBLOCK-</p>
<p>NAME&gt;dav_pfu_01&lt;/DATENBLOCK-NAME&gt; </p>
<p>        &lt;DATENBLOCK-FORMAT-</p>
<p>NAME&gt;dfn_mime&lt;/DATENBLOCK-FORMAT-NAME&gt; </p>
<p>        &lt;START-ADR&gt;0x9000&lt;/START-ADR&gt; </p>
<p>        &lt;DATENBLOCK-FORMAT&gt;0x00&lt;/DATENBLOCK-</p>
<p>FORMAT&gt; </p>
<p>        &lt;GROESSE-DEKOMPRIMIERT&gt;0xFA2&lt;/GROESSE-</p>
<p>DEKOMPRIMIERT&gt; </p>
<p>        &lt;LOESCH-BEREICH&gt; </p>
<p>         &lt;START-ADR&gt;0x9000&lt;/START-ADR&gt; </p>
<p>         &lt;END-ADR&gt;0x9FA1&lt;/END-ADR&gt; </p>
<p>        &lt;/LOESCH-BEREICH&gt; </p>
<p>        &lt;DATENBLOCK-CHECK&gt; </p>
<p>         &lt;START-ADR&gt;0x9000&lt;/START-ADR&gt; </p>
<p>         &lt;END-ADR&gt;0x9FA1&lt;/END-ADR&gt; </p>
<p>         &lt;CHECKSUMME&gt;0xA866&lt;/CHECKSUMME&gt; </p>
<p>        &lt;/DATENBLOCK-CHECK&gt; </p>
<p>        &lt;DATENBLOCK-DATEN&gt; </p>
<p>MIME-Version: 1.0 </p>
<p> </p>
<p>WflaW1xdXl9gYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXp</p>
<p>7fH1+f4CbgoOE </p>
<p>hYaHiImKi4yNjo+QkZKTlJWWl5iZmpucnZ6foKGio6Slpqe</p>
<p>oqaqrrK2ur7Cx </p>
<p>srO0tba3uLm6u7y9vr/AwcLDxMXGx8jJysvMzc7P0NHS09T</p>
<p>V1tfY2drb3N3e </p>
<p>        &lt;/DATENBLOCK-DATEN&gt; </p>
<p>      &lt;/DATENBLOCK&gt; </p>
<p>    &lt;/DATENBLOECKE&gt; </p>
<p>&lt;/DATEN&gt; </p>
<p><b>Section 5: </b></p>
<p>Appending file contents from „SGM footer file“ </p>
<p>&lt;/SW-CNT&gt; </p>
<p>Table 2-3  </p>
<p>Description of the elements for the VAG SGML output container </p>
<p>It should be noted, that the filename is automatically generated out of the part number and </p>
<p>the S/W-version fields whenever the fields are changed. You can overwrite the name if the </p>
<p>filename is changed at last. When editing the filename or <b>[Browse] </b>for a file, the name will </p>
<p>not automatically adapted. </p>
<p>It is also possible to preprocess the data before it is MIME-coded. This process is done </p>
<p>after the checksum calculation. It is intended to be used for e.g. Data Encryption. </p>
<p>It uses the standard interface functions from the EXPDATPROC.DLL (refer to section 4.2, </p>
<p>2.2.2.7 and 3.2.11 for further details). </p>
<p><b>INI-File info for VAG export </b></p>
<p>The dialog information is stored in an INI-file. This file has the same name as the HEX-file, </p>
<p>but with the file extension INI. Every time this dialog will be opened, CANflash checks for </p>
<p>such  an  INI-file  and  retrieves  the  information  from  there.  This  allows  to  store  project </p>
<h1 style="page-break-before:always; "></h1>
<p>Reference Manual HexView </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 1.12.02 </p>
<p>40 </p>
<p>based on template version 5.1.0 </p>
<p>information in separate files. It is a prerequisite that the INI-file resides in the same folder </p>
<p>as the HEX-file. </p>
<p>This INI-File can then also be used in the command line option. </p>
<p>The following list file shows an example of the INI-file: </p>
<p>[SGMDATA] </p>
<p>DATENBLOCKNAME=dav_pfu </p>
<p>FLASHDRVSECTION=FLASHDRV </p>
<p>FLASHDRV=D:\Usr\Armin\VC\HexView\FLASHCODE_SH70XXF_704.hex </p>
<p>SGMHEADERPRE=header1.txt </p>
<p>SGMHEADERPOST=header2.txt </p>
<p>SGMFOOTER=footer.txt </p>
<p>CHECKSUMTYPE=2 </p>
<p>DATAPROCESSINGTYPE=0 </p>
<p>DATAPROCESSINGPARAMETER=1234567890 </p>
<p>PARTNUMBER=123456789ab </p>
<p>SW_VERSION=cdef </p>
<p>FLASHDRV_DLID=12 </p>
<p>DATA_DLID=24 </p>
<p>MAXBLOCKLEN=0x400 </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>This INI-file is automatically created when executing this dialog. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>2.2.1.9.15 </b></p>
<p><b>Export GAC binary files </b></p>
<p>This option allows to write the internal data from Hexview to a GAC binary file. </p>
<p>The header information will be taken from the INI-file info section and written to the binary. </p>
<p>With this option it is only possible to write GAC files with address information. </p>
<p>If  you  want  to  generate  GAC  files  without  address  info,  use  the  commandline  option </p>
<p>“/xgacswil”. </p>
<p> </p>
<p><b>2.2.1.10 </b></p>
<p><b>Print / Print Preview / Printer Setup </b></p>
<p>There is no special support for printer output other than that from the MFC. Thus, the view </p>
<p>output will directly sent to the printer. </p>
<p><b>2.2.1.11 </b></p>
<p><b>Exit </b></p>
<p>Leaves the program. </p>
<p><b>2.2.2 </b></p>
<p><b>Edit </b></p>
<p>This menu item collects some options that can be used to manipulate data in HexView. </p>
<p><b>2.2.2.1 </b></p>
<p><b>Undo </b></p>
<p>This option is currently not supported by HexView. </p>
<h1 style="page-break-before:always; "></h1>
<p>Reference Manual HexView </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 1.12.02 </p>
<p>41 </p>
<p>based on template version 5.1.0 </p>
<p><b>2.2.2.2 </b></p>
<p><b>Cut / Copy / Paste </b></p>
<p>Hexview  uses  an  internal clipboard  (not  the Windows  clipboard). Cut  and  Copy  can  put </p>
<p>data into this clipboard. Even if files are closed and others are opened, the data remain in </p>
<p>clipboard. </p>
<p>It allows, to cut or copy data regions and put it into the data section. As a new challenge, </p>
<p>another  syntax  to  specify  range  has  been  introduced.  Different  from  the  other  regions, </p>
<p>where  start  and  end  address  must  be  specified  as  HEX-values,  the  range  can  now </p>
<p>specified in one single string. The range can be specified in two ways: Using start- and </p>
<p>end address or with startaddress and length. </p>
<p>Start and end address is separated with a ‘-‘ sign. Startaddress and length are separated </p>
<p>with a ‘,’. </p>
<h1 style="page-break-before:always; "></h1>
<p>Reference Manual HexView </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 1.12.02 </p>
<p>42 </p>
<p>based on template version 5.1.0 </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Example </b></p>
<p>Address range with start and end address: 0x9020-0x903f </p>
<p>This specifies start- and end-address in hexadecimal value. A ‘0x’ is required to </p>
<p>preceed. If ‘0x‘ is omitted, the value is treated as a decimal value. This allows to use </p>
<p>the parameters in both hexadecimal or decimal values. </p>
<p> </p>
<p>Figure 2-19 </p>
<p>Example of ‘Copy window’ when Ctrl-C or “Paste” pressed using start- and end-address </p>
<p>Address range with start address and length: 0x9020,32 </p>
<p>This specifies a range from 0x9020 with length of 32 bytes (0x20 bytes). It is the  </p>
<p>range of 0x9020-0x903f. </p>
<p>The standard short-cuts (acceleration keys) for delete (del or Ctrl-x), copy (Ctrl-</p>
<p>c) and paste (Ctrl-V) are supported by Hexview. </p>
<p> </p>
<p>Figure 2-20 </p>
<p>Example of cut-data using start-address and length as a parameter </p>
<p>Cut or paste can only be used if data are present inside Hexview. </p>
<p>The  paste-operation  is  activated  when  something  is  present  in </p>
<p>Hexview’s </p>
<p>internal clipboard. </p>
<p>When  ‘Paste’    (Ctrl-V)  is  entered,  a  window  will  open  where  the  target  paste </p>
<p>address can be specified. By default, the clipboard’s start address will be shown </p>
<p>as a default value. This can be overwritten. An address offset will be applied to </p>
<p>the pasting range from the clipboard. </p>
<h1 style="page-break-before:always; "></h1>
<p>Reference Manual HexView </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 1.12.02 </p>
<p>43 </p>
<p>based on template version 5.1.0 </p>
<p> </p>
<p>Figure 2-21: Pasting the clipboard data into the document specifying the target address </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>2.2.2.3 </b></p>
<p><b>Copy dsPIC like data </b></p>
<p>The dsPIC24/33 has a 24-bit addressing format. The flash memory only contains 3 bytes </p>
<p>per 4 words. Direct data access can be accomplished by addressing the lower 2 bytes, </p>
<p>disregarding the the upper byte. The 4</p>
<p>th</p>
<p> byte is also known as the ghost byte and is always </p>
<p>read  as  0.  Since  the  machine  is  a  16-bit  machine,  its  internal  words  are  normally </p>
<p>addressed  16-bit  wise,  Thus,  address  0x1000  specifies  e.g.  0xABCD,  whereas  0x1001 </p>
<p>then specifies 0x00EF and so on. Intel-HEX or Motorola S-records uses byte addresses. </p>
<p>The Microchip toolchain generates therefore hexfiles with double address. The values from </p>
<p>the example above is then represented on address 0x2000 with bytes 00 EF CD AB. </p>
<p>In somve cases it can be helpful to change the representation in a HEX file from “outer” to </p>
<p>“inner”  addresses  and  vice  versa.  The  copy  procedure  of  Hexview  allows  to  copy  any </p>
<p>section from outer addressed (doubled address) to inner (word) address (Shrink option in </p>
<p>dialog) and vice versa (Expand option in the dialog). </p>
<h1 style="page-break-before:always; "></h1>
<p>Reference Manual HexView </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 1.12.02 </p>
<p>44 </p>
<p>based on template version 5.1.0 </p>
<p> </p>
<p>Figure 2-22: Copy dsPIC like data </p>
<p>When expanding data, Hexview will add 2 zero bytes to the expanded location, one for the </p>
<p>ghost byte and one for the remaining byte. After flashing these data into dsPIC memory, </p>
<p>the data can be access using a byte pointer to data. The correct data will be read now. </p>
<p>When shrink operation is used, the upper two high bytes will not copied, only the lower two </p>
<p>bytes are copied to the new location. </p>
<p>When selecting the “Clear ghost byte” Copy type, no data will be copied, but the highest of </p>
<p>the four bytes will be set to 0. This allows to calculate a correct checksum over the data, </p>
<p>since internally of the dsPIC the ghost byte is always read with 0. </p>
<p>A target location is only required if the shrink or expand address is not double or half of the </p>
<p>specified source address. This option is also available through commandline. </p>
<p><b>2.2.2.4 </b></p>
<p><b>Data Alignment </b></p>
<p>Data Alignment operates on the block start address and its length. This can be used to </p>
<p>adjust the start address and length on all blocks/segments. </p>
<h1 style="page-break-before:always; "></h1>
<p>Reference Manual HexView </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 1.12.02 </p>
<p>45 </p>
<p>based on template version 5.1.0 </p>
<p> </p>
<p>Figure 2-23 </p>
<p>Data alignment option </p>
<p>This option ensures, that the start address of all blocks is a multiple of the segment size </p>
<p>alignment value. E.g., if this parameter is 2, then HexView ensures that all addresses are </p>
<p>even (dividable by 2 without remainder). If an odd address is detected, HexView fills bytes </p>
<p>with the “Fill character” at the beginning of a block until the address is even. </p>
<p>If  “Align  size”  is  selected,  too,  the  size  of  all  blocks  is  a  multiple  of  the  given  segment </p>
<p>alignment value. If a length of a block is not a multiple of the segment align value, a fill </p>
<p>pattern will be added until the size meets this condition. </p>
<p>Some export file formats contain separate address and length information used to specify </p>
<p>the erasable ranges of a flash memory. These address ranges require different alignment </p>
<p>definition. This align value can be specified in the “Erase segment alignment”. It is mainly </p>
<p>used  with  Ford-VBF  and  Fiat  binary/parameter  files.  This  value  can  also  be  specified </p>
<p>through the commandline option /AE. </p>
<p><b>2.2.2.5 </b></p>
<p><b>Fill block data  </b></p>
<p>This option provides the ability to fill data regions. This is possible with either random data </p>
<p>or with a pattern that will be added repetitively. </p>
<p>Within  the  dialog,  one  or  more  block  ranges  must  be  given.  This  parameter  is  used  to </p>
<p>generate the block base address and its size. </p>
<p>The overwrite method specifies how to treat the fill data with the existing data. If the new </p>
<p>data overlaps, the new data may overwrite it or will be weaved into the existing data as a </p>
<p>fill pattern. </p>
<p>The data pattern can either be a random data value or can be filled with a given pattern. </p>
<p>Here, you can even specify several ranges, each one separated by ‘:’. </p>
<p>If you push the “Get fill all region” button, the Fill address range will be filled in with the </p>
<p>smallest and largest address of the currently loaded hey data to create a single region file. </p>
<p>With  the  button  “Get  Geny  block  config”  you  can  read  the  .gny  file  from  geny.  Hexview </p>
<p>then tries to load the Flash block configuration for the address ranges. That can be used to </p>
<p>create a test file that fills all known flash blocks for a download. </p>
<h1 style="page-break-before:always; "></h1>
<p>Reference Manual HexView </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 1.12.02 </p>
<p>46 </p>
<p>based on template version 5.1.0 </p>
<p>You </p>
<p>may </p>
<p>have </p>
<p>to </p>
<p>generate </p>
<p>a </p>
<p>Document </p>
<p>from </p>
<p>the </p>
<p>GENy-component </p>
<p>“GenTool_GenyPluginConfigDocumentor”.  Make  sure  you  have  selected  the  checkbox </p>
<p>(Ignore Default Values). </p>
<p> </p>
<p> </p>
<p>Figure 2-24 </p>
<p>Dialog that allows to fill data </p>
<p><b>2.2.2.6 </b></p>
<p><b>Create Checksum </b></p>
<p>There are two different methods to allow to operate on the data set of the loaded file info:  </p>
<p><b></b></p>
<p><b> </b></p>
<p>data processing </p>
<p><b></b></p>
<p><b> </b></p>
<p>checksum calculation.  </p>
<p>Data processing operates directly on the data set and change it. The checksum calculation </p>
<p>operates on the data without changing them. The resulting value can be added to the data </p>
<p>set. </p>
<p>The dialog above shows the method to operate on the data. The <b> checksum range </b>can </p>
<p>limit the data section where the checksum calculation operates on. Please note, that you </p>
<p>can specify only one range. If several ranges are specified using the colon separator, only </p>
<p>the first one will be used to limit the data area. </p>
<h1 style="page-break-before:always; "></h1>
<p>Reference Manual HexView </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 1.12.02 </p>
<p>47 </p>
<p>based on template version 5.1.0 </p>
<p> </p>
<p>Figure 2-25 </p>
<p>Dialog to operate the checksum calculation </p>
<p>The checksum type depends on the capability of the underlying checksum DLL. For the </p>
<p>interfaces, </p>
<p>refer </p>
<p>to </p>
<p>section </p>
<p>4.1. </p>
<p>Also, </p>
<p>section </p>
<p>“Checksum </p>
<p>calculation </p>
<p>method </p>
<p>(/CS[R]x[:target[;!Forced-range[#fill  pattern]][;limited_range][/no_range])”  provides  further </p>
<p>details on checksum calculation. </p>
<p>The button <b>[Calculate] </b>will run the calculation and shows the result in the field <b>checksum </b></p>
<p><b>value</b>. If <b>[Insert] </b>is selected, the checksum calculation will be performed and the result will </p>
<p>be added to the internal data blocks on the given address. </p>
<p>When the checkbox “Reverse results” is selected, the checksum will be inserted in reverse </p>
<p>order, with lowest byte first (“little endianness”). </p>
<p><b>2.2.2.7 </b></p>
<p><b>Run Data Processing </b></p>
<p>The  second  method  that  uses  the  EXPDATPROC.DLL  functions  is  the  data  processing </p>
<p>field.  As  already  mentioned  in  the  Checksum  calculation  section,  the  data  processing </p>
<p>directly operates on the internal data. Most of these operations requires a parameter for </p>
<p>this operation. Typically, the resulting data is the manipulated data. Therefore, no result of </p>
<p>the data processing can be inserted or added to the data sections. </p>
<p> </p>
<p>Figure 2-26 </p>
<p>Dialog for Data Processing </p>
<h1 style="page-break-before:always; "></h1>
<p>Reference Manual HexView </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 1.12.02 </p>
<p>48 </p>
<p>based on template version 5.1.0 </p>
<p>The </p>
<p>data </p>
<p>processing </p>
<p>allows </p>
<p>to </p>
<p>operate </p>
<p>on </p>
<p>the </p>
<p>data. </p>
<p>Typical </p>
<p>applications </p>
<p>are </p>
<p>data </p>
<p>decryption/encryption or compression/decompression. </p>
<p>The  string  value  given  in  the <b> Parameter </b> field  is  passed  to  the  routines  for  the  data </p>
<p>processing.  </p>
<p>The <b> Data  processing  range </b> can  limit  the  data  range,  where  the  data  processing  will </p>
<p>operate on. The parameter will be stored in the registry, to retrieve the information the next </p>
<p>time this option is activated. Please note, that you can specify only one range. If several </p>
<p>ranges are specified using the colon separator, only the first one will be used to limit the </p>
<p>data area. </p>
<p>See  also  section  4.2  for  further  details  on  the  DLL-interface.  Please,  read  also  section </p>
<p>“Run Data Processing interface (/DPn:param[,section,key][;outfilename])” for more details </p>
<p>on available data processing functions. </p>
<p>Some  data  processing  options  allow  to  use  a  file  that  contains  the  parameter.  You  can </p>
<p>browse for the specific file using the “Browse” button. </p>
<p>Please note that all file references within the data processing operation are relative to the </p>
<p>location of the data file that is currently loaded. So use either full path or use relative paths </p>
<p>related to the location of your input file! </p>
<p><b>2.2.2.8 </b></p>
<p><b>Signature verification </b></p>
<p>A signature that was previously generated with the data processing interface can also be </p>
<p>verified. For calculation, the data, signature and the counter key, namely the public key is </p>
<p>required. The data are the internal data of Hexview, the key parameter and the signature </p>
<p>can be referenced in the corresponding dialog parts. The values for key and signature can </p>
<p>either  be  given  directly  or  referenced  by  a  file.  The  available  verification  methods  are </p>
<p>shown in the dialog. These should be the counterparts of the previously used algorithm to </p>
<p>calculate the signature. Otherwise, the signature verification will fail. If the verification was </p>
<p>successful or not will be shown in the resulting dialog after pressing the OK button. </p>
<p> </p>
<p>Figure 2-27 </p>
<p>Running signature verification from the dialog. </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Reference Manual HexView </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 1.12.02 </p>
<p>49 </p>
<p>based on template version 5.1.0 </p>
<p><b>2.2.2.9 </b></p>
<p><b>Edit/Create OEM Container-Info </b></p>
<p>This option is currently not available. </p>
<p><b>2.2.2.10 </b></p>
<p><b>Remap S12 Phys-&gt;Lin </b></p>
<p>This  option  is  used  to  remap  all  blocks  from  physical  paged  addressing  to  the  linear </p>
<p>address mode. It is dedicated to be used with HEX-files with paged address information for </p>
<p>the  Motorola  Star12  (MC9S12  family).  The  Star12  paged  addressing  mode  uses  24-bit </p>
<p>addresses,  where  the  upper 8-bit  specifies  the  bank  address  in  the  range from 0x30  to </p>
<p>0x3F. The  lower 16-bit  address  is the  physical  bank  address  in  the  range from  0x8000-</p>
<p>0xBFFF. </p>
<p>These </p>
<p>address </p>
<p>ranges </p>
<p>are </p>
<p>shifted </p>
<p>to </p>
<p>the </p>
<p>linear </p>
<p>addresses </p>
<p>starting </p>
<p>from </p>
<p>0x0C.0000 for Bank 0x30 up to the highest address 0xF.FFFF.  </p>
<p>The non-banked addresses from 0x4000-0x7FFF and 0xC000-0xFFFF are mapped to the </p>
<p>linear address range of the corresponding pages (0x4000-0x7FFF mapped to 0x0F.8000-</p>
<p>0x0F.BFFF  [Bank  0x3E]  and  0xC000-0xFFFF  mapped  to  0x0F.C000-0x0F.FFFF  (Bank </p>
<p>0x3F]). See also chapter 3.2.28 for further explanations. </p>
<p><b>2.2.2.11 </b></p>
<p><b>Remap S12x Phys-&gt;Lin </b></p>
<p>This  option  is  used  to  remap  all  blocks  from  physical  paged  addressing  to  the  linear </p>
<p>address mode. It is dedicated to be used with HEX-files with paged address information for </p>
<p>the Motorola Star12X (MC9S12X family). The Star12X paged addressing mode uses 24-</p>
<p>bit addresses, where the upper 8-bit specifies the bank address in the range from 0xE0 to </p>
<p>0xFF. The lower 16-bit address is the physical bank address in the range from 0x8000-</p>
<p>0xBFFF. These address ranges are shifted to the linear addresses starting from 0x78.0000 </p>
<p>for Bank 0xE0 up to the highest address 0x7F.FFFF.  </p>
<p>The non-banked addresses from 0x4000-0x7FFF and 0xC000-0xFFFF are mapped to the </p>
<p>linear address range of the corresponding pages (0x4000-0x7FFF mapped to 0x7F.4000-</p>
<p>0x7F.7FFF  [Bank  0xFD]  and  0xC000-0xFFFF  mapped  to  0x7F.C000-0x7F.FFFF  (Bank </p>
<p>0xFF]). See also chapter 3.2.28 for further explanations. </p>
<p><b>2.2.2.12 </b></p>
<p><b>General Remapping </b></p>
<p>This option can be used to remap any banked address information into a linear address </p>
<p>range, e.g. for the Motorola MCS08 or NEC 78k0. </p>
<p>Detailed information about banked and linear addresses can be found in chapter 3.2.28. </p>
<h1 style="page-break-before:always; "></h1>
<p>Reference Manual HexView </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 1.12.02 </p>
<p>50 </p>
<p>based on template version 5.1.0 </p>
<p> </p>
<p>Figure 2-28: Configuration window for general remapping </p>
<p><b>2.2.2.13 </b></p>
<p><b>Generate file validation structure </b></p>
<p>This  menu  item  provides  a  powerful  way  to  generate  a  validation  structure  over  the </p>
<p>complete download data. The purpose is to generate a list of target address and  length </p>
<p>information that can be located at a specific address within the flash memory. The target </p>
<p>location  can  be used to  verify  the  complete  that all  download  information  is available  in </p>
<p>your target memory. This validation information must be spared out from this range. </p>
<h1 style="page-break-before:always; "></h1>
<p>Reference Manual HexView </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 1.12.02 </p>
<p>51 </p>
<p>based on template version 5.1.0 </p>
<p> </p>
<p> </p>
<p>Figure 2-29 </p>
<p>Figure 2-30 Generate the validation structure for your target memory. </p>
<p>The following options are available: </p>
<p>•</p>
<p> </p>
<p>Target address:  </p>
<p>The fixed address where the validation structure shall be placed into the currently </p>
<p>open file. </p>
<p>•</p>
<p> </p>
<p>External C-structure   </p>
<p>A  C-file  and  header  will  be  generated  that  helps  you  to  access  all  the  individual </p>
<p>elements of the generated structure </p>
<h1 style="page-break-before:always; "></h1>
<p>Reference Manual HexView </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 1.12.02 </p>
<p>52 </p>
<p>based on template version 5.1.0 </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Example </b></p>
<p>Below is an example of the generated C and H-file: </p>
<p> </p>
<p><b>_page3a.h</b>: </p>
<p>/*************************************************************** </p>
<p>*  Filename:      D:\uti\_page3a.h </p>
<p>*  Project:       Header-File for validation structure </p>
<p>*  File created:  Tue Mar 11 19:59:54 2014 </p>
<p>****************************************************************/ </p>
<p> </p>
<p>#ifndef ___PAGE3A_H__ </p>
<p>#define ___PAGE3A_H__ </p>
<p> </p>
<p>/* Structure describing a single block info */ </p>
<p>typedef struct tVsBlockInfo { </p>
<p>  unsigned short blockAddress; </p>
<p>  unsigned short blockLength; </p>
<p>  unsigned short blockChecksum; </p>
<p>} tVsBlockInfo; </p>
<p> </p>
<p>typedef struct tValidateInfo { </p>
<p>  unsigned short tagBegin; </p>
<p>  unsigned char  blockCount; </p>
<p>  tVsBlockInfo   blockInfo[1]; </p>
<p>  unsigned long  fileChecksum; </p>
<p>  unsigned short tagEnd; </p>
<p>  unsigned short validateSum; </p>
<p>} tValidateInfo; </p>
<p> </p>
<p>/* Extern definition of the data generated structure */ </p>
<p>#define VALIDATEINFO_START_SEC_CONST_EXPORT </p>
<p>#include “memmap.h” </p>
<p> </p>
<p>extern const tValidateInfo ValidateInfo; </p>
<p> </p>
<p>#define VALIDATEINFO_STOP_SEC_CONST_EXPORT </p>
<p>#include “memmap.h” </p>
<p> </p>
<p> </p>
<p>#endif </p>
<p> </p>
<p><b>_page3a.c</b>: </p>
<p>/**************************************************************** </p>
<p>*  Filename:      D:\uti\_page3a.c </p>
<p>*  Project:       C-File for validation structure </p>
<p>*  File created:  Tue Mar 11 19:59:54 2014 </p>
<p>****************************************************************/ </p>
<p> </p>
<p>#include “_page3a.h” </p>
<p> </p>
<p>#define VALIDATEINFO_START_SEC_CONST </p>
<p>#include “memmap.h” </p>
<p> </p>
<p>const tValidateInfo ValidateInfo = { </p>
<p>  0x1234u,   /* Magic Tag begin */ </p>
<p>2 </p>
<p>/* Number of block elements */ </p>
<p>  ,0x9000u, 0xFA2u, 0xE321 </p>
<p>  ,0xA893AF42ul    /* Total file checksum*/ </p>
<p>  ,0x4321u   /* Magic Tag end */ </p>
<p>  ,0x2F0u /* 16-bit byte-sum on validation area. */}; </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Reference Manual HexView </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 1.12.02 </p>
<p>53 </p>
<p>based on template version 5.1.0 </p>
<p>#define VALIDATEINFO_STOP_SEC_CONST </p>
<p>#include “memmap.h”</p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p>•</p>
<p> </p>
<p>Word type:   </p>
<p>This  specifies  the  endianness  for  16-  and  32-bit  fields  of  the  generated  data </p>
<p>structure. </p>
<p>•</p>
<p> </p>
<p>Force 32-bit variables   </p>
<p>If  not  checked,  Hexview  will  use  either  16-bit  or  32-bit  values,  depending  on  the </p>
<p>length of the largest address in the hex file. When checked, the address and length </p>
<p>values of the validation table will always use 32-bit types. </p>
<p>•</p>
<p> </p>
<p>ID tag begin:  </p>
<p>Will  be  placed  at  the  beginning  of  the  address/length  list.  This  can  be  used  to </p>
<p>uniquely identify if the address/length field is actually present there. </p>
<p>•</p>
<p> </p>
<p>Data source:.  </p>
<p>For sure, the internal data of Hexview will be used. A limited range of the data can </p>
<p>be  specified.  In  addition,  a  range  can  be  specified  if  an  address  range  shall  be </p>
<p>spared  out.  It  could  be  useful  to  add  also  address/length  information  from  other </p>
<p>files.  These  files  can  be  specified  In  the  file  list  as  well.  Hexview  will  scan  the </p>
<p>address/length information and will add it to the list, and also calculate its checksum </p>
<p>if soecified. </p>
<p>•</p>
<p> </p>
<p>Block Checksum: </p>
<p>If </p>
<p>checked, </p>
<p>Hexview </p>
<p>will </p>
<p>calculate </p>
<p>and </p>
<p>add </p>
<p>the </p>
<p>specified </p>
<p>checksum </p>
<p>to </p>
<p>each </p>
<p>address/length field. </p>
<p>•</p>
<p> </p>
<p>Total checksum:   </p>
<p>if checked, a checksum/CRC will be calculated over the complete set of data. This </p>
<p>checksum can be calculated in addition or instead to the block checksum values. </p>
<p>•</p>
<p> </p>
<p>ID tag end:  </p>
<p>Here you can specify a magic number that indicates the end of the list. It can be </p>
<p>used to verify if the complete validation list is present. </p>
<p>•</p>
<p> </p>
<p>16-bit byte checksum:   </p>
<p>This is a checksum that is generated over the complete validation array. It can be </p>
<p>used in addition to check if the complete validation structure is present. </p>
<p>When generating the data, all parameters will be written to the INI-file. This INI-file can be </p>
<p>used for the commandline option. </p>
<p> </p>
<p><b>2.2.2.14 </b></p>
<p><b>Run Postbuild </b></p>
<p>This option  allows  to  scan for postbuild files. Typically,  a  postbuild file  contains  address </p>
<p>and  length  information  as  well  as  data  information  which  shall  be  used  to  overwrite  the </p>
<p>current  contents  within  a  hexfile.  With  Hexview  V1.6  and  higher  it  is  even  possible  to </p>
<p>create segment blocks based on the information in a postbuild file. </p>
<p>Note, that the postbuild option is only available if the pbuild.dll is available. After selecting </p>
<p>the item Edit -&gt; Run postbuild, you can select one or more XML files that follows the data </p>
<p>scheme for postbuild. Normally, the postbuild files will be generated by Geny. If you need </p>
<p>further information about the postbuild options, please contact Vector. </p>
<h1 style="page-break-before:always; "></h1>
<p>Reference Manual HexView </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 1.12.02 </p>
<p>54 </p>
<p>based on template version 5.1.0 </p>
<p><b>2.2.2.15 </b></p>
<p><b>Options </b></p>
<p>This option allows to change threshold parameters for Hexview. Since V1.11.00, Hexview </p>
<p>can handle large data files, even bigger than 1 GB (but definitely not more than 4.7 GB </p>
<p>since it is currently a 32-bit program). To achieve this, data blocks must be handled on the </p>
<p>file </p>
<p>system, </p>
<p>because </p>
<p>the </p>
<p>internal </p>
<p>memory </p>
<p>would </p>
<p>exhaust </p>
<p>to </p>
<p>keep </p>
<p>everything </p>
<p>there. </p>
<p>However, </p>
<p>operations  are </p>
<p>much  faster </p>
<p>when </p>
<p>the </p>
<p>data </p>
<p>blocks </p>
<p>can </p>
<p>be </p>
<p>kept </p>
<p>in </p>
<p>RAM. </p>
<p>Therefore, memory thresholds were introduced so that the user can decide when to switch </p>
<p>from  RAM  operation  to  file  operation.  This  option  is  used  to  change  the  pre-configured </p>
<p>thresholds. </p>
<p> </p>
<p>Figure 2-31 </p>
<p>Hexview configuration options to change the memory thresholds </p>
<p>Three parameters have been introduced: </p>
<p> </p>
<p><b>Option text </b></p>
<p><b>Meaning </b></p>
<p>Big hex file conversion threshold </p>
<p>This threshold value is used to change the scanning operation </p>
<p>of hex files. If a hexfile is bigger than the named threshold, </p>
<p>Hexview will scan the data on a file instead of the memory. </p>
<p>This allows to read in very large hex files. </p>
<p>Buffer to file size threshold </p>
<p>If a block segment exceeds this threshold size, its data will not </p>
<p>kept in memory but stored in a temporary file.  </p>
<p>Temporary buffer size </p>
<p>Many operations in Hexview must be done in internal memory. </p>
<p>If a block segment is stored in a temporary file, Hexview needs </p>
<p>to read portions of the file into internal memory to process </p>
<p>them. This buffer size specifies the largest buffer Hexview can </p>
<p>allocate to perform data operations.  </p>
<p>Table 2-4: </p>
<p>Description of Hexview options. </p>
<p>The dialog above shows the default values of Hexview. See also sections 3.2.6, 3.2.7 and </p>
<p>3.2.8 for further explanations. </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Reference Manual HexView </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 1.12.02 </p>
<p>55 </p>
<p>based on template version 5.1.0 </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>Modifications will be stored permanently on your machine. </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>If you change the values, they will be stored in the windows registry of the </b></p>
<p><b>current user on this machine. You cannot port them to other machines. In other </b></p>
<p><b>words, if you run Hexview on another machine or as another user, you will see </b></p>
<p><b>here the default values again. </b></p>
<p> </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>Parameters can be given by commandline for temporary usage. </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>The three parameters can also be entered by commandline with /BHFCT=xx, </b></p>
<p><b>/BTFST=xxx and /BTBS=xxx. See the corresponding section for commandline </b></p>
<p><b>description. </b></p>
<p> </p>
<p> </p>
<p> </p>
<p><b>2.2.3 </b></p>
<p><b>View </b></p>
<p>This menu item provides some features to control the view. </p>
<p><b>2.2.3.1 </b></p>
<p><b>Goto address… </b></p>
<p>This item allows to jump to a specific address within the view. </p>
<p> </p>
<p>Figure 2-32: Jump to a specific address in the display window </p>
<p>If the address is valid, the slider will be moved to the beginning of the address. Thus, the </p>
<p>address information will be shown on the top of the display. The line is not highlighted. </p>
<p>A way to jump to the beginning of an address block can be done by jump to the beginning </p>
<p>of the file (press POS1 or Ctrl-Pageup button) </p>
<p><b>2.2.3.2 </b></p>
<p><b>Find record </b></p>
<p>This option allows to search for a pattern within the file. </p>
<h1 style="page-break-before:always; "></h1>
<p>Reference Manual HexView </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 1.12.02 </p>
<p>56 </p>
<p>based on template version 5.1.0 </p>
<p> </p>
<p>Figure 2-33: Find a string or pattern within the document </p>
<p>The format of the pattern can be selected on the right side of the window. By default, the </p>
<p>data pattern is given as a hexadecimal data byte stream. The search algorithm searches </p>
<p>from the beginning until the presence of this pattern is found. HexView tries to display the </p>
<p>value on the top of the screen. If a pattern has been found, the search can be repeated </p>
<p>from the last position where the pattern has been found. </p>
<p>If the “Find-string format” is changed to “ASCII-string”, the pattern entered in “Find what” </p>
<p>will be treated as an ASCII pattern and will search for the ASCII values. </p>
<p><b>2.2.3.3 </b></p>
<p><b>Repeat last find </b></p>
<p>This option is only present after a successful search operation. This item will continue the </p>
<p>search given from “View -&gt; Find record”. </p>
<p><b>2.2.3.4 </b></p>
<p><b>View OEM container info </b></p>
<p>This option was implemented to present some OEM-specific information available in the </p>
<p>file. However, at the moment only the GM header information will be shown. </p>
<p>This may be extended in the future. </p>
<p><b>2.2.4 </b></p>
<p><b>Flash Programming </b></p>
<p>This menu item is directly related to the flash process. </p>
<p><b>2.2.4.1 </b></p>
<p><b>Scan CANoe trace log </b></p>
<p>This menu allows you to backtrace a download of CAN data. You need an ASCII-based log </p>
<p>file from CANoe. </p>
<h1 style="page-break-before:always; "></h1>
<p>Reference Manual HexView </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 1.12.02 </p>
<p>57 </p>
<p>based on template version 5.1.0 </p>
<p> </p>
<p>Figure 2-34:  Dialog to run a CANoe trace </p>
<p>You  need  to  go  through  the  menu  step-by-step.  First,  you  need  browse  for  the  CANoe </p>
<p>trace file, which normally has the file extension “.ASC”. Then, select the channel. Hexview </p>
<p>will  show  the  available  channel  numbers  in  the  list  box.  Then  select  the  functional  and </p>
<p>physical CAN identifier. Also here, Hexview will show you all available CAN IDs found in </p>
<p>the trace file. </p>
<p>Not only UDS downloads are supported, but also KWP2000 and GMLAN. Pre-select the </p>
<p>desired option before running the scan. </p>
<p>Select  the  checkbox  “Scan  Data”  if  the  resulting  data  information  shall  be  scanned  and </p>
<p>placed into the memory buffer. Now you can run the trace by clicking on the “Run Trace” </p>
<p>button. An output window like shown above can be seen. Depending on the “log verbosity </p>
<p>level”,  more  or  less  information  per  trace  can  be  seen.  The  internal  Transport  layer </p>
<p>analyser  will  analyse  the  timing  of  each  service  and  indicated  in  the  list  box.  The </p>
<h1 style="page-break-before:always; "></h1>
<p>Reference Manual HexView </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 1.12.02 </p>
<p>58 </p>
<p>based on template version 5.1.0 </p>
<p>information can be stored into a CSV file through the “Save log” button, to further process </p>
<p>this with a spreadsheet. </p>
<p>After finishing the trace you can exit through the “Exit” button. But if you have selected the </p>
<p>“Scan data” checkbox and the trace ran successfully, you can also leave using the “Exit </p>
<p>and insert scan” button. Then, all scanned data will be placed into the memory buffer with </p>
<p>the  specified  addresses,  length  and  data  found  in  the  RequestDownload/TransferData </p>
<p>services. </p>
<p><b>2.2.4.2 </b></p>
<p><b>Build ID based EEP download file. </b></p>
<p>This  option  is  intended  to  be  used  to  create  an  address  based  data  file  with  EEPROM </p>
<p>information. Each segment in the memory represents one entry of an EEPROM block. The </p>
<p>virtual  address  space  shall  address  a  special  driver  that  extracts  the  block  number  and </p>
<p>data from each record and writes the data to an EEPROM emulation. </p>
<p>Hexview takes the information from an XML-file with the following format: </p>
<p>&lt;?xml version=”1.0”?&gt; </p>
<p>&lt;DataFlash&gt; </p>
<p> </p>
<p>&lt;AdministrativeSection&gt; </p>
<p> </p>
<p> </p>
<p>&lt;SectionSize&gt;0x0800&lt;/SectionSize&gt; </p>
<p> </p>
<p> </p>
<p>&lt;Offset&gt;0x0000&lt;/Offset&gt; </p>
<p> </p>
<p> </p>
<p>&lt;VirtualBaseAddress&gt;0x100000&lt;/VirtualBaseAddress&gt; </p>
<p> </p>
<p> </p>
<p>&lt;IdMultiplier&gt;256&lt;/IdMultiplier&gt; </p>
<p> </p>
<p>&lt;/AdministrativeSection&gt; </p>
<p> </p>
<p>&lt;Record&gt; </p>
<p> </p>
<p> </p>
<p>&lt;ID&gt;0x80&lt;/ID&gt; </p>
<p> </p>
<p> </p>
<p>&lt;Length&gt;4&lt;/Length&gt; </p>
<p> </p>
<p> </p>
<p>&lt;Data&gt; </p>
<p> </p>
<p> </p>
<p>   0x47, 0x48, 0x49, 0x4a </p>
<p> </p>
<p> </p>
<p>&lt;/Data&gt; </p>
<p> </p>
<p>&lt;/Record&gt; </p>
<p> </p>
<p>&lt;Record&gt; </p>
<p> </p>
<p> </p>
<p>&lt;ID&gt;0x81&lt;/ID&gt; </p>
<p> </p>
<p> </p>
<p>&lt;Length&gt;8&lt;/Length&gt; </p>
<p> </p>
<p> </p>
<p>&lt;Data&gt; </p>
<p> </p>
<p> </p>
<p>   0x20, 0x30, 0x31, 0x32, </p>
<p> </p>
<p> </p>
<p>   0x40, 0x40, 0x41, 0x42 </p>
<p> </p>
<p> </p>
<p>&lt;/Data&gt; </p>
<p> </p>
<p>&lt;/Record&gt; </p>
<p>&lt;/DataFlash&gt; </p>
<p>Each record consists of its ID, length and data. The block address of a segment will be </p>
<p>created by the formula: </p>
<p> </p>
<p>&lt;VirtualBaseAddress&gt; + &lt;IdMultipler&gt; * &lt;ID&gt; </p>
<p>The above example generates the following output: </p>
<h1 style="page-break-before:always; "></h1>
<p>Reference Manual HexView </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 1.12.02 </p>
<p>59 </p>
<p>based on template version 5.1.0 </p>
<p> </p>
<p>Figure 2-35:  Example output for building ID based download files. </p>
<p>The offset and SectionSize information is not used and just present for compatibility. </p>
<p><b>2.2.4.3 </b></p>
<p><b>Scan EepM data section </b></p>
<p>The EepM is a software component from Vector to emulate EEPROM in data or program </p>
<p>flash. If EepM has written data into a flash memory, it is often difficult to re-trace the block </p>
<p>information. This option is used to provide the possibility to upload the memory contents of </p>
<p>the flash memory into a HEX file and then let Hexview trace back the block number, length </p>
<p>and information and put the results into an XML file. </p>
<p> </p>
<p>Figure 2-36: Scan EepM dialog and example </p>
<p>The above picture shows the flash memory data in the background and the dialog for scan </p>
<p>in  the  foreground.  You  need  to  specify  the  flash  segment  size  (flash  sector  size,  the </p>
<p>minimum write unit of the flash memory), but also specify the range of data and the XML </p>
<p>output file.  </p>
<p>If the scan could be executed successfully, an output fiel as shown below can be seen: </p>
<h1 style="page-break-before:always; "></h1>
<p>Reference Manual HexView </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 1.12.02 </p>
<p>60 </p>
<p>based on template version 5.1.0 </p>
<p>&lt;?xml version=”1.0”?&gt; </p>
<p>&lt;DataFlash&gt; </p>
<p>   &lt;AdministrativeSection&gt; </p>
<p>      &lt;SectionSize&gt;0x2&lt;/SectionSize&gt; </p>
<p>      &lt;Offset&gt;0x0000&lt;/Offset&gt; </p>
<p>      &lt;VirtualBaseAddress&gt;0x400&lt;/VirtualBaseAddress&gt; </p>
<p>      &lt;IdMultiplier&gt;1&lt;/IdMultiplier&gt; </p>
<p>   &lt;/AdministrativeSection&gt; </p>
<p>   &lt;Record&gt; </p>
<p>      &lt;ID&gt;12&lt;/ID&gt; </p>
<p>      &lt;Length&gt;17&lt;/Length&gt; </p>
<p>      &lt;Data&gt; </p>
<p>           0x10, 0x4D, 0x16, 0x0F,  </p>
<p> </p>
<p> </p>
<p>   0x10, 0x11, 0x02, 0x03,  </p>
<p> </p>
<p> </p>
<p>   0x04, 0x05, 0x06, 0x07,  </p>
<p> </p>
<p> </p>
<p>   0x08, 0x09, 0x0A, 0x0B,  </p>
<p> </p>
<p> </p>
<p>   0x0C </p>
<p>      &lt;/Data&gt; </p>
<p> </p>
<p>&lt;/Record&gt; </p>
<p>   &lt;Record&gt; </p>
<p>      &lt;ID&gt;13&lt;/ID&gt; </p>
<p>      &lt;Length&gt;17&lt;/Length&gt; </p>
<p>      &lt;Data&gt; </p>
<p>           0x10, 0x4E, 0x17, 0x0D,  </p>
<p> </p>
<p> </p>
<p>   0x0E, 0x0F, 0x10, 0x11,  </p>
<p> </p>
<p> </p>
<p>   0x02, 0x03, 0x04, 0x05,  </p>
<p> </p>
<p> </p>
<p>   0x06, 0x07, 0x08, 0x09,  </p>
<p> </p>
<p> </p>
<p>   0x0A </p>
<p>      &lt;/Data&gt; </p>
<p> </p>
<p>&lt;/Record&gt; </p>
<p>   &lt;Record&gt; </p>
<p>      &lt;ID&gt;11&lt;/ID&gt; </p>
<p>      &lt;Length&gt;1&lt;/Length&gt; </p>
<p>      &lt;Data&gt; </p>
<p>           0xFD </p>
<p>      &lt;/Data&gt; </p>
<p> </p>
<p>&lt;/Record&gt; </p>
<p>&lt;/DataFlash&gt; </p>
<p> </p>
<p><b>2.2.5 </b></p>
<p><b>Info operation (?) </b></p>
<p>This option contains the About information of HexView. It shows the version of the tool and </p>
<p>displays also the copyright information.  </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Reference Manual HexView </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 1.12.02 </p>
<p>61 </p>
<p>based on template version 5.1.0 </p>
<p><b>2.3 </b></p>
<p><b>Hexview return values </b></p>
<p>Hexview returns an errorcode if a failure has been detected during runtime. Such a return </p>
<p>value can be checked on commandline with the ERRORLEVEL status. The following error </p>
<p>levels are provided: </p>
<p><b>Return code </b></p>
<p><b>Description </b></p>
<p>0 </p>
<p>No errors detected during runtime. </p>
<p>1 </p>
<p>Reserved. </p>
<p>2 </p>
<p>Merge or re-map operation failed. </p>
<p>3 </p>
<p>Reserved. </p>
<p>4 </p>
<p>Error during GM file operation </p>
<p>5 </p>
<p>GM FBL XML file generation failure. </p>
<p>6 </p>
<p>Error writing a C-File </p>
<p>7 </p>
<p>Error reading Intel-Hex file. </p>
<p>8 </p>
<p>Error writing an Intel-Hex file </p>
<p>9 </p>
<p>Error occurred while filling a range of data. </p>
<p>10 </p>
<p>Error during import of binary data. </p>
<p>11 </p>
<p>Error on checksum calculation. </p>
<p>12 </p>
<p>Error on generating a VAG SGML file output. </p>
<p>13 </p>
<p>Error on export binary data. </p>
<p>14 </p>
<p>Error on data processing. </p>
<p>15 </p>
<p>Error on generating a flash kernel output file. </p>
<p>16 </p>
<p>Could not load and initialize data processing DLL (expdatproc.dll) </p>
<p>17 </p>
<p>Error on exporting a VBF file. </p>
<p>18 </p>
<p>Error on exporting a GAC file. </p>
<p>19 </p>
<p>Signature verification failed. </p>
<p>20 </p>
<p>Could not load or initialize signature verification DLL (expdatproc.dll) </p>
<p>21 </p>
<p>File open error. Specified input file could not be loaded. </p>
<p>22 </p>
<p>License file not found. </p>
<p>23 </p>
<p>Disclaimer denied. </p>
<p>24 </p>
<p>General windows open failure (could not generate windows class files) </p>
<p>25 </p>
<p>Unspecified Hexview commandline errors. </p>
<p>Table 2-5: </p>
<p>Hexview return values. </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>An error level of 0 does not mean that all operations are successfully performed. You </p>
<p>need to verify carefully the output if it matches the desired expectation!! </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Reference Manual HexView </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 1.12.02 </p>
<p>62 </p>
<p>based on template version 5.1.0 </p>
<p><b>2.4 </b></p>
<p><b>Accelerator Keys (short-cut keys) </b></p>
<p>Some of the menu items mentioned above can be entered by hotkeys or accelerator keys. </p>
<p>This can be helpful to activate functions from the keyboard without using the menu and the </p>
<p>mouse. </p>
<p>The following table provides a list of available accelerator keys: </p>
<p><b>Accelerator key </b></p>
<p><b>Description </b></p>
<p>Ctrl+A </p>
<p>Align data </p>
<p>Ctrl+B </p>
<p>Run postbuild configuration </p>
<p>Ctrl+C </p>
<p>Copy data to the internal clipboard </p>
<p>Ctrl+D </p>
<p>Data Processing </p>
<p>Ctrl+F </p>
<p>Find record </p>
<p>Ctrl+G </p>
<p>Goto address </p>
<p>Ctrl+K </p>
<p>Open checksum calculation dialog </p>
<p>Ctrl+L </p>
<p>Opens the fill data dialog </p>
<p>Ctrl+N </p>
<p>File new </p>
<p>Ctrl+O </p>
<p>Open file </p>
<p>Ctrl+P </p>
<p>Print file </p>
<p>Ctrl+S </p>
<p>Save current file </p>
<p>Ctrl+T </p>
<p>Generate validation structure information </p>
<p>Ctrl+V </p>
<p>Paste data into current document </p>
<p>Ctrl+X </p>
<p>Remove data from current document and put </p>
<p>them into the internal clipboard </p>
<p>Alt+A </p>
<p>Export as HEX-ASCII </p>
<p>Alt+B </p>
<p>Export Fiat binary </p>
<p>Alt+C </p>
<p>Export C-Array </p>
<p>Alt+E </p>
<p>Export Ford Intel-HEX format </p>
<p>Alt+F </p>
<p>Export Ford VBF format </p>
<p>Alt+G </p>
<p>Export GM file format </p>
<p>Alt+I </p>
<p>Export Intel-HEX </p>
<p>Alt+L </p>
<p>Export GM-FBL data </p>
<p>Alt+M </p>
<p>Export MIME-Data </p>
<p>Alt+N </p>
<p>Export Binary data </p>
<p>Alt+S </p>
<p>Export S-Record </p>
<p>Alt+V </p>
<p>Export VAG-Data </p>
<p>Alt+Y </p>
<p>Export splitted binary file. </p>
<p>F3 </p>
<p>Repeat last find </p>
<p>Alt+F4 </p>
<p>Exit application </p>
<p>DEL </p>
<p>Delete a range from the current document </p>
<p>Table 2-6  </p>
<p>Accelerator keys (short-cut keys)  available in Hexview </p>
<h1 style="page-break-before:always; "></h1>
<p>Reference Manual HexView </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 1.12.02 </p>
<p>63 </p>
<p>based on template version 5.1.0 </p>
<p><b>3 </b></p>
<p><b>Command line arguments description </b></p>
<p>HexView cannot only be used as a PC-program with a GUI to display information. It is also </p>
<p>possible  to  manipulate  the  data  via  command  line.  There  are  even  some  options  only </p>
<p>available through command lines. </p>
<p>The following section describes the usage of the command line. </p>
<p>The command line can be grouped roughly into two groups: general options that operates </p>
<p>generally and OEM-related command line options. The OEM command line options control </p>
<p>the generation of files in OEM specific file formats. </p>
<p><b>3.1 </b></p>
<p><b>Command line options summary </b></p>
<p>This section provides a summary of all command line options. An option must start either </p>
<p>with a <b>‘/’ </b>or a <b>‘-‘</b>. In this description, a slash is used. The switches are not case-sensitive. </p>
<p>Some  options  require  additional  parameter  information.  Some  parameters  are  followed </p>
<p>directly by the option, some others require a separator. The separator can either be the </p>
<p>equal-sign or a colon. </p>
<p> </p>
<p>Hexview infile  [options] [-o outfile] </p>
<p> </p>
<p><b>Command line option </b></p>
<p><b>Description </b></p>
<p>Infile </p>
<p>This is the input filename either in Intel-HEX or </p>
<p>Motorola S-Record format  </p>
<p>/Ad:xx </p>
<p>/Adyy </p>
<p>Align data. Xx is specified in standard-C </p>
<p>notation, e.g. 0xFF, whereas yy are only hex-</p>
<p>digits. Format is distinguished by the </p>
<p>separator ‘:’ or ‘=’. </p>
<p>/AE:zzzz </p>
<p>Specify AlignErase section size, e.g. for VBF </p>
<p>or Fiat Erase sections aligned to a multiple of </p>
<p>this value. </p>
<p>/AL </p>
<p>Align length.  </p>
<p>/Afxx </p>
<p>Specifies the fill character for /AL, /AD and /FA </p>
<p>as hexadecimal value </p>
<p>/Af:xx </p>
<p>Same as above: specifies the fill character for </p>
<p>/AL, /AD, but xx can either be specified as </p>
<p>decimal (no suffix), hex value (<b>0x</b>-suffix) or </p>
<p>binary (<b>b</b>-suffix) </p>
<p>/AR:’range’1 </p>
<p>Load a limited range of data. </p>
<p>The ‘range’ is an address range, that can be </p>
<p>specified in two ways: either with start address </p>
<p>and length, separated by a comma, or with </p>
<p>start address and end address, separated by </p>
<p>a minus-sign. </p>
<p>/BHFCT=xxx </p>
<p>Changes the threshold in kB where hex-files </p>
<p>are converted on hard disk instead of in-</p>
<h1 style="page-break-before:always; "></h1>
<p>Reference Manual HexView </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 1.12.02 </p>
<p>64 </p>
<p>based on template version 5.1.0 </p>
<p><b>Command line option </b></p>
<p><b>Description </b></p>
<p>memory. Usage for big hex files that exhaust </p>
<p>the internal memory. </p>
<p>/BTFST=xxx </p>
<p>Threshold in kB for blocks handled on files </p>
<p>instead of in-memory. Usage for big files that </p>
<p>exhaust the internal memory. This is also a </p>
<p>performance parameter. </p>
<p>/BTBS=xxx </p>
<p>Block temporary buffer size. Used for portion </p>
<p>operation when blocks are handled on files </p>
<p>instead of memory. This is a performance </p>
<p>parameter. </p>
<p>/cdspx:range[;target][:range[;target]] </p>
<p>Expand dsPIC like data from range (0x1000-</p>
<p>0x103ff/0x1000,0x400) to the target address. </p>
<p>If target is not specified, the doubled address </p>
<p>(0x2000) will be used  (see section “Copy </p>
<p>dsPIC like data”). </p>
<p>/cdsps:range[;target][:range[;target]]… </p>
<p>Same as /cdspx, but it’s the shrink operation </p>
<p>(see section “Copy dsPIC like data”) </p>
<p>/cdspg:range[:range]… </p>
<p>Clear ghost byte in the specified range. </p>
<p>/CR:’range1’:’range2’:… </p>
<p>Cut out data ranges from the loaded file </p>
<p>/CS[R]xx:target[;!forced range[#Fill-pattern]] </p>
<p>    [;limited_range]  </p>
<p>    [/exclude_range1]  </p>
<p>    [/exclude_range2]  </p>
<p>    [:target[;limited_range] </p>
<p>    [/exclude_range1] </p>
<p>    [/exclude_range2]]… </p>
<p>This option specifies the checksum calculation </p>
<p>method. If the optional location parameter is </p>
<p>added, the checksum value is written into this </p>
<p>file. The result can also be placed into the file </p>
<p>using the @ operator.  </p>
<p>Note: ‘location’ is a pre-requisit in most cases. </p>
<p> </p>
<p>If /CSR is used instead of /CS, the generated </p>
<p>checksum will be inverted (low byte first). </p>
<p>/DLS=AA or /DLS=ABC </p>
<p>This option is used in combination with the </p>
<p>/XG group option to specify the DLS code and </p>
<p>length. </p>
<p>The DLS code can be 2 or 3 characters. A ‘=’ </p>
<p>is required between the option and the </p>
<p>characters itself.  </p>
<p>Do not use this option for GM cyber security </p>
<p>files. </p>
<p>/DCID=0x8000 </p>
<p>/DCID:32238 </p>
<p>This option is used in combination with the </p>
<p>/XG group option to specify the DCID code. </p>
<p>The value can be represented in integer or </p>
<p>hexadecimal. In the latter case, a ‘0x’ must </p>
<p>preceed the value. The value is treaded as a </p>
<p>16-bit value and will be added to the header </p>
<p>when creating the GM-header. </p>
<p>Do not use this option for GM cyber security </p>
<p>files. </p>
<p>/DIFF=new-file </p>
<p>Build the delta between the internal and the </p>
<p>new-file. Only possible when the diff-dll is </p>
<h1 style="page-break-before:always; "></h1>
<p>Reference Manual HexView </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 1.12.02 </p>
<p>65 </p>
<p>based on template version 5.1.0 </p>
<p><b>Command line option </b></p>
<p><b>Description </b></p>
<p>available. </p>
<p>/DPn:param </p>
<p>Run the data processing interface from </p>
<p>expdatproc.dll. The value ‘n’ specifies the </p>
<p>method, ‘param’ is used as the string </p>
<p>parameter to the DoDataProcessing function </p>
<p>(see section 3.2.11 for parameter details). </p>
<p>/E=errorfile </p>
<p>/e:errorfile </p>
<p>This specifies an error log file. HexView can </p>
<p>run in silent mode. In that case, no error will </p>
<p>be displayed to the GUI. However, error </p>
<p>messages are also suppressed. This option </p>
<p>allows an error report to the file in the silent </p>
<p>mode. </p>
<p>/expdat:&lt;path-to-expdatproc.dll&gt; </p>
<p>/expdat=&lt;path-to-expdatproc.dll&gt; </p>
<p>Specify an alternative path to expdatproc.dll, </p>
<p>e.g. if you want to use your own DLL. </p>
<p>Note: The standard expdatproc.dll functions </p>
<p>are then not usable in this session. </p>
<p>/FA </p>
<p>Create a single region file (fill all) </p>
<p>/FR:’range1’:’range2’:… 1 </p>
<p>Fill regions. </p>
<p>/FP:11223344 </p>
<p>Fill pattern in hex. Used by the /FR parameter </p>
<p>/G </p>
<p>Suppress the disclaimer. Be aware, that you </p>
<p>are suppressing the disclaimer. <b>This option </b></p>
<p><b>shall only be used in test environments </b></p>
<p><b>and not for production data generation!!</b> </p>
<p>/gmad:len </p>
<p>Specify the alignment value for the GM </p>
<p>header. This command line option is optional if </p>
<p>only length alignment is needed (can be </p>
<p>specified with /gmal only). </p>
<p>Note: by default, the /AD parameter will be </p>
<p>used instead if this option is not provided.  </p>
<p>/gmal[:len] </p>
<p>Length alignment for GM header. The length </p>
<p>parameter is optional. </p>
<p>Note: by default, the /AL parameter will be </p>
<p>used instead if this option is not provided. </p>
<p>/II2=filename.hex </p>
<p>Special import for 16-bit addressed Intel-HEX </p>
<p>files </p>
<p>/IA=filename[;startAddress] </p>
<p>Read Hex data from a file. Startaddress </p>
<p>specifies the address of the block.Cannot be </p>
<p>combined with infile. </p>
<p>/IN=filename[;startAddress] </p>
<p>Explicit read of a binary file, no file </p>
<p>interpretation. Cannot be combined with infile. </p>
<p>/L:logfile.log </p>
<p>Load and execute a commandfile </p>
<p>/M:path-to-licensefile </p>
<p>Specify a path to the license.liz file (if not </p>
<p>specified, hexview looks in its own folder). </p>
<p>/MPFH[=cal1.hex+cal2.hex+…] </p>
<p>Special option for /XG. Sets the MPFH flag </p>
<p>and optionally adds the address, length and </p>
<p>DCID-info to the GM-header. </p>
<h1 style="page-break-before:always; "></h1>
<p>Reference Manual HexView </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 1.12.02 </p>
<p>66 </p>
<p>based on template version 5.1.0 </p>
<p><b>Command line option </b></p>
<p><b>Description </b></p>
<p>/MPFH must be specified if an existing NOAM-</p>
<p>field shall be re-positioned adjacent to the new </p>
<p>NOAR-field. </p>
<p>Do not use this option for GM cyber security </p>
<p>files. </p>
<p>/MODID:value </p>
<p>Special option for GM-header creation. Sets </p>
<p>the Module-ID for this header. </p>
<p>Do not use this option for GM cyber security </p>
<p>files. </p>
<p>/MO:file1[;offset] </p>
<p> </p>
<p>[+file2][;offset] </p>
<p>Merges the file(s) from the filelist into the </p>
<p>memory in Opaque mode (existing data will be </p>
<p>overwritten). The optional offset may be added </p>
<p>to all addresses of the file that is merged. </p>
<p>File names can have wildcards such as ? or *. </p>
<p>/MT:file1 </p>
<p> </p>
<p>[;offset][:range1] </p>
<p> </p>
<p>[+file2][;offset][:range1] </p>
<p>Merges the file(s) or portions of it from the </p>
<p>filelist into the memory in transparent mode </p>
<p>(existing data not overwritten). The optional </p>
<p>offset will be applied to all addresses of the file </p>
<p>that is merged. The range limits the  before </p>
<p>the offset  </p>
<p>File names can have wildcards such as ? or *. </p>
<p>/MVBF:Merged.vbf </p>
<p>Merges a VBF file to the currently loaded VBF </p>
<p>-o outfilename </p>
<p>Specifies the output filename. The filename </p>
<p>must follow directly the –o option separated </p>
<p>with a blank character. </p>
<p>/P:ini-file </p>
<p>Specifies the path and file for the INI-</p>
<p>information partly used by some conversion </p>
<p>routines. </p>
<p>/PB:”PostbuildXML-file1”;”XML-File2”;… </p>
<p>Applies Postbuild operation to the specified </p>
<p>file. </p>
<p>/PN </p>
<p>Add part number to the GM-header. This </p>
<p>option is only useful in combination with /XGC </p>
<p>or /XGCC. The part number must not be </p>
<p>specified and will be taken from the SWMI </p>
<p>value. </p>
<p>Do not use this option for GM cyber security </p>
<p>files. </p>
<p>/remap:BankStartAddress-</p>
<p>BankEndAddress,LinearBaseAddress,BankSize,</p>
<p>BankIncrement </p>
<p> </p>
<p>This option was intended to be used for </p>
<p>controllers using a memory banked </p>
<p>addressing scheme. The option calculates </p>
<p>from physical banked addressing to a linear </p>
<p>addressing scheme. </p>
<p>One of the most popular controllers using </p>
<p>banked method, the Star12 and Star12x, is </p>
<p>directly supported with the special option </p>
<p>/s12map resp. /s12xmap (see below). </p>
<p>/swmi:value </p>
<p>Specifies the SWMI parameter when creating </p>
<h1 style="page-break-before:always; "></h1>
<p>Reference Manual HexView </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 1.12.02 </p>
<p>67 </p>
<p>based on template version 5.1.0 </p>
<p><b>Command line option </b></p>
<p><b>Description </b></p>
<p>the GM-header </p>
<p>Do not use this option for GM cyber security </p>
<p>files. </p>
<p>/s </p>
<p>Run HexView in silent mode. </p>
<p>/s08map </p>
<p>Re-maps the physical address spaces of the </p>
<p>Freescale Star08 to its linear address spaces, </p>
<p>e.g. maps segments in the range of 0x4000-</p>
<p>0x7FFF to 0x104.000 or from 0x02.8000-</p>
<p>0x02.BFFF to 0x10.8000-0x10.BFFF and so </p>
<p>on. </p>
<p>/s12map </p>
<p>Re-maps the physical address space to the </p>
<p>linear address space of the Freescale Star12 </p>
<p>to its linear address spaces, e.g. maps </p>
<p>segments in the range of 0x4000-0x7FFF to </p>
<p>0xF8000 or from 0x308000-0x30BFFF to </p>
<p>0xC0000-0xC3FFF and so on. </p>
<p>/s12xmap </p>
<p>Re-maps the physical address space to the </p>
<p>linear address space of the Freescale Star12x </p>
<p>to its linear address spaces, e.g. maps </p>
<p>segments in the range of 0x4000-0x7FFF to </p>
<p>0x7F4000-0x7F7FFF or from 0xE08000-</p>
<p>0xE0BFFF to 0x780000-0x783FFF and so on. </p>
<p>/sb:maxblocksize </p>
<p>Splits a block into pieces if the size exceeds </p>
<p>maxblocksize. </p>
<p>/sigkeyid=xxxx </p>
<p>Overwrites the default signature key ID for GM </p>
<p>files. </p>
<p>/sigver=xxxx </p>
<p>Provides the signature version for GM files. </p>
<p>/SVn:keyinfo!signatureinfo </p>
<p>Run signature verification from commandline. </p>
<p>The value ‘n’ stands for the method of the </p>
<p>signature calculation algorithm provided by </p>
<p>expdatproc.dll, keyinfo is the corresponding </p>
<p>public key or certificate and signatureinfo is </p>
<p>the ignature or the filename of the signature. </p>
<p>/swapword </p>
<p>Swaps the byte on an even address with its </p>
<p>successor. AA BB becomes BB AA. </p>
<p>/swaplong </p>
<p>Swaps 4 bytes on longword addresses. AA BB </p>
<p>CC DD becomes DD CC BB AA </p>
<p>/tms570-parity </p>
<p>Generates the parity data for the TMS570 </p>
<p>flash file </p>
<p>/tms570-ECC </p>
<p>Generates the ECC data for the TMS570 flash </p>
<p>file. </p>
<p>/v </p>
<p>Writes the Hexview version string into the </p>
<p>error log file (see /L). </p>
<p>/vs </p>
<p>Create validation structure. All necessary </p>
<p>information are provided through an INI-file. </p>
<p>See section 3.2.29 for further details. </p>
<h1 style="page-break-before:always; "></h1>
<p>Reference Manual HexView </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 1.12.02 </p>
<p>68 </p>
<p>based on template version 5.1.0 </p>
<p><b>Command line option </b></p>
<p><b>Description </b></p>
<p>/XA[:Linelen[:ExportSeparator]] </p>
<p>Exports the data as HEX ASCII data. Use </p>
<p>doublequotes if separator shall contain </p>
<p>spaces. </p>
<p>Since 1.10.01 the linelen can also be entered </p>
<p>in HEX. Long values are also accepted. To </p>
<p>use single line outputs, a very long linelen can </p>
<p>be used, e.g. 0xffffffff. </p>
<p>/XB </p>
<p>Outputs the data in the Fiat binary format </p>
<p>including the PRM- and BIN-file . </p>
<p>/XC </p>
<p>Outputs the data into a C-like array. All </p>
<p>configuration options are provided through an </p>
<p>INI-file. </p>
<p>/XF </p>
<p>Exports data in the Ford-HEX specific file </p>
<p>format. Adds the Ford header information  and </p>
<p>data in an Intel-HEX like file format. </p>
<p>/XGAC </p>
<p>Exports data into a GAC binary file format. </p>
<p>The data information will be taken from an INI-</p>
<p>file. Address and length information will be </p>
<p>added accordingly. </p>
<p>/XGACSWIL </p>
<p>Like the /XGAC export option, but the </p>
<p>address/length information will not be added. </p>
<p>Typical use-case for the SWIL (software </p>
<p>interlock). </p>
<p>/XG[:header-address] </p>
<p>Completes the information in an existing GM-</p>
<p>header </p>
<p>/XGC[:header-address] </p>
<p>Generates the GM-file header and completes </p>
<p>the information. </p>
<p>/XGCC[:header-address] </p>
<p>Generates the header information for a single-</p>
<p>region calibration file. </p>
<p>/XGCS </p>
<p>Generates the header, but with a 1-byte HFI </p>
<p>information (backward compatibility with </p>
<p>previous “SAAB”-specific header). </p>
<p>/XGC_APP_PLAIN </p>
<p>/XGC_APP_SIGN </p>
<p>/XGC_CAL_PLAIN </p>
<p>/XGC_CAL_SIGN </p>
<p>/XGC_SIGN_CMPR[:DataType[:DictCoding]] </p>
<p>Generate the GM file header applicable for </p>
<p>GM Cyber security. </p>
<p>/XML:xml-file </p>
<p>Specifies an XML file used for some additional </p>
<p>command options (mainly for the new GM </p>
<p>header generation) </p>
<p>/XGMFBL </p>
<p>Exports the GM-FBL XML-data file </p>
<p>/XI[:reclinelen[:rectype]] </p>
<p>Exports in Intel-HEX format </p>
<p>/XK </p>
<p>Outputs the data into an FKL-file for CCP/XCP </p>
<p>kernel </p>
<p>/XN </p>
<p>Exports data into the binary file format </p>
<h1 style="page-break-before:always; "></h1>
<p>Reference Manual HexView </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 1.12.02 </p>
<p>69 </p>
<p>based on template version 5.1.0 </p>
<p><b>Command line option </b></p>
<p><b>Description </b></p>
<p>/XP </p>
<p>Exports data into a single region binary file </p>
<p>and appends a checksum. Typically used by a </p>
<p>Porsche download (KWP2000). </p>
<p>/XS[:reclinelen[:rectype]] </p>
<p>Exports in Motorola S-Record format </p>
<p>/XSB </p>
<p>Export each section of a hex file into a binary </p>
<p>file. The start address of the block is used as a </p>
<p>postfix for the binary name. </p>
<p>/XV </p>
<p>Outputs the VAG-compatible SGML file </p>
<p>format. </p>
<p>/XVBF </p>
<p>Generates the Ford-specific VBF file format. </p>
<p>All parameters are specified through an INI-</p>
<p>file. </p>
<p>/XVBFSUBST=<i>&lt;&lt;NewFileData&gt;&gt;[;DFI=xx] </i></p>
<p>Allows to substitute the binary data section of </p>
<p>a VBF with that contained in </p>
<p><i>&lt;&lt;NewFileData&gt;&gt; </i></p>
<p>and optionally the DFI </p>
<p>Table 3-1  </p>
<p>Command line options summary </p>
<p>1 </p>
<p>A range defines a section area. It can be entered in two ways, either with start address </p>
<p>and length separated by comma or with start address and end address separated with ‘-‘. </p>
<p>Examples are: “0x1000,0x200” (range) or “0x1000-0x11FF” (start and end address). Both </p>
<p>parameters  span  the  same  range  and  will  be  treated  the  same  way.  Note  that  the  end </p>
<p>address must be higher than the start address. Values are accepted as binaries, integer or </p>
<p>hex with C-like pre- or postfixes. </p>
<h1 style="page-break-before:always; "></h1>
<p>Reference Manual HexView </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 1.12.02 </p>
<p>70 </p>
<p>based on template version 5.1.0 </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>Parameter /Xx cannot be combined. /Xx can be specified only once in the parameter </p>
<p>list. </p>
<p>/Mt and /MO cannot be combined as well. </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>3.2 </b></p>
<p><b>General command line operation order </b></p>
<p> </p>
<p>Figure 3-1 </p>
<p>Order of commandline operations within Hexview. </p>
<h1 style="page-break-before:always; "></h1>
<p>Reference Manual HexView </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 1.12.02 </p>
<p>71 </p>
<p>based on template version 5.1.0 </p>
<p>The  commandlines  can  be  specified  in  any  order.  Hexview  will  first  summarize  the </p>
<p>commandline  operations  and  will  then  execute  them.  Since  some  operations  may  have </p>
<p>influences to subsequent operations, the commandline operation sequence within hexview </p>
<p>is important to know. The following commandline sequence will be applied (if specified): </p>
<p>This  section  describes  command  line  options  of  HexView,  that  can  be  used  in  general. </p>
<p>There is no restriction or limitation in the combination of the options (as long as they are </p>
<p>useful). </p>
<p><b>3.2.1 </b></p>
<p><b>Align Data (/ADxx or /AD:yy) </b></p>
<p>The start address of each block will be aligned to multiples of the given parameter xx. If </p>
<p>the separator ‘:’ or ‘=’ is omitted, the parameter xx is a hexadecimal value. If the separator </p>
<p>is used, the value xx is interpreted in C-style, e.g. /AD:0xFF is the same as /AD:255 or </p>
<p>/AD:11111111b. This value can only be an unsigned char value. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Example </b></p>
<p><b>/AD2   </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p>Aligns address to be a multiple of 2.   </p>
<p>If a block starts at 0xFE01 a fill byte will be inserted at 0xFE00. The inserted character </p>
<p>will be 0xFF by default. The default character can be overwritten with the /AF </p>
<p>parameter.    </p>
<p>An address starting at 0xE000 will be left unchanged. No characters are inserted. </p>
<p> </p>
<p><b>/AD:0x80     </b></p>
<p>Align the addresses of all sections to a multiple of 128   </p>
<p>If an address starts at e.g. 0xE730, the address will be aligned to 0xE700. </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>3.2.2 </b></p>
<p><b>Align length (/AL[:length]) </b></p>
<p>This option is useful in combination with the /AD parameter. It aligns also the length of all </p>
<p>blocks to be a multiple of the parameter given in the /Adxx option. The option corresponds </p>
<p>to the “Align size” option in section 2.2.2.4: “Data Alignment”. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Example </b></p>
<p><b>/AD4 /AL </b></p>
<p>A block 0xE432-0xE47E will be aligned to 0xE430-0xE47F. All characters will be filled </p>
<p>with 0xFF or the value specified by /Afxx. </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>3.2.3 </b></p>
<p><b>Specify erase alignment value (/AE:xxx) </b></p>
<p>This parameter specifies the erase alignment parameter. This value is used to align data </p>
<p>blocks that specifies erase blocks for certain output file formats for Ford and Fiat. </p>
<h1 style="page-break-before:always; "></h1>
<p>Reference Manual HexView </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 1.12.02 </p>
<p>72 </p>
<p>based on template version 5.1.0 </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Example </b></p>
<p><b>/AE:0x200   </b></p>
<p> </p>
<p>Erase blocks are always aligned to multiples of 0x200 </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>3.2.4 </b></p>
<p><b>Specify fill character (/AF:xx, /AFxx) </b></p>
<p>This option specifies the fill character used for the align options (/AL, /AD or /FA). If the fill </p>
<p>parameter is located directly after the option, it is treaded as a hex-string. If the parameter </p>
<p>is  separated  by  a  colon,  the  parameter  must  use  the  C-convention  for  characters,  e.g. </p>
<p>0xCC for hexadecimal values.  </p>
<p>Important: Distinguish if a colon or equal-sign is in-between the option field or not. If the fill </p>
<p>value follows directly the /AF option, then xx is always treated as HEX value. If you put a </p>
<p>colon or equal in-between,  it  can  be  either dec,  hex  or binary  like  “128</p>
<p>dec</p>
<p>”,  “0xAA</p>
<p>hex</p>
<p>” or </p>
<p>“b01001100</p>
<p>bin</p>
<p>”. Thus, /AFdd is the same as /AF:0xdd or /AF:221,. </p>
<p>This option corresponds to the “Fill character” in section 2.2.2.4: “Data Alignment”. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Example </b></p>
<p><b>/AF:0xEF  </b></p>
<p> </p>
<p>Fill character is 0xEF </p>
<p><b>/AFCD   </b></p>
<p><b> </b></p>
<p>Fill character is 0xCD </p>
<p><b> </b></p>
<p><b>3.2.5 </b></p>
<p><b>Address range reduction (/AR:’range’) </b></p>
<p>This option can limit the range of data to be loaded into the memory. This is useful if only a </p>
<p>reduced range of data shall be processed within HexView.  </p>
<p>An address range is specified by its block start address and its length. Address and length </p>
<p>are  separated  by  a  comma.  You  can  also  specify  the    range  with  the  start  and  end </p>
<p>address. Then, the two values must be separated by ‘-‘. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Example </b></p>
<p><b>/AR:0x1000,0x200 </b></p>
<p>Only the data between 0x1000 and 0x11FF are loaded to the memory and then further </p>
<p>processed. </p>
<p><b>/AR:0x7000-0x7FFF </b></p>
<p>This loads the data from 0x7000 to 0x7FFF </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>3.2.6 </b></p>
<p><b>Big hex-file conversion threshold (/BHFCT=xxx) </b></p>
<p>Since Hexview V1.11 it is possible to handle large hex files, even larger than the internal </p>
<p>memory  of  the  computer  hexview  is  running  on.  To  accomplish  this,  the  data  must  be </p>
<p>stored  temporarily  on  the  hard  disc.  As  a  disadvantage,  operations  are  getting  much </p>
<p>slower. A trade-off value when to handle data in internal memory or on hard disc mainly </p>
<h1 style="page-break-before:always; "></h1>
<p>Reference Manual HexView </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 1.12.02 </p>
<p>73 </p>
<p>based on template version 5.1.0 </p>
<p>depends on the computer itself. Therefore, threshold parameters have been introduced to </p>
<p>increase performance on powerful computers.  </p>
<p>The BHFCT parameter specifies the total file size of a hex file. If the file is bigger than this </p>
<p>threshold, Hexview will extract the data by putting the contents directly to a temporary file </p>
<p>on hard disc (the temporary file will be located in the %TEMP% folder). If the extracted </p>
<p>data further processed on hard disc or memory depends on the size of each section block. </p>
<p>The value is specified in kB. The default is 64MB (65536kB; /BHFCT=65536). See also </p>
<p>section 2.2.2.15. </p>
<p><b>3.2.7 </b></p>
<p><b>Buffer to file threshold (/BTFST=xxx) </b></p>
<p>A file  handled  by  hexview  consists  of  one or more  regions  or blocks.  Hexview  operates </p>
<p>these  blocks  in  a  list.  Typically,  after  loading  a  file,  the  data  of  the  blocks  are  stored </p>
<p>temporarily  in  internal  memory.  However,  if  one  block  exceeds  the  limit  its  data  will  be </p>
<p>stored  on  hard  disc. The  threshold,  when  to  put  data  to  hard  disc  is  specified  with  this </p>
<p>parameter. Thus, smaller blocks can still be handled in memory, whereas bigger ones are </p>
<p>stored on hard disc. </p>
<p>The </p>
<p>value </p>
<p>is </p>
<p>specified </p>
<p>in </p>
<p>kB. </p>
<p>The </p>
<p>default </p>
<p>is </p>
<p>16MB </p>
<p>(16384kB; </p>
<p>/BTFST=16384 </p>
<p>or </p>
<p>/BTFST=0x4000). See also section 2.2.2.15. </p>
<p><b>3.2.8 </b></p>
<p><b>Temporary buffer size (/BTBS=xxx) </b></p>
<p>This parameter is used when operating on large blocks stored on hard disc. The operation </p>
<p>is  done  on  portions  in  a  streaming  operation,  e.g.  for  signature  calculation  parts  of  the </p>
<p>block  data  are  read  into  the  temporary  buffer  and  then  processed. The  result  is  written </p>
<p>back and the next portion is taken from the file for the block operation until all data of a </p>
<p>block have been processed. Thus, this parameter is a performance parameter. </p>
<p>The value is specified in kB. The default is 1MB (1024kB; /BTBS=1024 or /BTBS=0x400). </p>
<p>See also section 2.2.2.15. </p>
<p><b>3.2.9 </b></p>
<p><b>Cut out data from loaded file (/CR:’range1[:’range2’:…] </b></p>
<p>The parameter option /CR is used to cut out a range from the loaded data file. It removes </p>
<p>any data within the specified ranges. More than one range can be specified. Each range </p>
<p>must be separated by a colon ‘:’. </p>
<h1 style="page-break-before:always; "></h1>
<p>Reference Manual HexView </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 1.12.02 </p>
<p>74 </p>
<p>based on template version 5.1.0 </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Example </b></p>
<p><b>/CR:0x1000,0x200 </b></p>
<p>If a data section in the range from 0x1000-0x11FF exist, the data will be removed from </p>
<p>the file. All successive operations will operate on data that don’t include this section. All </p>
<p>other sections remain unchanged. If this section is located within a segment or block, it </p>
<p>will be splitted into two. </p>
<p><b>/CR:0x7000-0x7FFF </b></p>
<p>This removes the data from 0x7000 to 0x7FFF if present. </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>3.2.10 </b></p>
<p><b>Checksum calculation method (/CS[R]x[:target[;!Forced-range[#fill </b></p>
<p><b>pattern]][;limited_range][/no_range]) </b></p>
<p>/CS respectively /CSR is used to calculate a checksum over the loaded data file. A digit </p>
<p>follows  directly  the  option  to  specify  which  checksum  calculation  method  shall  be  used. </p>
<p>The digit and its associated checksum can be depicted from table Table 3-2. It can also be </p>
<p>seen on the GUI when using the option “Edit -&gt; Create Checksum” (see Figure 3-2). The </p>
<p>digit is specified in decimal value and follows directly the commandline option without any </p>
<p>blank.  Either  /CS  or  /CSR  can  be  specified  in  the  commandline. The  difference  is,  that </p>
<p>/CSR  provides  the  result  in  reverse  order,  also  known  as  “little  endian”,  whereas  /CS </p>
<p>provides the result in “big endianess”.  </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Example </b></p>
<p> </p>
<p>Figure 3-2 </p>
<p>Example on how to select the checksum calculation methods in the Edit -&gt; “Create Checksum” operation </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p>Various  additional  parameters  can  follow.  At  first,  separated  by  a  colon  ‘:’  it  can  be </p>
<p>specified where Hexview shall place the result of the checksum calculation. This can either </p>
<p>be a file or it can be placed directly into the internal data buffer. Be careful when placing </p>
<p>the checksum into the data buffer. It will overwrite data without complain. The parameter </p>
<p>“@append” </p>
<p>is </p>
<p>the </p>
<p>default. </p>
<p>Thus, </p>
<p>if </p>
<p>no </p>
<p>target </p>
<p>parameter </p>
<p>is </p>
<p>specified, </p>
<p>Hexview </p>
<p>will </p>
<p>automatically append the checksum result to the last block. Other target addresses can be </p>
<p>specified. Please check Table 3-2 what type of specifications are possible. If placed into </p>
<h1 style="page-break-before:always; "></h1>
<p>Reference Manual HexView </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 1.12.02 </p>
<p>75 </p>
<p>based on template version 5.1.0 </p>
<p>the data file, the location of the checksum value will automatically be spared by Hexview </p>
<p>so that the checksum itself does not influence the calculation. </p>
<p>Further parameters specify ranges for the checksum calculation separated by semicolon </p>
<p>‘;’. The first optional range is a “forced range” marked with a preceding exclamation mark </p>
<p>‘!’. Hexview will calculate the checksum over this forced range as virtual data information </p>
<p>and  uses  either  the  data  that  exist  in  the  internal  memory  or,  if  no  data  exist  at  the </p>
<p>specified address, a fill value. Internally, Hexview will create a filled range over this forced </p>
<p>address range and will merge the existing data into it. Existing data always have certainly </p>
<p>higher priority than filled data. This fill operation has no effect to the internal data itself and </p>
<p>is just generated for the checksum calculation. A fill character or pattern can be specified </p>
<p>and can be added directly to the forced range separated but must be separated by a hash </p>
<p>sign ‘#’</p>
<p>1</p>
<p>. The value is given in hexadecimal value with or without preceding ‘0x’. If no fill </p>
<p>value is provided, the fill value ‘FF’ is used. Typical use case is to build a checksum over a </p>
<p>flash memory that also include the programmed and non-programmed data. The fill value </p>
<p>corresponds to the erase value of the flash. You can specify only one forced range. </p>
<p> </p>
<p>Figure 3-3: Various checksum calculation options using forced and limited ranges </p>
<p>It  is  also  possible  to  calculate  the  checksum  just  over  a  specified  range  of  the  loaded </p>
<p>memory. Only one range can be specified here. The limited_range parameter is optional. If </p>
<p>not provided the checksum will be calculated over all specified data. </p>
<p> </p>
<p>Figure 3-4: Various options for checksum calculation using excluded ranges (no range) </p>
<p>The “no_range” can be used to extract ranges from checksum calculation. It works similar </p>
<p>to the /CR option, but will extract the specified ranges only for the checksum calculation. </p>
<p>                                            </p>
<p>1</p>
<p> From V1.12.00 and upwards. In earlier versions a fill character was mandatory. </p>
<h1 style="page-break-before:always; "></h1>
<p>Reference Manual HexView </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 1.12.02 </p>
<p>76 </p>
<p>based on template version 5.1.0 </p>
<p>This can be useful if you want to explicitly exclude ranges from checksum calculation. You </p>
<p>can specify a list of excluded ranges each separated by a forward slash. The “no_range” </p>
<p>will be applied AFTER the forced range so that it can also be applied to virtual resp. non-</p>
<p>programmed address areas. </p>
<p>Note,  that  the  relative  target  address  specifier  such  as  @append,  @upfront,  etc  are </p>
<p>relative  to  the  currently  loaded  data  without  the  no_range  or force_range  address  data. </p>
<p>This was cleaned up in Hexview V1.12.00. </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Example </b></p>
<p> </p>
<p><b>/CS6:csum.txt </b></p>
<p>Runs the checksum calculation method “Wordsum LE into 16-Bit, 2’s Compl LE-Out </p>
<p>(GM new style)” and writes the results into the file CSUM.TXT. </p>
<p>This example uses the checksum method “Wordsum LE into 16-Bit, 2’s Compl LE-Out </p>
<p>(GM new style)”, as this is the 7th option in the checksum dialog menu shown above. </p>
<p> </p>
<p><b>/CS1:@append;0x1000-0x7FFF  or  /CS1:@append;0x1000,0x7000 </b></p>
<p>Runs the checksum calculation method “Bytesum into a 16-Bit LE-out” and appends </p>
<p>the checksum at the very end of the internal file. The checksum is calculated over the </p>
<p>limited range from 0x1000-0x7FFF as specified. </p>
<p>A range within the checksum range can be excluded, if for example a data array shall </p>
<p>not be used for checksum calculation, Such an excluded range can be specified with a </p>
<p>preceding ‘/’. </p>
<p><b>/CS7:@upfront;0x2000-0x3fff/0x2800-0x29ff/0x3000,0x200 </b></p>
<p>The option above calculates the checksum using method 7 (the 8th) on data within the </p>
<p>range from 0x2000-0x3ffff. The range from 0x2800-0x29ff and 0x3000-0x31ff will be </p>
<p>excluded for the checksum calculation. The exclude has no effect to the real data. The </p>
<p>result of the checksum calculation will be written before the very beginning of the file </p>
<p>data (Note: it will be written not upfront to 0x2000, but to the very beginning of the </p>
<p>loaded file. This applies to all other labelled address specifier, such as ‘upfront’, ‘begin’ </p>
<p>and ‘append’). </p>
<p><b>/CS4:@0xFFFC;!0x01000-0xFFFFF#FF </b></p>
<p>It might be useful to calculate the checksum over a range of pre-filled data that do not </p>
<p>exist in the internal data representation. A command can be given to calculate the </p>
<p>checksum also over this range. This feature is only available through the commandline </p>
<p>interface. For example, if the checksum shall be calculated over the range of 0x0.1000-</p>
<p>0xF.FFFF which is pre-filled with the pattern FF, a checksum can be calculated over the </p>
<p>existing data including the specified range. </p>
<p><b> </b></p>
<p>With  HexView  version  V1.2.0  and  higher,  the  results  of  the  checksum  can  now  also  be </p>
<p>written into an output file or placed into a location within the internal data. The location is </p>
<p>separated by a ‘:’ or ‘=’ sign, followed by the target where the resulting checksum value </p>
<p>shall be placed in. The example above shows how to write the results of the checksum </p>
<p>calculation into the file “csum.txt”. </p>
<p>The following target IDs can be used: </p>
<h1 style="page-break-before:always; "></h1>
<p>Reference Manual HexView </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 1.12.02 </p>
<p>77 </p>
<p>based on template version 5.1.0 </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p>Filename (e.g. csum.txt) </p>
<p>Writes the result into a file. The value is </p>
<p>written from high to low byte in hexadecimal </p>
<p>form. Each byte is separated by a comma. </p>
<p>@append </p>
<p>The results of the checksum will be added at </p>
<p>the very end of the file. </p>
<p>@begin </p>
<p>Writes the contents at the very beginning of </p>
<p>the file. </p>
<p><b>Important Note</b>: It will <i><b>overwrite </b></i>the first </p>
<p>bytes of your data. The number of bytes that </p>
<p>will be overwritten depends on the checksum </p>
<p>method. </p>
<p>@upfront </p>
<p>Write the checksum results prior to the </p>
<p>beginning of the first block. No data will be </p>
<p>overwritten. </p>
<p>@end </p>
<p>Places the checksum on the last bytes of the </p>
<p>last section of the file. The address is </p>
<p>automatically calculated.  </p>
<p><b>Important Note</b>: It will <i><b>overwrite </b></i>the last </p>
<p>bytes of your data. The number of bytes that </p>
<p>will be overwritten depends on the checksum </p>
<p>method. </p>
<p>@0x1234 </p>
<p>Writes the checksum result into the address </p>
<p>location given after the @ operator. </p>
<p> </p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>Whenever using the @ operator to write the results into the internal data, make sure </p>
<p>that the checksum is at the proper location and is <i><b>not overwriting accidentally any </b></i></p>
<p><i><b>imported data! </b></i></p>
<p><b> </b></p>
<p><b> </b></p>
<p>Table 3-2  </p>
<p>Checksum location operators used in the commandline </p>
<p>Since Hexview V1.10.01 the parameter /CSR can be used which accepts the parameter in </p>
<p>the same way as /CS does. The only difference is, that /CSR reverses the output to ‘little </p>
<p>endian’ instead of ‘big endian’. </p>
<p>The  available  checksum  methods  depend  on  the  expdatproc.dll.  Version  1.05.00  of  the </p>
<p>DLL provides the following methods: </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p>0 </p>
<p>ByteSum into 16-Bit, BE-out </p>
<p>Sums the bytes of all segments into a </p>
<p>16-bit value. The result is a 16-Bit </p>
<p>value in Big-Endian order (high byte </p>
<p>first). </p>
<p>1 </p>
<p>ByteSum into 16-Bit, LE-out </p>
<p>Sums the bytes of all segments into a </p>
<p>16-bit value. The result is a 16-Bit </p>
<h1 style="page-break-before:always; "></h1>
<p>Reference Manual HexView </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 1.12.02 </p>
<p>78 </p>
<p>based on template version 5.1.0 </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p>value in Little-Endian order (low-byte </p>
<p>first) </p>
<p>2 </p>
<p>Wordsum BE into 16-Bit, BE-Out </p>
<p>Sums the data of every segment as </p>
<p>16-bit words. The result is a 16-bit </p>
<p>value. </p>
<p>The input stream is treaded as big-</p>
<p>endians (high-byte first), the 16-bit </p>
<p>checksum result is given in big-</p>
<p>endian format (high-byte first). </p>
<p>Note that this routine requires aligned </p>
<p>data. The number of bytes per </p>
<p>segment and the start address of </p>
<p>each segment must be a multiple of </p>
<p>two. If not, Hexview/expdatproc will </p>
<p>generate the errors “Base address </p>
<p>mis-alignment” or “Data length mis-</p>
<p>alignment” </p>
<p>3 </p>
<p>Wordsum LE into 16-Bit, LE-Out </p>
<p>Same as above, but the data are </p>
<p>treaded as 16-bit values with low byte </p>
<p>first. The 16-bit result is also stored </p>
<p>with low-byte first </p>
<p>4 </p>
<p>ByteSum w/ 2s complement into 16-Bit BE (GM </p>
<p>old-style) </p>
<p>Each byte of the segments are </p>
<p>complemented with its 2’s </p>
<p>complement and then added to a 16-</p>
<p>bit sum value. The result is stored in </p>
<p>big-endian format (high-byte first). </p>
<p>5 </p>
<p>Wordsum BE into 16-Bit, 2's Compl BE-Out (GM </p>
<p>new style) </p>
<p>Sums the data of every segment as </p>
<p>16-bit words. The result is the 2’s </p>
<p>complement of the  16-bit sum. </p>
<p>The input stream is treaded as big-</p>
<p>endians (high-byte first), the 16-bit </p>
<p>checksum result is given in big-</p>
<p>endian format (high-byte first). </p>
<p>Note that this routine requires aligned </p>
<p>data. The number of bytes per </p>
<p>segment and the start address of </p>
<p>each segment must be a multiple of </p>
<p>two. If not, Hexview/expdatproc will </p>
<p>generate the errors “Base address </p>
<p>mis-alignment” or “Data length mis-</p>
<p>alignment” </p>
<p>6 </p>
<p>Wordsum LE into 16-Bit, 2's Compl LE-Out (GM </p>
<p>new style) </p>
<p>Same as above, but the input data is </p>
<p>managed in little-endian format. The </p>
<p>result is also given as 16-bit little-</p>
<p>endian. </p>
<p>7 </p>
<p>CRC-16 (Standard) </p>
<p>Calculation of a CRC-16 using the </p>
<p>polynomial: </p>
<p> </p>
<p>215+214+27+26+20 ($C0C1) </p>
<h1 style="page-break-before:always; "></h1>
<p>Reference Manual HexView </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 1.12.02 </p>
<p>79 </p>
<p>based on template version 5.1.0 </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p>8 </p>
<p>CRC-16 (non-standard) </p>
<p>This is a 16-bit checksum algorithm </p>
<p>that can easily implemented in a </p>
<p>microcontroller. The used algorithm is </p>
<p>as follows: </p>
<p>CS = 0xffff;   </p>
<p>// pre-initialize CS </p>
<p>Foreach 8-bit data byte do </p>
<p>Swap(CS)     // swap upper and lower </p>
<p>bytes </p>
<p>CS = CS XOR data-byte </p>
<p>CS = CS XOR  ((CS AND 0xFF) SHR </p>
<p>4) </p>
<p>CS = CS XOR  ((CS SHL 8) SHL 4) </p>
<p>CS = CS XOR (((CS AND 0xFF) SHL </p>
<p>4) SHL 1) </p>
<p>Endeach </p>
<p>CS = NOT CS   // Inverse CS after </p>
<p>operation </p>
<p> </p>
<p>9 </p>
<p>CRC-32 </p>
<p>Calculation of the CRC-32 according </p>
<p>to IEEE, using the polynomial: </p>
<p> </p>
<p>0x04C11DB7. The start value is </p>
<p>0xFFFFFFFF. </p>
<p>The result is inverted. </p>
<p>10 </p>
<p>SHA-1 Hash Algorithm </p>
<p>Creating a 20-byte hash value based </p>
<p>on the SHA-1 algorithm. </p>
<p>11 </p>
<p>RIPEMD-160 Hash Algorithm </p>
<p>Dto for RIPE-MD 160 </p>
<p>12 </p>
<p>Wordsum LE into 16-Bit, 2's Compl BE-Out (GM </p>
<p>new style) </p>
<p>Same as method 6, but the resulting </p>
<p>16-bit value will be represented as </p>
<p>16-bit big-endian. </p>
<p>13 </p>
<p>CRC-16 (CCITT) LE out </p>
<p>16-Bit CRC using the non-reflected </p>
<p>CCITT polynomial with start value </p>
<p>0xFFFF: </p>
<p>212 + 25 + 20   ($1021) </p>
<p>The function returns the 16-bit </p>
<p>checksum in Little-Endian format </p>
<p>(low-byte first) </p>
<p>The start value is 0xFFFF. </p>
<p>The result is inverted. </p>
<p>14 </p>
<p>CRC-16 (CCITT) BE out </p>
<p>Same as method 13, but result is in </p>
<p>Big-Endian format. </p>
<p>15 </p>
<p>MD5 Hash algorithm </p>
<p>The MD5 has value. </p>
<p>16 </p>
<p>Constant expression </p>
<p>Doesn’t calculate a checksum but </p>
<p>places a constant string to the </p>
<p>specified location. The constant is </p>
<p>taken from an INI-file with the name </p>
<p>“expdatproc.ini” located in the same </p>
<p>folder as the HEX file. The INI-file </p>
<h1 style="page-break-before:always; "></h1>
<p>Reference Manual HexView </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 1.12.02 </p>
<p>80 </p>
<p>based on template version 5.1.0 </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p>must have the following format: </p>
<p>[constant] </p>
<p>NumBytes=8 </p>
<p>HexDataString=0123456789ABCDEF </p>
<p>17 </p>
<p>CRC16 CCITT LE-Out </p>
<p>Sames as method 13, but with start </p>
<p>value 0. </p>
<p>18 </p>
<p>CRC16 CCITT BE-Out </p>
<p>Same as method 17, but in big-</p>
<p>endian output format. </p>
<p>19 </p>
<p>SHA-256 Hash Algorithm on Address, length and </p>
<p>data </p>
<p>This method builds the hash value </p>
<p>with SHA-256 including the block </p>
<p>address and length. </p>
<p><b>Note: RIPEMD-128 is discontinued </b></p>
<p><b>since V2.0 of this DLL.</b></p>
<p><b> </b></p>
<p>20 </p>
<p> </p>
<p>SHA-256 Hash Algorithm </p>
<p>Build the Hash value on the data </p>
<p>using SHA-256. </p>
<p>Table 3-3: </p>
<p>Functional overview of checksum calculation methods in “expdatproc.dll” </p>
<p><b>3.2.11 </b></p>
<p><b>Run Data Processing interface (/DPn:param[,section,key][;outfilename]) </b></p>
<p>This option will run the data processing interface. This method is called right before the </p>
<p>data export commands are executed. </p>
<p>The parameter ‘n’ specifies the method. The value ‘n’ can be calculated in a similar way to </p>
<p>the checksum calculation method. The number can be found from the list box in the Edit-</p>
<p>&gt;Run Data processing” option dialog. Count the number of  entries in this dialog starting </p>
<p>from 0. The number of processing methods depends on the EXPDATPROC.DLL. </p>
<p>Some </p>
<p>of </p>
<p>the </p>
<p>data </p>
<p>processing </p>
<p>interface </p>
<p>functions </p>
<p>may </p>
<p>take </p>
<p>over </p>
<p>useful </p>
<p>(optional) </p>
<p>parameters. This parameter is separated by a colon directly after the command line option. </p>
<p>The RSA operation also accepts PKCS#1 and PKCS#8 files without password. Public keys </p>
<p>can also be extracted from common X.509 certificates. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Examples </b></p>
<p><b>HexView testfile.dat /DP1:CC </b></p>
<p>This option runs the second data processing method in the list. It passes the parameter </p>
<p>string “CC” to the function. </p>
<p><b>Hexview testfile.dat /dp11:00112233445566778899aabbccddeeff;RFC1321#IV=0 </b></p>
<p>This command encrypts a file using AES128 in CBC-mode. The initialization vector is 0 </p>
<p>and the padding mode according to RFC1321 is applied. </p>
<p><b> </b></p>
<p><b> </b></p>
<p>The  EXPDATPROC  that  comes  with  this delivery  of  Hexview  can  manage  the  following </p>
<p>data processing methods: </p>
<p><b>ID </b></p>
<p><b>Name </b></p>
<p><b>Description </b></p>
<p><b>Parameter </b></p>
<p>0 </p>
<p>No action </p>
<p>Does no modification on </p>
<p>the data  </p>
<p>- </p>
<h1 style="page-break-before:always; "></h1>
<p>Reference Manual HexView </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 1.12.02 </p>
<p>81 </p>
<p>based on template version 5.1.0 </p>
<p><b>ID </b></p>
<p><b>Name </b></p>
<p><b>Description </b></p>
<p><b>Parameter </b></p>
<p>1 </p>
<p>XOR data with byte </p>
<p>parameter </p>
<p>Runs XOR operation on </p>
<p>the data </p>
<p>If no parameter is given, all data </p>
<p>will be inverted (XOR by 0xFF). </p>
<p>Otherwise, it will run a byte-wise </p>
<p>operation with a HEX-string </p>
<p>passed as parameter. </p>
<p>2 </p>
<p>AES-ECB encryption </p>
<p>Encrypts the data with the </p>
<p>AES standard encryption </p>
<p>method. </p>
<p>(This represents the HIS </p>
<p>security class AAA). </p>
<p>Selection of AES-128/AES-</p>
<p>196 or AES-256 selected </p>
<p>by the key length. </p>
<p>A 16/24 or 32 byte hex string </p>
<p>00112233445566778899aabbcc</p>
<p>ddeeff[;padding method] </p>
<p>Padding at the end of the block </p>
<p>is optional. The following </p>
<p>padding methods are accepted: </p>
<p>- </p>
<p>PKCS7 </p>
<p>- </p>
<p>RFC1321 </p>
<p>- </p>
<p>ANSIX.923 </p>
<p>Example: /DP2: </p>
<p>00112233445566778899 </p>
<p>aabbccddeeff;PKCS7 </p>
<p>3 </p>
<p>AES-ECB decryption </p>
<p>Decrypts data with the </p>
<p>AES-ECB method </p>
<p>A 16/24 or 32 byte hex string </p>
<p>00112233445566778899aabbcc</p>
<p>ddeeff[;padding method] </p>
<p>Use the same padding method </p>
<p>for decryption to reconstruct the </p>
<p>original size of the block. </p>
<p>4 </p>
<p>HMAC (ANSI-X9.71) </p>
<p>with SHA-1 </p>
<p>Creates a signature based </p>
<p>on Runs the HMAC using </p>
<p>SHA-1. </p>
<p>By default, the signature is </p>
<p>written to a file </p>
<p>signd_sha1.txt. </p>
<p>The key-parameter as HEX-</p>
<p>string or an ASN-formatted string </p>
<p>The ASN-string must be </p>
<p>preceeded by the tag bytes </p>
<p>FF59 or FF5B. </p>
<p>Example: /dp:mykeyfile[;outfile] </p>
<p>/dp:647262756473[;outputfile] </p>
<p>5 </p>
<p>HMAC /w SHA-1 on </p>
<p>addr+len+data </p>
<p>Creates a signature based </p>
<p>on HMAC using SHA-1 </p>
<p>including the address and </p>
<p>length information for each </p>
<p>segment </p>
<p>By default, the signature is </p>
<p>written to the file </p>
<p>signdal_sha1.txt. </p>
<p>This is security class C. </p>
<p>The key-parameter as HEX-</p>
<p>string or an ASN-formatted </p>
<p>string. </p>
<p>The ASN-string must be </p>
<p>preceeded by the tag bytes </p>
<p>FF59 or FF5B </p>
<p>Example: /dp:mykeyfile[;outfile] </p>
<p>/dp:647262756473[;outputfile] </p>
<p>6 </p>
<p>HMAC (ANSI-X9.71) </p>
<p>with RIPEMD-160 </p>
<p>Creates a signature based </p>
<p>on HMAC using </p>
<p>RIPEMD160 including the </p>
<p>address and length </p>
<p>information for each </p>
<p>segment. </p>
<p>By default, the signature is </p>
<p>written to the file </p>
<p>SignD_Ripemd160.HMAC. </p>
<p>The key-parameter as HEX-</p>
<p>string or an ASN-formatted </p>
<p>string. </p>
<p>The ASN-string must be </p>
<p>preceeded by the tag bytes </p>
<p>FF59 or FF5B </p>
<p>Example: /dp:mykeyfile[;outfile] </p>
<p>/dp:647262756473[;outputfile] </p>
<h1 style="page-break-before:always; "></h1>
<p>Reference Manual HexView </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 1.12.02 </p>
<p>82 </p>
<p>based on template version 5.1.0 </p>
<p><b>ID </b></p>
<p><b>Name </b></p>
<p><b>Description </b></p>
<p><b>Parameter </b></p>
<p>7 </p>
<p>HMAC /w RIPEMD-160 </p>
<p>on addr+len+data </p>
<p>Creates a signature based </p>
<p>on HMAC using </p>
<p>RIPEMD160. </p>
<p>By default, the signature is </p>
<p>written to the file </p>
<p>SignDAL_Ripemd160.HMA</p>
<p>C </p>
<p>This is security class C.. </p>
<p>The key-parameter as HEX-</p>
<p>string or an ASN-formatted </p>
<p>string. </p>
<p>The ASN-string must be </p>
<p>preceeded by the tag bytes </p>
<p>FF59 or FF5B </p>
<p>Example: /dp:mykeyfile[;outfile] </p>
<p>/dp:647262756473[;outputfile] </p>
<p>8 </p>
<p>RSA-Signature /w SHA-</p>
<p>1 on data </p>
<p>Creating the hash-value </p>
<p>using the SHA-1 algorithm </p>
<p>the data (only) for every </p>
<p>segment and encrypt the </p>
<p>result with the RSA </p>
<p>algorithm. By default, the </p>
<p>output is written to </p>
<p>SignD_SHA1.RSA. </p>
<p>The private key as an ASN </p>
<p>formatted string. The string must </p>
<p>be preceeded by the tag FF49 or </p>
<p>FF4B. The tag for the exponent </p>
<p>is 0x91 and the tag for the </p>
<p>modulo is 0x81. </p>
<p>Example: /dp:mykeyfile[;outfile] </p>
<p>Note: Signature follows the </p>
<p>EMSA-PKCS1-v1_5 format. </p>
<p>9 </p>
<p>RSA-Signature /w </p>
<p>RIPEMD160 on </p>
<p>Addr+Len+Data </p>
<p>Creating the hash-value </p>
<p>using the RIPEMD160 </p>
<p>algorithm on address, </p>
<p>length and data for every </p>
<p>segment and encrypt the </p>
<p>result with the RSA </p>
<p>algorithm. By default, the </p>
<p>output is written to </p>
<p>SignDAL_RIPEMD160.RS</p>
<p>A. </p>
<p>This is security class CCC. </p>
<p>The private key as an ASN </p>
<p>formatted string. The string must </p>
<p>be preceeded by the tag FF49 or </p>
<p>FF4B. The tag for the exponent </p>
<p>is 0x91 and the tag for the </p>
<p>modulo is 0x81. </p>
<p>Example: /dp:mykeyfile[;outfile </p>
<p>Note: Signature follows the </p>
<p>EMSA-PKCS1-v1_5 format. </p>
<p>10 </p>
<p>RSA-Signature /w SHA-</p>
<p>1 on Addr+Len+data </p>
<p>Creating the hash-value </p>
<p>using the RIPEMD160 </p>
<p>algorithm on address, </p>
<p>length and data for every </p>
<p>segment and encrypt the </p>
<p>result with the RSA </p>
<p>algorithm. By default, the </p>
<p>output is written to </p>
<p>SignDAL_SHA1.RSA </p>
<p>This is security class CCC. </p>
<p>The private key as an ASN </p>
<p>formatted string. The string must </p>
<p>be preceeded by the tag FF49 or </p>
<p>FF4B. The tag for the exponent </p>
<p>is 0x91 and the tag for the </p>
<p>modulo is 0x81. </p>
<p>Example: /dp:mykeyfile[;outfile] </p>
<p>Note: Signature follows the </p>
<p>EMSA-PKCS1-v1_5 format. </p>
<p>11 </p>
<p>AES-CBC Encryption  </p>
<p>Encrypts the data with AES </p>
<p>in CBC-mode using an </p>
<p>initialisation vector (IV).  </p>
<p>The IV will be taken from the first </p>
<p>16 bytes of the data stream. The </p>
<p>data for the IV will be skipped for </p>
<p>encryption operation. </p>
<p>The IV can also be defined </p>
<p>explicitly in the parameter field </p>
<p>separated by the Hash sign. </p>
<p>Example: </p>
<p>“/dp11:00112233445566778899a</p>
<p>abbccddeeff;RFC1321#IV=ABC</p>
<p>D” </p>
<h1 style="page-break-before:always; "></h1>
<p>Reference Manual HexView </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 1.12.02 </p>
<p>83 </p>
<p>based on template version 5.1.0 </p>
<p><b>ID </b></p>
<p><b>Name </b></p>
<p><b>Description </b></p>
<p><b>Parameter </b></p>
<p>IV=0 sets the IV explicitly to 0. </p>
<p>remaining values will be set to 0 </p>
<p>by default. Use a 32 char hex </p>
<p>string if you want to define a </p>
<p>complete and explicit vector. </p>
<p>See option 2 for further </p>
<p>description. </p>
<p>12 </p>
<p>AES-CBC Decryption  </p>
<p>Counter operation of AES-</p>
<p>CBC Encryption.  </p>
<p>See operation #11 for further </p>
<p>description. </p>
<p>13 </p>
<p>HMAC (ANSI-X9.71) </p>
<p>with MD-5&quot; </p>
<p>Calculating the Hash-MAC </p>
<p>based on MD5 </p>
<p>The key-parameter as HEX-</p>
<p>string or an ASN-formatted string </p>
<p>The ASN-string must be </p>
<p>preceeded by the tag bytes </p>
<p>FF59 or FF5B. </p>
<p>Examples:  </p>
<p>/dp:mykeyfile[;outputfile] </p>
<p>/dp:6472A275D73[;outputfile] </p>
<p>14 </p>
<p>HMAC /w MD-5 on </p>
<p>addr+len+data </p>
<p>Same as #13, but also </p>
<p>including address and </p>
<p>length of each block to the </p>
<p>hash value. </p>
<p>The key-parameter as HEX-</p>
<p>string or an ASN-formatted string </p>
<p>The ASN-string must be </p>
<p>preceeded by the tag bytes </p>
<p>FF59 or FF5B. </p>
<p>Example:  </p>
<p>/dp:mykeyfile[;outfile] </p>
<p>/dp:647262756473[;outputfile] </p>
<p>15 </p>
<p>RSA-Signature /w MD5 </p>
<p>on data </p>
<p>Creating the hash-value </p>
<p>using the MD5 algorithm </p>
<p>the data (only) for every </p>
<p>segment and encrypt the </p>
<p>result with the RSA </p>
<p>algorithm. By default, the </p>
<p>output is written to </p>
<p>SignD_MD5.RSA. </p>
<p>The private key as an ASN </p>
<p>formatted string. The string must </p>
<p>be preceeded by the tag FF49 or </p>
<p>FF4B. The tag for the exponent </p>
<p>is 0x91 and the tag for the </p>
<p>modulo is 0x81. </p>
<p>Example: /dp:mykeyfile[;outfile] </p>
<p>Note: Signature follows the </p>
<p>EMSA-PKCS1-v1_5 format. </p>
<p>16 </p>
<p>RSA-Signature /w MD5 </p>
<p>on Addr+Len+data </p>
<p>Creating the hash-value </p>
<p>using the MD5 algorithm on </p>
<p>address, length and data </p>
<p>for every segment and </p>
<p>encrypt the result with the </p>
<p>RSA algorithm. By default, </p>
<p>the output is written to </p>
<p>SignDAL_MD5.RSA </p>
<p>The private key as an ASN </p>
<p>formatted string. The string must </p>
<p>be preceeded by the tag FF49 or </p>
<p>FF4B. The tag for the exponent </p>
<p>is 0x91 and the tag for the </p>
<p>modulo is 0x81. </p>
<p>Example: /dp:mykeyfile[;outfile] </p>
<p>Note: Signature follows the </p>
<p>EMSA-PKCS1-v1_5 format. </p>
<p>17 </p>
<p>RSA Encryption (Public </p>
<p>key operation) </p>
<p>Encrypt data using the </p>
<p>public RSA key. </p>
<p>Example: /dp:mykeyfile. </p>
<p>Note: The type of operation </p>
<p>depends on the length of input </p>
<p>data. If the length is not a </p>
<p>multiple of the keylength, data </p>
<h1 style="page-break-before:always; "></h1>
<p>Reference Manual HexView </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 1.12.02 </p>
<p>84 </p>
<p>based on template version 5.1.0 </p>
<p><b>ID </b></p>
<p><b>Name </b></p>
<p><b>Description </b></p>
<p><b>Parameter </b></p>
<p>will padded as block type 02 </p>
<p>according to PKCS#1, V1.5. If </p>
<p>the length is a multiple of </p>
<p>keylength, a plain RSA operation </p>
<p>will be performed. </p>
<p>RSA-512/1024/1536 and 2048 </p>
<p>are supported. Operation </p>
<p>derived from length of modulo. </p>
<p>Do not encrypt files longer than </p>
<p>RSA-bit size. </p>
<p>18 </p>
<p>RSA Decryption (Private </p>
<p>key operation) </p>
<p>Decrypt data using the </p>
<p>private RSA key. </p>
<p>Example: /dp:mykeyfile. </p>
<p>Note: Data length is expevted to </p>
<p>be a multiple of keylength. First, </p>
<p>decryption of PKCS#1, V1.5 BT </p>
<p>02 is tried. If this fails, a plain </p>
<p>decryption is performed. </p>
<p>19 </p>
<p>LZ Vector data </p>
<p>compression (0) </p>
<p>LZSS with Vector specific </p>
<p>coding of compressed </p>
<p>data.  </p>
<p>This is the default and </p>
<p>preferred algorithm! </p>
<p>Uses 8 bits for sliding window </p>
<p>and 4 bits for repeated </p>
<p>characters </p>
<p>20 </p>
<p>LZ Vector data </p>
<p>compression (1) </p>
<p>LZSS with Vector specific </p>
<p>coding of compressed </p>
<p>data.  </p>
<p>Uses 9 bits for sliding window </p>
<p>and 4 bits for repeated </p>
<p>characters </p>
<p>21 </p>
<p>LZ Vector data </p>
<p>compression (2) </p>
<p>LZSS with Vector specific </p>
<p>coding of compressed </p>
<p>data.  </p>
<p>Uses 12 bits for sliding window </p>
<p>and 6 bits for repeated </p>
<p>characters </p>
<p>22 </p>
<p>LZ Vector data </p>
<p>decompression (0) </p>
<p>LZSS decompression of </p>
<p>Vector specific method </p>
<p>Counter operation of #19 </p>
<p>23 </p>
<p>LZ Vector data </p>
<p>decompression (1) </p>
<p>LZSS decompression of </p>
<p>Vector specific method </p>
<p>Counter operation of #20 </p>
<p>24 </p>
<p>LZ Vector data </p>
<p>decompression (2) </p>
<p>LZSS decompression of </p>
<p>Vector specific method </p>
<p>Counter operation of #21 </p>
<p>25 </p>
<p>RSA-RIPEMD sign. </p>
<p>A+L+D /w Vector data </p>
<p>compression (0) </p>
<p>Calculates the hash with </p>
<p>RIPEMD-160 with address </p>
<p>and uncompressed length </p>
<p>over compressed data, </p>
<p>encrypts the signature </p>
<p>using RSA-1024 and writes </p>
<p>the result to the signature </p>
<p>file. Outputs compressed </p>
<p>data. Thus, signature and </p>
<p>compression is done in one </p>
<p>step. </p>
<p>This is the only way to add </p>
<p>address and uncompressed </p>
<p>length to the signature while </p>
<p>compressing the file at the same </p>
<p>time. The uncompressed </p>
<p>memory size is transferred in </p>
<p>RequestDownload and added to </p>
<p>the hash value. Input parameter </p>
<p>like in operation #9. </p>
<p>It can fulfull Security class CCC </p>
<p>w/ compression. </p>
<p>This method is not needed when </p>
<p>using “LifeCompression” </p>
<p>26 </p>
<p>LZSS data compression </p>
<p>(10Bit/4Bit acc. Ford-</p>
<p>This is a pure LZSS </p>
<p>compression with bit coded </p>
<p>Sliding window is 10 bit length, </p>
<p>repeat character is 4 bits. </p>
<h1 style="page-break-before:always; "></h1>
<p>Reference Manual HexView </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 1.12.02 </p>
<p>85 </p>
<p>based on template version 5.1.0 </p>
<p><b>ID </b></p>
<p><b>Name </b></p>
<p><b>Description </b></p>
<p><b>Parameter </b></p>
<p>SWDL005) </p>
<p>value of plain text or </p>
<p>repeated data. </p>
<p>27 </p>
<p>LZSS data </p>
<p>decompression </p>
<p>(10Bit/4Bit acc. Ford-</p>
<p>SWDL005) </p>
<p>The LZSS decompression </p>
<p>algorithm  </p>
<p>Counter operation of #26. </p>
<p>28 </p>
<p>RSA-Signature /w </p>
<p>RIPEMD160 on Data </p>
<p>RSA signature without </p>
<p>address and length info. </p>
<p>Like e.g. in operation #9. </p>
<p>29 </p>
<p>HMAC-RIPEMD sign. </p>
<p>A+L+D /w Vector </p>
<p>compression (0) </p>
<p>Calculates the hash with </p>
<p>RIPEMD-160 with address </p>
<p>and uncompressed length </p>
<p>over compressed data, </p>
<p>encrypts the signature </p>
<p>using RSA-1024 and writes </p>
<p>the result to the signature </p>
<p>file. Outputs compressed </p>
<p>data. Thus, signature and </p>
<p>compression is done in one </p>
<p>step. </p>
<p>This is the only way to add </p>
<p>address and uncompressed </p>
<p>length to the signature while </p>
<p>compressing the file at the same </p>
<p>time. The uncompressed </p>
<p>memory size is transferred in </p>
<p>RequestDownload and added to </p>
<p>the has value. Input parameter </p>
<p>like in operation #9. It can fulfull </p>
<p>Security class C w/ </p>
<p>compression. </p>
<p>This method is not needed when </p>
<p>using “LifeCompression” </p>
<p>30 </p>
<p>HMAC-SHA256 </p>
<p>Calculate the Hash MAC </p>
<p>with SHA256 </p>
<p>Segment address and length is </p>
<p>not added to the hash value. </p>
<p>A symmetric key as parameter is </p>
<p>required. </p>
<p>31 </p>
<p>HMAC-SHA256 on </p>
<p>segment-</p>
<p>address+segment-</p>
<p>length+data </p>
<p>Calculate the Hash-MAC </p>
<p>with SHA256, hashing also </p>
<p>start address and length </p>
<p>per segment. </p>
<p>A symmetric key as parameter is </p>
<p>required. </p>
<p>32 </p>
<p>RSA-Signature on data </p>
<p>using SHA256. </p>
<p>Builds the signature on the </p>
<p>data  </p>
<p>The private key as an ASN </p>
<p>formatted string. The string must </p>
<p>be preceeded by the tag FF49 or </p>
<p>FF4B. The tag for the exponent </p>
<p>is 0x91 and the tag for the </p>
<p>modulo is 0x81. </p>
<p>Example: /dp:mykeyfile[;outfile] </p>
<p>Note: Signature follows the </p>
<p>EMSA-PKCS1-v1_5 format. </p>
<p>33 </p>
<p>RSA-Signature using </p>
<p>SHA256 on </p>
<p>address+length+data. </p>
<p>Builds the signature on the </p>
<p>segment start </p>
<p>address+segment </p>
<p>length+segmentdata (per </p>
<p>all segments) </p>
<p>The private key as an ASN </p>
<p>formatted string. The string must </p>
<p>be preceeded by the tag FF49 or </p>
<p>FF4B. The tag for the exponent </p>
<p>is 0x91 and the tag for the </p>
<p>modulo is 0x81. </p>
<p>Example: /dp:mykeyfile[;outfile] </p>
<p>Note: Signature follows the </p>
<p>EMSA-PKCS1-v1_5 format. </p>
<p>34 </p>
<p>Ford compression with </p>
<p>Performs the Ford </p>
<p>Parameter like for AES CBC </p>
<h1 style="page-break-before:always; "></h1>
<p>Reference Manual HexView </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 1.12.02 </p>
<p>86 </p>
<p>based on template version 5.1.0 </p>
<p><b>ID </b></p>
<p><b>Name </b></p>
<p><b>Description </b></p>
<p><b>Parameter </b></p>
<p>AES-CBC encryption </p>
<p>compression (LZSS 10/4) </p>
<p>followed by AES CBC </p>
<p>encryption. </p>
<p>compression (see #11) </p>
<p>35 </p>
<p>AES-CBC decryption </p>
<p>with Ford </p>
<p>decompression </p>
<p>Performs first the </p>
<p>decryption of the data with </p>
<p>AES-CBC followed by the </p>
<p>Ford decompression with </p>
<p>LZSS (10/4). </p>
<p>Parameter like for AES CBC </p>
<p>compression (see #11) </p>
<p>36 </p>
<p>ARLE compression </p>
<p>Compresses a file with </p>
<p>ARLE </p>
<p>ARLE format: </p>
<p>00LL.LLLL: Plain bytes </p>
<p>01LL.LLLL: Repeated byte </p>
<p>10LL.LLLL: Repeated WORD </p>
<p>11LL.LLLL: Repeated LWORD </p>
<p>LLLLLL specifies the number of </p>
<p>repetitions or plain data bytes. </p>
<p>Good compression for multiple </p>
<p>repetitive bytes or words. </p>
<p>37 </p>
<p>ARLE decompression </p>
<p>Decompresses a file with </p>
<p>ARLE </p>
<p>See above. </p>
<p>38 </p>
<p>Code signing with RSA-</p>
<p>PSS SHA-256 </p>
<p>Hashes the data with SHA-</p>
<p>256 and signs it with RSA-</p>
<p>PSS. </p>
<p>Note that the salt is generated </p>
<p>with srand()/rand(). </p>
<p>Parameters like above. </p>
<p>39 </p>
<p>Code signing with RSA-</p>
<p>PSS SHA-256 </p>
<p>Same as 38, but also </p>
<p>hashes address and length </p>
<p>before hashing the data. </p>
<p>See above. </p>
<p>40 </p>
<p>RSA encryption with </p>
<p>RSA-OAEP with SHA-1 </p>
<p>Encrypts the data with the </p>
<p>public key </p>
<p>See above </p>
<p>41 </p>
<p>RSA decryption with </p>
<p>RSA-OAEP with SHA-1 </p>
<p>Decrypts the data with the </p>
<p>private key </p>
<p>See above </p>
<p>42 </p>
<p>RSA encryption with </p>
<p>RSA-OAEP with SHA-</p>
<p>256 </p>
<p>Encrypts the data with the </p>
<p>public key </p>
<p>See above </p>
<p>43 </p>
<p>RSA decryption with </p>
<p>RSA-OAEP with SHA-</p>
<p>256 </p>
<p>Decrypts the data with the </p>
<p>public key </p>
<p>See above </p>
<p> </p>
<p>Table 3-4  </p>
<p>Functional overview of data processing methods in “expdatproc.dll” </p>
<p>With  EXPDATPROC.DLL,  V1.02,  it  is  also  possible  to  pass  the  parameters  not  only </p>
<p>directly but through a file or an INI-file. The parameter must be passed as follows: </p>
<p>Passing the parameter through a file: </p>
<p> /DP:input-filename[;output-filename] </p>
<p> </p>
<p>Passing the parameter through an INI-file: </p>
<p> </p>
<p> </p>
<p> /DP:input-filename,sectionname, keyname[;out-filename] </p>
<h1 style="page-break-before:always; "></h1>
<p>Reference Manual HexView </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 1.12.02 </p>
<p>87 </p>
<p>based on template version 5.1.0 </p>
<p> </p>
<p> </p>
<p> </p>
<p> The INI-file has the format: </p>
<p> </p>
<p> </p>
<p> </p>
<p>  </p>
<p> [sectionname] </p>
<p> </p>
<p> </p>
<p> </p>
<p>     keyname=’0011223344’ </p>
<p>In  every  case,  an  output-filename  can  be  optionally  entered,  preceeded  by  a  “;”.  This </p>
<p>output-filename will overwrite the default output filename. </p>
<p>Please note that all file references within the data processing operation are relative to the </p>
<p>location of the data file that is currently loaded. So use either full path or use relative paths </p>
<p>related to the location of your input file! </p>
<p>The output is always written relative to the location of the Hex-File loaded by HexView. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Expert Knowledge </b></p>
<p>Methods 17 and 18 for RSA operation are different in behavior depending on the length </p>
<p>of input data and thus somewhat tricky for use. That is to pack several use-cases into </p>
<p>this method. </p>
<p><b>17 RSA Encryption</b>: If the input data are a multiple of the modulo length, a public key </p>
<p>operation will be applied on each of it. If the data length is not equal to the public key </p>
<p>length, Encryption with the public key will be applied according to PKCS#1, V1.5. That </p>
<p>is, a maximum of &lt;RSA-Length&gt; - 12 bytes are taken, 00 02 is added, then filled with </p>
<p>(non-zero) random values, a ‘0’ is added followed by the data. This package is </p>
<p>encrypted with the public key. </p>
<p><b>18 RSA Decryption: </b>If the input data are a multiple of the modulo length, the RSA </p>
<p>operation will be applied on a try-and-error method. First, PKCS#1, V1.5 decryption </p>
<p>with the public key is applied. If the result does not start with 00 02, then the RSA </p>
<p>operation will be applied without interpretation using the private key. </p>
<p>If the length is not a multiple of the modulo, then the encryption according to PKCS#1, </p>
<p>V1.5 will be applied. Thus, 00 01 will be set, followed by a number of FF and one 00 </p>
<p>until the fill value and data provides a multiple of the RSA key length. This data is then </p>
<p>encrypted with the private key. </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>3.2.12 </b></p>
<p><b>Specify an alternative data processing DLL (/expdat:&lt;path-to-</b></p>
<p><b>expdatproc.dll&gt;) </b></p>
<p>By default, Hexview searches and loads the DLL EXPDATPROC.DLL for daa processing </p>
<p>and </p>
<p>checksum </p>
<p>calculation </p>
<p>methods. </p>
<p>This </p>
<p>default </p>
<p>value </p>
<p>can </p>
<p>be </p>
<p>overwritten </p>
<p>by </p>
<p>this </p>
<p>commandline interface. An alternative path and name for the DLL can be specified, so that </p>
<p>these methods are used for the options /CS or /DP. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>Only one DLL can be active at a time. Thus, if you specify your own DLL, the default </p>
<p>methods are not available. </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>3.2.13 </b></p>
<p><b>Create error log file (/E:errorfile.err) </b></p>
<p>This specifies an error log file. HexView can run in silent mode (see 3.2.24). In that case, </p>
<p>no error will be displayed to the GUI. However, error messages are important to know. This </p>
<p>option allows to re-direct the output to a file. </p>
<h1 style="page-break-before:always; "></h1>
<p>Reference Manual HexView </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 1.12.02 </p>
<p>88 </p>
<p>based on template version 5.1.0 </p>
<p><b>3.2.14 </b></p>
<p><b>Create single region file (/FA) </b></p>
<p>This option can be used to create a single block file. In that case, HexView will use the </p>
<p>start  address  of  the  first  block  and  the  end  address  of  the  last  block  and  will  fill  all </p>
<p>remaining holes in-between with the fill character given with the /AFxx parameter. </p>
<p>Note that some files should be a single region file, e.g. the flashdrivers are not allowed to </p>
<p>have more than 1 region. This option can ensure that the file is a single region file.  </p>
<p><b>3.2.15 </b></p>
<p><b>Fill region (/FR:’range1’:’range2’:…) </b></p>
<p>This option is used to create and fill memory regions. If the /FP parameter is not provided, </p>
<p>HexView will create random data to fill the blocks or regions. Otherwise, the value given by </p>
<p>the /FP parameter will be used repetitively. The fill-operation does not touch existing data. </p>
<p>Thus, it can even be used to fill data between segments. Ranges are either specified by its </p>
<p>start  and  length,  separated  by  a  coma,  or  by  start  and  end  address,  separated  by  the </p>
<p>minus sign (e.g. /FR:0x1000,0x200:0x2000-0x2FFF). </p>
<p><b>3.2.16 </b></p>
<p><b>Specify fill pattern (/FP:xxyyzz…) </b></p>
<p>This option can be used to specify a fill pattern that’s been used to fill regions. This option </p>
<p>is  only  useful  in  combination  with  the  /FR  parameter. The  parameter  for  /FP  is  a  list  of  </p>
<p>(see /FR option). The parameter will be treaded as a data stream in hexadecimal format. </p>
<p><b>3.2.17 </b></p>
<p><b>Import HEX-ASCII data (/IA:filename[;AddressOffset]) </b></p>
<p>This option is used to instruct Hexview to read in HEX-ASCII data values to the internal </p>
<p>data memory. Since HEX-ASCII files are not detected automatically, it cannot be read in as </p>
<p>a normal input file. However, if you want to use this option, you cannot read in a normal </p>
<p>HEX file while you are also want to read in HEX-ASCII data. The accepted format is as </p>
<p>follows: </p>
<p>  23456789 </p>
<p>  0x12, 0x23, 0x34, … </p>
<p> </p>
<p>All data are expected to be in HEX data format. No integers will be recognized. </p>
<p>Typically, the input data will be located at start address 0. An offset can be specified with </p>
<p>the  parameter,  e.g.  /IA:myhexstring.asc;0x1000,  which  will  place  the  string  at  address </p>
<p>0x1000. No data overlapping is allowed with data from the input file! If data overlaps, a </p>
<p>warning is generated and the HEX input is completely ignored. </p>
<p>Hint: Set the filename in double quotes if spaces or other untypical characters are used for </p>
<p>the filename itself. </p>
<p><b>3.2.18 </b></p>
<p><b>Import Binary data (/IN:filename[;AddressOffset]) </b></p>
<p>This option can be used to import explicitly a binary data file. This option is used to avoid </p>
<p>the  file  interpretation  algorithm.  It  corresponds  to  the  “File  -&gt;  Import  -&gt;  Import  Binary” </p>
<p>option from the GUI. </p>
<p><b>3.2.19 </b></p>
<p><b>Execute logfile (/L:logfile) </b></p>
<p>This option is intended to load a logfile command. Similar to a macro recorder, actions in </p>
<p>the GUI can be logged and later on re-executed using this command line option. Refer to </p>
<p>section 2.2.1.7 for further description). </p>
<h1 style="page-break-before:always; "></h1>
<p>Reference Manual HexView </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 1.12.02 </p>
<p>89 </p>
<p>based on template version 5.1.0 </p>
<p><b>3.2.20 </b></p>
<p><b>Merging files (/MO, /MT) </b></p>
<p>One or more files can be merged into the internal data memory of the program. The files </p>
<p>are  read  using  the  auto-detect  filetype  mechanism  described  in  chapter  2.2.1.2.1.  The </p>
<p>commandline operation has some optional parameters to control the merge operation. </p>
<p>First,  the  type  of  merge  operation  need  to  be  chosen.  The  merge  can  done  in  a </p>
<p>transparent (/MT) or opaque (/MO) mode. Both cannot be mixed. Only one can be chosen </p>
<p>in one commandline operation.  </p>
<p>In the transparent mode, the loaded filedata will not overwrite data in the internal memory. </p>
<p>The  opaque  mode  does  not  check  if  data  already  exist  and  will  load  the  data  from  the </p>
<p>merged file unconditionally. Already existing data may be overwritten. </p>
<p>Option extensions: file1[;offset][:’range’][+file2;offset][:’range’] </p>
<p>The filename must be followed directly to the option, separated by either a ‘: or the ‘=’ sign </p>
<p>(/Mx:file or /Mx=file). An optional offset parameter can be added. The offset can be positive </p>
<p>or  negative,  specified  in  hexadecimal  or  integer.  In  addition,  a  data  range  that’s  been </p>
<p>loaded from the merge-file can be specified. This can be given with or without the offset. </p>
<p>Note, that the range will be applied on the unshifted data, then the address shift operation </p>
<p>will be applied. </p>
<p>Further files to merge can be added using the ‘+’ character to separate the next file to load. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Example </b></p>
<p>HexView will merge the file “cal1.hex” with address offset -0x1000, then loads </p>
<p>“cal2.s19” with address offset 128. Existing address information in the internal memory </p>
<p>will not be overwritten. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Example </b></p>
<p><b>/MT:cal1.hex;-0x1000+cal2.s19;128 </b></p>
<p> </p>
<p><b>/MO:testfile.hex;0x2000-0x3FFF </b></p>
<p>Simply reads the address range from 0x2000-0x3FFF from the file “testfile.hex” into the </p>
<p>memory. No offset will be added or subtracted. Existing data on the same address will </p>
<p>be overwritten. </p>
<p><b>/MT:testfile1.hex;0x2000:0x1000,0x4000+cal2.s19;-0x3000:0x1000-0x1FFF </b></p>
<p>Merges the address range 0x1000-0x4FFF of testfile1.hex and shifts all block </p>
<p>addresses of these ranges by the offset 0x2000. Afterwards, merges the address range </p>
<p>0x1000-0x1FFF of file cal2.s19 and changes the block start addresses by -0x3000. </p>
<p>Note: /MT and /MO cannot be combined in one commandline. Only the last in the </p>
<p>commandline-list will be used, in that case. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Reference Manual HexView </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 1.12.02 </p>
<p>90 </p>
<p>based on template version 5.1.0 </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>Since this operation can manipulate data in a post process, make sure HexView </p>
<p>creates the resulting file containing the desired data and applies the correct changes. </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>3.2.21 </b></p>
<p><b>Merge two VBF files (/MVBF:vbf_file.vbf) </b></p>
<p>This command allows to merge two VBF files into one. Pre-requisite is, that a valid VBF </p>
<p>file has already been loaded resp has been loaded as the basic input file. The VBF file </p>
<p>specified with /MVBF will be merged into the currently loaded. </p>
<p>Hexview reads the VBF file specified with /MVBF if it is a valid VBF and then checks if data </p>
<p>sections  overlap  with  the  currently  loaded  file.  At  next  some  basic  parameters  are </p>
<p>compared with each other like VBF version, software part type, ECU address or software </p>
<p>part  numbers,  because  they  cannot  be  mixed  in  a  combined  VBF  file.  If  everything </p>
<p>matches, the erase and omit ranges of the two VBF files are merged. If the loaded file was </p>
<p>a Ford VBF then also the software signature and validation structure address is merged. </p>
<p>Then the data are merged into the currently loaded file. The result can be written back. </p>
<p>The process can be repeated with the same file so that one resulting VBF may contain all </p>
<p>sub-VBFs  of  a  project.  Note  that  only  the  concatenated  VBF  header  information  will </p>
<p>written. Other changes from an INI-file will be ignored. Changes to data of the loaded file </p>
<p>will be applied and written to the output file. </p>
<p> </p>
<p><b>3.2.22 </b></p>
<p><b>Run postbuild operation (/pb=postbuild-file) </b></p>
<p>This  option  applies  the  postbuild  operation.  This  option  requires  a  valid  PBUILD.DLL  to </p>
<p>read the data from a postbuild file. The results will be applied to the internal document. </p>
<p>Originally, it is used to read the generated postbuild XML-file using the PBUILD.DLL that </p>
<p>comes  along  with  Hexview.  However,  it  can  also  be  used  to  apply  your  own  postbuild </p>
<p>configuration or to apply data changes to the currently loaded document. </p>
<p>The only pre-requisite is that the DLL provides the correct interface functions. </p>
<p>The DLL interface functions will be called in the following sequence: </p>
<p> </p>
<p>Figure 3-5: </p>
<p>Calling sequence of the post-build  functions </p>
<p>OpenPBFile(Filename)</p>
<p>GetPBSegmentInfo(Address[], Length[], </p>
<p>maxNoOfSegments)</p>
<p>GetPBData(srcAddress, dstAddress, </p>
<p>length)</p>
<p>ClosePBFile( )</p>
<h1 style="page-break-before:always; "></h1>
<p>Reference Manual HexView </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 1.12.02 </p>
<p>91 </p>
<p>based on template version 5.1.0 </p>
<p>The following function interface will be applied: </p>
<p><b>3.2.22.1 </b></p>
<p><b>OpenPBFile </b></p>
<p><b>Prototype </b></p>
<p>Long __declspec(dllexport) __cdecl <b>OpenPBFile  </b>( LPCSTR filename ) </p>
<p><b>Parameter </b></p>
<p>Filename </p>
<p>Pointer to the location of the file that shall be opened. This is the full-path of </p>
<p>the file that has been selected in the file dialog when slecting the “Apply </p>
<p>postbuild options”. </p>
<p><b>Return code </b></p>
<p>Long </p>
<p>Number of segments found in the postbuild file and shall be applied to. </p>
<p><b>Functional Description </b></p>
<p>Requests to open a file used for the postbuild operation process. Typically, it is the XML file generated by </p>
<p>GENy to apply the postbuild configuration data. </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>The function must return the number of segments that shall be applied to the postbuild operation </p>
<p>Call context </p>
<p><b>&gt; </b></p>
<p>- </p>
<p>Table 3-5  </p>
<p>OpenPBFile </p>
<p><b>3.2.22.2 </b></p>
<p><b>ClosePBFile </b></p>
<p><b>Prototype </b></p>
<p>Void __declspec(dllexport) __cdecl <b>ClosePBFile  </b>( void ) </p>
<p><b>Parameter </b></p>
<p>- </p>
<p>- </p>
<p><b>Return code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>Closes the previously opened file. Concludes all operations within the DLL. </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>- </p>
<p>Call context </p>
<p><b>&gt; </b></p>
<p>- </p>
<p>Table 3-6  </p>
<p>OpenPBFile </p>
<p><b>3.2.22.3 </b></p>
<p><b>ClosePBFile </b></p>
<p><b>Prototype </b></p>
<p>Long __declspec(dllexport) __cdecl <b>GetPBSegmentInfo  </b>( DWORD address[], DWORD </p>
<p>length[], long maxSegments ) </p>
<h1 style="page-break-before:always; "></h1>
<p>Reference Manual HexView </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 1.12.02 </p>
<p>92 </p>
<p>based on template version 5.1.0 </p>
<p><b>Parameter </b></p>
<p>Address </p>
<p>Length </p>
<p> </p>
<p>Long maxSegments </p>
<p>Pointer to a list of addresses. Will be filled by the operation. </p>
<p>Pointer to a list of length values. Each field for one segment. The index </p>
<p>corresponds to the address field. </p>
<p>Size of the fields where Address and Length points to. The interface function </p>
<p>shall not place more address and length information into the list as specified </p>
<p>by maxSegments (will exceeds internal data structures within Hexview). </p>
<p><b>Return code </b></p>
<p>Long </p>
<p>Number of segments found in the postbuild file and loaded to the segment </p>
<p>arrays of Address[] and Length[].. </p>
<p><b>Functional Description </b></p>
<p>Provides all segments from the postbuild file that shall be loaded.- </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>The function must return the number of segments that has been loaded to the arrays. </p>
<p><b>&gt; </b></p>
<p>Segments provided in the list of address[] and length[] shall not overlap, length shall be greater than 0 in </p>
<p>all cases (otherwise, the element in the list should be omitted). </p>
<p>Call context </p>
<p><b>&gt; </b></p>
<p>- </p>
<p>Table 3-7  </p>
<p>ClosePBFile </p>
<p><b>3.2.22.4 </b></p>
<p><b>GetPBData </b></p>
<p><b>Prototype </b></p>
<p>Long __declspec(dllexport) __cdecl <b>GetPBData  </b>( DWORD srcAddress, char </p>
<p>*dstBuffer, DWORD length) </p>
<p><b>Parameter </b></p>
<p>srcAddress </p>
<p>Length </p>
<p> </p>
<p>Long maxSegments </p>
<p>Pointer to the segment that shall be read. Corresponds to at least one of </p>
<p>the Addresses  of addresses. Will be filled by the operation. </p>
<p>Pointer to a list of length values. Each field for one segment. The index </p>
<p>corresponds to the address field. </p>
<p>Size of the fields where Address and Length points to. The interface function </p>
<p>shall not place more address and length information into the list as specified </p>
<p>by maxSegments (will exceeds internal data structures within Hexview). </p>
<p><b>Return code </b></p>
<p>Long </p>
<p>Number of bytes read for post-building. </p>
<p><b>Functional Description </b></p>
<p>Reads the segment data from the postbuild file and applies it to the current document. </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>The function must return the number of bytes read from the segment. </p>
<p><b>&gt; </b></p>
<p>The number of bytes read from the segment must correspond to the size previously specified for the </p>
<p>segment that belongs to the address given in the parameter. </p>
<p>Call context </p>
<p><b>&gt; </b></p>
<p>- </p>
<p>Table 3-8  </p>
<p>GetPBData </p>
<h1 style="page-break-before:always; "></h1>
<p>Reference Manual HexView </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 1.12.02 </p>
<p>93 </p>
<p>based on template version 5.1.0 </p>
<p><b>3.2.23 </b></p>
<p><b>Specify output filename (-o outfilename) </b></p>
<p>This option is used to overwrite the default output filename when exporting data to a file.  </p>
<p><b>3.2.24 </b></p>
<p><b>Run in silent mode (/s) </b></p>
<p>This option is used to suppress any output to the GUI. After executing all commands given </p>
<p>in the command line options, HexView will be closed. </p>
<p> </p>
<p><b>3.2.25 </b></p>
<p><b>Split blocks (/sb:maxblocksize) </b></p>
<p>This option allows to split a large block into pieces when the original block is too large. Thus, one </p>
<p>block can be splitted into several blocks. This can be helpful if RequestDownload-TransferData-</p>
<p>TransferExit for a large block exceeds the timing constrains (e.g. checksum calculation in </p>
<p>TransferExit for some OEMs). </p>
<p>&lt;maxblocksize&gt; can be given in decimal or hexadecimal with preceeding ‘0x’. </p>
<p> </p>
<p><b>3.2.26 </b></p>
<p><b>Run signature verification (/SVn:keyinfo!signatureinfo) </b></p>
<p>This option provides the ability to check a signature for a given file. </p>
<p>The operation is like the /DPn operation. Whereas /DPn is used to generate a signature </p>
<p>with a private key, /SVn is used to verify the signature with its public key. Thus, you specify </p>
<p>with  the  parameter  typically  the  public  key  information  and  provide  the  signature.  Both </p>
<p>parameters  are  separated  with  the  ‘!’  sign.  Each  keyinfo  and  signature  info  can  be  a </p>
<p>reference to a file. Hexview will take the corresponding information from the file for internal </p>
<p>processing. The keyinfo follows the rule defined with expdatproc (see description of /DP). </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Reference Manual HexView </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 1.12.02 </p>
<p>94 </p>
<p>based on template version 5.1.0 </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Example1: </b></p>
<p>Hexview myfile.xy /SV6:keyfile.txt! SignD_PSS_SHA256.RSA /s </p>
<p>Hexview returns with 0 if the signature calculation was successful, otherwise returns </p>
<p>with a non-zero value. A text info is also placed into the log file. </p>
<p><b> </b></p>
<p><b>Example2: </b></p>
<p>Creating a signature: </p>
<p><i>Hexview test.hex –s -dp28:.\rsakeys_2048.txt </i></p>
<p><i>if ERRORLEVEL 1 GOTO Error </i></p>
<p>Verifying the previously generated signature: </p>
<p><i>Hexview test.hex –s -sv0:.\rsakeys_2048.txt!SignD_RMD160.RSA </i></p>
<p><i>if ERRORLEVEL 1 GOTO Error </i></p>
<p><i> </i></p>
<p><b>Example3: </b></p>
<p>Assuming we have a signed VBF file, Hexview will read the signature from the VBF </p>
<p>and verifies that with its public key. </p>
<p><i>Hexview test.vbf -s -sv6:public_key.pem </i></p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p>Table of the data processing number with the corresponding signature verification number: </p>
<p><b>Generate </b></p>
<p><b>signature </b></p>
<p><b>Verify </b></p>
<p><b>signature </b></p>
<p><b>Operation </b></p>
<p>/DPx </p>
<p>/SVx </p>
<p> </p>
<p>28 </p>
<p>0 </p>
<p>RSA signature (PKCS#1, V1.5) with RIPEMD-160 on data </p>
<p>9 </p>
<p>1 </p>
<p>RSA signature (PKCS#1, V1.5) with RIPEMD-160 on address, length and data </p>
<p>8 </p>
<p>2 </p>
<p>RSA signature (PKCS#1, V1.5) with SHA-1 on data </p>
<p>10 </p>
<p>3 </p>
<p>RSA signature (PKCS#1, V1.5) with SHA-1 on address, length and data </p>
<p>32 </p>
<p>4 </p>
<p>RSA signature (PKCS#1, V1.5) with SHA-256 on data </p>
<p>33 </p>
<p>5 </p>
<p>RSA signature (PKCS#1, V1.5) with SHA-256 on address, length and data </p>
<p>38 </p>
<p>6 </p>
<p>RSA signature (PKCS#1, V2.2/PSS) with SHA-256 on data </p>
<p>39 </p>
<p>7 </p>
<p>RSA signature (PKCS#1, V2.2/PSS) with SHA-256 on address, length and </p>
<p>data </p>
<p>46 </p>
<p>8 </p>
<p>ED25519PH on data </p>
<p>47 </p>
<p>9 </p>
<p>ED25519PH on address, length and data </p>
<p>48 </p>
<p>10 </p>
<p>ED25519PH on hashed data w/ SHA-512 </p>
<p>49 </p>
<p>11 </p>
<p>ED25519PH on hashed address, length and data w/ SHA-512 </p>
<p>Table 3-9:  </p>
<p>Correspondence table of signature generation and verification </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Reference Manual HexView </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 1.12.02 </p>
<p>95 </p>
<p>based on template version 5.1.0 </p>
<p> </p>
<p><b>3.2.27 </b></p>
<p><b>Specify an INI-file for additional parameters (/P:ini-file) </b></p>
<p>Some output control functions require complex parameters that cannot be passed on by </p>
<p>command lines. These output controls reads parameters from the INI-file. By default, if the </p>
<p>/P parameter is not given, HexView will extract the path and file information from the input </p>
<p>file and will search for the same file and location, but with the INI-extension. It will read the </p>
<p>contents from there. However, it could be useful to specify the INI-file explicitly. This is for </p>
<p>example useful, if several output controls shall be used with the same parameters. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>Some export functions from the GUI automatically generates an INI-file with the same </p>
<p>name and path location as the output file, to write these parameters into it. These </p>
<p>values will then automatically taken when reading or converting the file through </p>
<p>commandline. </p>
<p><b> </b></p>
<p><b> </b></p>
<p>The path and filename for the INI-file must follow directly the /P parameter, but separated </p>
<p>either with a colon or an Equal sign. No blank character is allowed for separation or within </p>
<p>the file and path name (or use double quotes to specify such file and path names). </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Example </b></p>
<p><b>/P:testfile.ini </b></p>
<p>HexView will read the data from the path of the input file. If no explicit path is used for </p>
<p>the input file, HexView will search for the file in its current path. </p>
<p><b>/P=c:\testpath\testfile.ini </b></p>
<p>HexView reads the INI-file from the specified path and filename. </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>3.2.28 </b></p>
<p><b>Remapping address information (/remap) </b></p>
<p>The remap option is used to shift the start address of block. This can be useful to remap </p>
<p>several address blocks from physical to logical addresses. A use-case for that is the re-</p>
<p>mapping of address spaces in banked mode to a contiguous linear address space2. </p>
<p>                                            </p>
<p>2</p>
<p>  Such  linear  address  spaces  are  also  called  „virtual“  addresses,  because  the  address  itself  does  cannot </p>
<p>directly used for a read operation on the micro. An address calculation of the virtual address is necessary to </p>
<p>split it to a banked and a physical address.  </p>
<h1 style="page-break-before:always; "></h1>
<p>Reference Manual HexView </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 1.12.02 </p>
<p>96 </p>
<p>based on template version 5.1.0 </p>
<p> </p>
<p>Figure 3-6: </p>
<p>Mapping pysical to linear address spaces </p>
<p>The parameters to this option are as follows: </p>
<p><b>/remap:BankStartAddress-BankEndAddress,LinearBaseAddress,BankSize,BankIncrement </b></p>
<p>Figure 3-6 gives a reference to the parameters of the memory map. The BankStartAddress </p>
<p>and  BankEndAddress  spans  a  range  of  the  memory  region,  where  the  remap  shall  be </p>
<p>applied to. The LinearBaseAddress is the base address, where the first BankStartAddress </p>
<p>shall be mapped to. The BankSize is the maximum size of a block that shall be remapped </p>
<p>and the BankIncrement is the difference of address between two banks, e.g. the difference </p>
<p>between BankStartAddress of bank #1 and BankStartAddress of bank #2. </p>
<p>Please note, that just blocks can be remapped, that fits within the BankStartAddress and </p>
<p>BankEndAddress or multiples of BankIncrement. That is to say, only blocks with maximum </p>
<p>size  of  BankSize  can  be  remapped. A  continuous  block  section  cannot  be  splitted  and </p>
<p>remapped into linear addresses (this is not necessary. In that case, only the whole base </p>
<p>address of a block may be shifted). </p>
<p>The following example shows, how address shift operations are applied: </p>
<p>Assuming, the input file contains the following data sections: </p>
<p>Non-Banked addresses from 0x0000 – 0x7FFF. </p>
<p>Banked addresses:  0x018000-0x01BFFF; 0x028000-0x02BFFF. </p>
<p>In  this  example,  the  address  mapping  consists  of  a  non-banked  section  and  two  bank </p>
<p>sections. The bank numbers are 0x01 and 0x02. The physical bank addresses are from </p>
<p>0x8000-0xBFFF.  The bank size is 0x4000. </p>
<p>Bank no. </p>
<p>#1</p>
<p>Bank start </p>
<p>address</p>
<p>Bank end </p>
<p>address</p>
<p>Bank no. </p>
<p>#2</p>
<p>Bank no. </p>
<p>#3</p>
<p>Physical address space</p>
<p>Virtual, linear address space</p>
<p>Non-</p>
<p>banked </p>
<p>section #1</p>
<p>Non-</p>
<p>banked </p>
<p>section #2</p>
<p>Bank no. </p>
<p>#1</p>
<p>Bank no. </p>
<p>#2</p>
<p>Bank no. </p>
<p>#3</p>
<p>„Peep-</p>
<p>Hole“</p>
<p>Linear base </p>
<p>address</p>
<p>Bank size</p>
<p>Non-</p>
<p>banked </p>
<p>section #2</p>
<p>Non-</p>
<p>banked </p>
<p>section #1</p>
<h1 style="page-break-before:always; "></h1>
<p>Reference Manual HexView </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 1.12.02 </p>
<p>97 </p>
<p>based on template version 5.1.0 </p>
<p>The following option will remap the addresses to a linear address space: </p>
<p> </p>
<p> </p>
<p>/remap:0x018000-0x02BFFF,0x008000,0x4000,0x010000 </p>
<p>This remaps the address space in the example above to 0x0000-0xFFFF.  </p>
<p><b>3.2.29 </b></p>
<p><b>Write version string to error log file (/v) </b></p>
<p>The Hexview version string is written to the error log file. </p>
<p>Note  that  you  also  need  to  specify  the  /E:&lt;filename&gt;  option  in  combination  to  see  the </p>
<p>string in this file. </p>
<p>Version string: “Hexview V1.09.02” </p>
<p><b>3.2.30 </b></p>
<p><b>Create validation structure (/vs) </b></p>
<p>This  item  is  used  to  create  an  information  structure  intended  to  be  used  for  application </p>
<p>validation. It is typically used for flash download systems where it is difficult or impossible </p>
<p>to determine if all elements necessary for a download are available and complete. </p>
<p>There are some flash download procedures, where it is impossible to verify if the download </p>
<p>is  completed.  For  example,  if  partial  download  is  used  without  an  information  in  the </p>
<p>download procedure, where the complete download can be verified, or where a download </p>
<p>can be interrupted at a certain state that appears like a completed download. </p>
<p>For  a  successful  usage  of  the  validation  structure,  it  is  necessary,  some  important </p>
<p>precautions  must  be  considered.  To  use  the  structure  it  is  necessary  to  be  able  to  re-</p>
<p>program it with every download, even if it is just a partial download. Before the validation </p>
<p>structure  itself  can  be  used,  it  is  necessary  to  determine  if  the  validation  structure  is </p>
<p>present and complete. There are three options that can be used in combination to verify if </p>
<p>the structure is complete. A magic value at the beginning and the end can be added to the </p>
<p>structure In addition, a simple byte checksum can be inserted that is added at the very end </p>
<p>to the structure. </p>
<p>The key information for the validation is the block structure containing the segment start </p>
<p>address and length for each segment or block. The data information is not only (and not </p>
<p>necessarily) taken from the internal data but also from external files. A list of files can be </p>
<p>provided  in  the  list  box. An  optional  checksum  per  block  can  be  added. The  checksum </p>
<p>method can be chosen from the available checksum methods from EXPDATPROC.DLL. </p>
<p>Instead or in addition to the block checksum a total checksum that is calculated over all </p>
<p>segment and block data can be added. The total checksum method can be different from </p>
<p>the block checksum. </p>
<p>The  resulting  data  structure  can now  generated  in  two  ways,  or even  in  both  if  wanted. </p>
<p>First, a C-structure can be generated that can be compiled and linked together with your </p>
<p>program data.  If  the  data don’t  change,  the resulting  HEX-files  should be  the  same  just </p>
<p>with the additional structure added to the HEX-file. A header-file may helps you to access </p>
<p>the data structure during the validation method. </p>
<p>A second method is to insert the data directly into the HEX-data file. Since 16-bit or 32-Bit </p>
<p>values are generated, it is important to select if the CPU uses little- or big-endian format. </p>
<p>The 16- and 32-Bit values will be generated according to the selected option. </p>
<p>When  using  this commandline option, all  parameters will  be  taken from  the  INI-file  (see </p>
<p>section 3.2.26). The contents of the INI-file has the following parameters: </p>
<p>[VALIDATION] </p>
<h1 style="page-break-before:always; "></h1>
<p>Reference Manual HexView </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 1.12.02 </p>
<p>98 </p>
<p>based on template version 5.1.0 </p>
<p>GenerateCFiles=1  ; 0=no, 1=yes </p>
<p>InsertData=1 </p>
<p>CFilename=D:\uti\_page3a.c </p>
<p>HFilename=D:\uti\_page3a.h </p>
<p>BlockChecksumType=0 </p>
<p>FileChecksumType=9 </p>
<p>ValidateChecksum=1 </p>
<p>IdTagBegin=0x1234 </p>
<p>IdTagEnd=0x4321 </p>
<p>BaseAddress=0x10000 </p>
<p>SpareRange= </p>
<p>EndianType=0 </p>
<p>Force32BitFormat=0 ; 0=Not force, 1=force. </p>
<p>IdTagBeginLength=2 </p>
<p>IdTagEndLength=2 </p>
<p> </p>
<p>See section 2.2.2.13: “Generate file validation structure” for further information. </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>Some changes were made to Hexview V1.10.  </p>
<p>The validation structure is added as a separate block into the block chain list of the </p>
<p>hexfiles. Before that, it was merged into the file. Thus, the validation structure always </p>
<p>appears as a separate block even if the preceeding block ends at the start address of </p>
<p>the validation structure. Re-Reading the file will merge the blocks. </p>
<p>IDtags are added as is, e.g. a value of 001A will be added as 2-byte value. </p>
<p>Address/length values can be forced as 4-byte values. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Info </b></p>
<p>A validation structure can automatically be generated when exporting a VBF file. No </p>
<p>separate validation structure generation is needed. There is also no need to create a </p>
<p>separate [validation] section in the INI file. See VBF export for more details (see </p>
<p>chapter 3.3.5). </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p> </p>
<p><b>3.3 </b></p>
<p><b>Output-control command line options (/Xx) </b></p>
<p>The  following  chapter  describes  the  options  used  to  control  the  output  generator  of </p>
<p>HexView. Note that only one output can be generated per execution. That is, you cannot </p>
<p>combine several output generator options (/X..) in one command line call of HexView. </p>
<p>The  output  control  is  used  to  generate  a  file  in  a  specific  output  format.  Some  of  the </p>
<p>formats correspond to a file format used for flash download in the OEM specific download </p>
<h1 style="page-break-before:always; "></h1>
<p>Reference Manual HexView </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 1.12.02 </p>
<p>99 </p>
<p>based on template version 5.1.0 </p>
<p>process. Therefore, the output control is named in combination with a car manufacturer’s </p>
<p>brand name. </p>
<p><b>3.3.1 </b></p>
<p><b>Output of HEX ASCII data (/XA[:linelen[:separator]]) </b></p>
<p>This option provides the possibility to output the data into a file as HEX ASCII. </p>
<p>There are two optional parameters to control the output. The first option is the length of the </p>
<p>output line. The second option is the separator between bytes within a line. Each option </p>
<p>will  be  separated  by  a  semicolon. The  line  number  always  comes  first,  followed  by  the </p>
<p>separator. If you want to use spaces for the separator, you need to use doublequotes. The </p>
<p>separator is only placed between two HEX values within a line, not at the beginning or end </p>
<p>of it. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Example #1 </b></p>
<p>Output HEX ASCII as a number of HEX strings </p>
<p>.   /XA:32 </p>
<p>  0102030405060708090A0B0C0D0E0F10 </p>
<p>  1112131415161718191A1B1C1D1E1F20 </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Example #2 </b></p>
<p>Output HEX ASCII in a formatted string using the separator. </p>
<p>  /XA:32:”, “ </p>
<p>  01, 02, 03, 04, 05, 06, 07, 08, 09, 0A, 0B, 0C, 0D, 0E, 0F, 10 </p>
<p>  11, 12, 13, 14, 15, 16, 17, 18, 19, 1A, 1B, 1C, 1D, 1E, 1F, 20 </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>3.3.2 </b></p>
<p><b>Output a Fiat specific data file (/XB) </b></p>
<p>This option commands to create the BIN- and PRM file used for the Fiat specific download. </p>
<p>The  format  of  the  file  will  not  described  here,  but  can  be  found  in  the  Fiat  specific </p>
<p>documentations (07284-01). Refer also to section 2.2.1.9.9. </p>
<p>The Fiat file contains a number of parameters. These parameters are too complex to pass </p>
<p>them all through command line options. Therefore, HexView reads this information from an </p>
<p>INI-file. This INI-file can either be specified explicitly with the command line option /P (see </p>
<p>section  3.2.26)  or  will  use  the  filename  of  the  input  file,  but  with  the  file  extension  ‘.INI’ </p>
<p>(same location of INI as the HEX-file). </p>
<p>The base address and length of the erase sections within the parameter file fields will be </p>
<p>aligned with the erase alignment value. See sections 2.2.2.4 and 3.2.3 on how to specify </p>
<p>this value. </p>
<p>The following table shows the options for the INI-File used with the Fiat output. </p>
<p><b> </b></p>
<p><b> </b></p>
<p>HFIType=4 </p>
<p>HFIType: Header Format Identifier. Should be </p>
<p>4 for 07209 or 2 for 07274 </p>
<h1 style="page-break-before:always; "></h1>
<p>Reference Manual HexView </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 1.12.02 </p>
<p>100 </p>
<p>based on template version 5.1.0 </p>
<p><b> </b></p>
<p><b> </b></p>
<p>DownloadMethod=0 </p>
<p>DownloadMethod or Fingerprint (FPM):  </p>
<p>0=all Fingerprints,  </p>
<p>1=Prog+Data,  </p>
<p>2=Prog-only </p>
<p>ChecksumMethod=1 </p>
<p>ChecksumMethod:  </p>
<p>0=Files and Segments,  </p>
<p>1=File only </p>
<p>ChecksumType=1 </p>
<p>ChecksumType=Type of Checksum </p>
<p>calculation. Same paramter value as in </p>
<p>section 3.2.10 resp. 2.2.2.6. </p>
<p>ECUAddress=0x20 </p>
<p> </p>
<p>TesterAddress=0xf1 </p>
<p> </p>
<p>TesterCanID=0x18DA20F1 </p>
<p> </p>
<p>EcuCanID=0x18DAF120 </p>
<p> </p>
<p>TypeOfSeedKey=0 </p>
<p> </p>
<p>AccessMethod=0 </p>
<p> </p>
<p>AccessParameter=0 </p>
<p> </p>
<p>ReqDLMethod=0 </p>
<p> </p>
<p>ReqDLType=0 </p>
<p> </p>
<p>P2Min=5 </p>
<p> </p>
<p>P2Max=2 </p>
<p> </p>
<p>P3Min=1 </p>
<p> </p>
<p>P3Max=20 </p>
<p> </p>
<p>P4=0 </p>
<p> </p>
<p>AddressLengthSize </p>
<p>The size for the used addresses and length of </p>
<p>the segment information in the parameter file.  </p>
<p>The default value is 0x33, which denotes, that </p>
<p>3-bytes will be used for address and length </p>
<p>values. </p>
<p>ReqDLParam </p>
<p>The parameter to the data processing </p>
<p>algorithm. See “Data Processing” chapter for </p>
<p>more information. </p>
<p>UseParialDownload </p>
<p>This flag is set to 1 if a partial download </p>
<p>parameter file shall be generated. The partial </p>
<p>download is used if the binary data file </p>
<p>consists of the application and data file. In this </p>
<p>case, the partial download extracts the </p>
<p>parameter file info for the data section only. A </p>
<p>data range must be specified for the data field. </p>
<p>PartialRange </p>
<p>This is the range for the data field if the binary </p>
<p>download is used for application and data. It’ll </p>
<p>be used to generate a separate parameter file </p>
<p>that specifies only the data section within the </p>
<p>combined binary section. </p>
<h1 style="page-break-before:always; "></h1>
<p>Reference Manual HexView </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 1.12.02 </p>
<p>101 </p>
<p>based on template version 5.1.0 </p>
<p><b> </b></p>
<p><b> </b></p>
<p>PartialPrmFile </p>
<p>Specifies the separate parameterfile that will </p>
<p>be generated if partial download is used. </p>
<p>Table 3-10  </p>
<p>INI-file information fort he Fiat file container generation </p>
<p><b>3.3.3 </b></p>
<p><b>Output data into C-Code array (/XC) </b></p>
<p>This  option  allows  to  create  arrays  in  a  C-language.  This  allows  to  compile  and  link </p>
<p>complex  data  packets  with  a  program.  This  option  directly  reflects  the  GUI-option  in </p>
<p>section 2.2.1.9.4. </p>
<p>The  parameter for this  output  can  also  controlled  by  an  INI-file  (for INI-file  rule,  refer to </p>
<p>section 3.2.26). </p>
<p>The following list shows the options of the INI-file for this output: </p>
<p><b> </b></p>
<p><b> </b></p>
<p>Decryption=0 </p>
<p>Option: </p>
<p>0=Off,   </p>
<p>1=On </p>
<p>Decryptvalue=0xCC    </p>
<p>Value for encryption using XOR with each </p>
<p>uchar/ushort/ulong </p>
<p>Prefix=flashDrv </p>
<p> </p>
<p>WordSize=0   </p>
<p>0=uchar,  </p>
<p>1=ushort,  </p>
<p>2=ulong </p>
<p>WordType=0   </p>
<p>Only used if WordSize &gt; 0. </p>
<p>0=Intel,  </p>
<p>1=Motorola  </p>
<p>Table 3-11  </p>
<p>INI-File definition fort he C-Code array export function </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Example </b></p>
<p><b>HexView test.dat /XC </b></p>
<p>Reads data from test.dat as Intel-HEX or S-Record and outputs to test.c/test.h. Tries to </p>
<p>read the INI-Info from test.ini in the same folder where test.dat is located. </p>
<p><b>HexView /XC test.dat /P:myini.ini –o outfile.c </b></p>
<p>Reads the data from test.dat and the parameter from myini.ini and outputs the file </p>
<p>outfile.c/outfile.h. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>3.3.4 </b></p>
<p><b>Output Ford files in Intel-HEX format (/XF) </b></p>
<p>The Ford files in Intel-HEX format consist of a header with some Ford specific information </p>
<p>and the data itself in Intel-HEX format. The header has the following format: </p>
<h1 style="page-break-before:always; "></h1>
<p>Reference Manual HexView </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 1.12.02 </p>
<p>102 </p>
<p>based on template version 5.1.0 </p>
<p>APPLICATION&gt;FORD FNOS-DemoIL </p>
<p>MASK NUMBER&gt;7 or later </p>
<p>FILE NAME&gt;APPL.hex </p>
<p>RELEASE DATE&gt;10/05/2001 </p>
<p>MODULE TYPE&gt;Restraint Control Module </p>
<p>PRODUCTION MODULE PART NUMBER&gt;XL5A-14B321-AA </p>
<p>WERS NOTICE&gt;DE00E10757919001 </p>
<p>COMMENTS&gt;Any comments can be entered here. </p>
<p>RELEASED BY&gt;John Smith </p>
<p>MODULE NAME&gt;RESTRAINTS CONTROL MODULE </p>
<p>MODULE ID&gt;0x7B0 </p>
<p>DOWNLOAD FORMAT&gt;0x01 </p>
<p>FILE CHECKSUM&gt;0xBF76 </p>
<p>FLASH INDICATOR&gt;1 </p>
<p>FLASH ERASE </p>
<p>SECTORS&gt;:0xFC0002,0x5716:0xFF9D00,0xC:0xFF9F54,0x8C:0xFF9F54,0x8C </p>
<p>$ </p>
<p>:0200000400FCFE </p>
<p>:2000020011AA0001230000BC614E4141000AFFFFFFFFFFFFFFFFFFFFFFFFFFFFF</p>
<p>FFFFFFF1A </p>
<p>… </p>
<p>The whole file format can be written by HexView. The only information that HexView needs </p>
<p>in addition to the data itself are the parameters for the header shown above. </p>
<p>Some  information  can  be  generated  automatically  by  the  tool.  Further  information  is </p>
<p>necessary and will be given by the INI-file parameter. The parameters from the INI-file are </p>
<p>controlled according to the INI parameter rule (see section 3.2.26). </p>
<p>The base address and length of the erase sections in the “flash erase sections” field will be </p>
<p>aligned with the erase alignment value. See sections 2.2.2.4 and 3.2.3 on how to specify </p>
<p>this value. </p>
<p>The following table shows the INI-information: </p>
<p><b>[FORDHEADER]</b></p>
<p><b> </b></p>
<p><b> </b></p>
<p>APPLICATION=FORD FNOS-DemoIL </p>
<p>Mandatory text field </p>
<p>MASK NUMBER=7 or later </p>
<p>Mandatory text field </p>
<p>FILE NAME=APPL.hex </p>
<p>Optional If omitted, the file-output name will be </p>
<p>used. Otherwise, the text field paramter is used. </p>
<p>RELEASE DATE=10/05/2001 </p>
<p>If omitted, the current PC-date will be used. </p>
<p>Otherwise, if specified, the textfield will be used. </p>
<p>MODULE TYPE=Restraint Control Module </p>
<p>Mandatory text field </p>
<p>PRODUCTION MODULE PART NUMBER=XL5A-</p>
<p>14B321-AA </p>
<p>Mandatory text field </p>
<p>WERS NOTICE=DE00E10757919001 </p>
<p>Mandatory text field </p>
<p>COMMENTS=Henrys header for flashdata </p>
<p>Mandatory text field </p>
<p>RELEASED BY=John Smith </p>
<p>Mandatory text field </p>
<p>MODULE NAME=RESTRAINTS CONTROL </p>
<p>MODULE </p>
<p>Mandatory text field </p>
<h1 style="page-break-before:always; "></h1>
<p>Reference Manual HexView </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 1.12.02 </p>
<p>103 </p>
<p>based on template version 5.1.0 </p>
<p><b>[FORDHEADER]</b></p>
<p><b> </b></p>
<p><b> </b></p>
<p>MODULE ID=0x7B0 </p>
<p>Mandatory text field </p>
<p>DOWNLOAD FORMAT=0x01 </p>
<p>Specifies the download method: </p>
<p>0: Download Application file </p>
<p>1: Download SBL </p>
<p>;FILE CHECKSUM=0x0A33 </p>
<p>Will be generated by HexView. This is a byte </p>
<p>sum of the data in the datafield. </p>
<p>FLASH INDICATOR=1 </p>
<p>0: for Flashdriver aka. SBL, </p>
<p>1: for normal file download </p>
<p>Note: Writes 0 if paramter is omitted. </p>
<p>;FLASH ERASE </p>
<p>SECTORS=:0xF0000,0x4000:0xF4000,0x4000:0x</p>
<p>F8000,0x4000:0xFC000,0x4000:0xFD800,0x0400 </p>
<p>Can be given as a textual information. If omitted, </p>
<p>the block sections will be listed. This can be </p>
<p>used with GGDS and I3 to specify the erase </p>
<p>values (Note: for I3 und GGDS, usually the VBF-</p>
<p>format is used). </p>
<p> </p>
<p>In 14230/KWP2000, the Erase indicator must be </p>
<p>given here.   </p>
<p>0: Erase all </p>
<p>1: Any erase section numbers </p>
<p>1,3,5: erase section number as a list. </p>
<p>Table 3-12  </p>
<p>INI-file description for Ford I-Hex file generation </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Reference Manual HexView </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 1.12.02 </p>
<p>104 </p>
<p>based on template version 5.1.0 </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Example 1 </b></p>
<p>Output an application file for FNOS 101 (KWP2000 based): </p>
<p>    </p>
<p>HexView /FR:0x4000,0x200 /XF /P:test.ini /AD2 /AL –o demo_fill1.hex </p>
<p>INI File contents of test.ini: </p>
<p>[FORDHEADER] </p>
<p>APPLICATION=FORD FNOS-Demo DemoAppl, adapted for Bootloader </p>
<p>MASK NUMBER=Must be adapted by TIER I </p>
<p>;FILE NAME=appl.hex  ; Will be filled out automatically if not </p>
<p>present. </p>
<p>;RELEASE DATE=02/18/2005 ; dto. </p>
<p>MODULE TYPE=Demo Software </p>
<p>PRODUCTION MODULE PART NUMBER=XL5A-14B321-AA </p>
<p>WERS NOTICE=DE00E10757919001 </p>
<p>COMMENTS=This is just an example software </p>
<p>RELEASED BY=John Smith </p>
<p>MODULE NAME=Test software </p>
<p>MODULE ID=0x7B0 </p>
<p>DOWNLOAD FORMAT=0x00 </p>
<p>;FILE CHECKSUM=0x0A33  ; dto. </p>
<p>FLASH INDICATOR=1 </p>
<p>FLASH ERASE SECTORS=0 </p>
<p> </p>
<p>HEX file output: </p>
<p>APPLICATION&gt;FORD FNOS-Demo DemoAppl, adapted for Bootloader </p>
<p>MASK NUMBER&gt;Must be adapted by TIER I </p>
<p>FILE NAME&gt;Demo_Fill1_f.hex </p>
<p>RELEASE DATE=17/02/2004 </p>
<p>MODULE TYPE&gt;Demo Software </p>
<p>PRODUCTION MODULE PART NUMBER&gt;XL5A-14B321-AA </p>
<p>WERS NOTICE&gt;DE00E10757919001 </p>
<p>COMMENTS&gt;This is just an example software </p>
<p>RELEASED BY&gt; John Smith </p>
<p>MODULE NAME&gt;Test software </p>
<p>MODULE ID&gt;0x7B0 </p>
<p>DOWNLOAD FORMAT&gt;0x00 </p>
<p>FILE CHECKSUM&gt;0x1BFB </p>
<p>FLASH INDICATOR&gt;1 </p>
<p>FLASH ERASE SECTORS&gt;0 </p>
<p>$ </p>
<p>:02000004000EEC </p>
<p>:20000000E25C9D40D6874BEAFAF1C7824BF70FE1CAE157397509A05577408C229C6D7</p>
<p>16FD1</p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Reference Manual HexView </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 1.12.02 </p>
<p>105 </p>
<p>based on template version 5.1.0 </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Example 2 </b></p>
<p>Output an SBL aka. Flashdriver file: </p>
<p>    </p>
<p>HexView flash_s12.hex /XF /P:flashdrv.ini /FA </p>
<p>INI File contents of flashdrv.ini: </p>
<p>[FORDHEADER] </p>
<p>APPLICATION=FORD FNOS-Secondary Bootloader </p>
<p>MASK NUMBER=Must be adapted by TIER I </p>
<p>;FILE NAME=Flash_S12.hex  ; Will be filled out automatically if </p>
<p>not present. </p>
<p>;RELEASE DATE=02/18/2005 </p>
<p>MODULE TYPE=Restraint Control Module </p>
<p>PRODUCTION MODULE PART NUMBER=XL5A-14B321-AA </p>
<p>WERS NOTICE=DE00E10757919001 </p>
<p>COMMENTS=Henrys header for flashdata </p>
<p>RELEASED BY=Armin Happel </p>
<p>MODULE NAME=RESTRAINTS CONTROL MODULE </p>
<p>MODULE ID=0x7B0 </p>
<p>DOWNLOAD FORMAT=0x01 </p>
<p>;FILE CHECKSUM=0x0A33 </p>
<p>;FLASH INDICATOR=1 Set to 0 if not present </p>
<p>FLASH ERASE SECTORS= </p>
<p> </p>
<p>HEX file output: </p>
<p>APPLICATION&gt;FORD FNOS-Secondary Bootloader </p>
<p>MASK NUMBER&gt;Must be adapted by TIER I </p>
<p>FILE NAME&gt;Flash_S12_f.hex </p>
<p>RELEASE DATE=17/02/2004 </p>
<p>MODULE TYPE&gt;Restraint Control Module </p>
<p>PRODUCTION MODULE PART NUMBER&gt;XL5A-14B321-AA </p>
<p>WERS NOTICE&gt;DE00E10757919001 </p>
<p>COMMENTS&gt;Henrys header for flashdata </p>
<p>RELEASED BY&gt;Armin Happel </p>
<p>MODULE NAME&gt;RESTRAINTS CONTROL MODULE </p>
<p>MODULE ID&gt;0x7B0 </p>
<p>DOWNLOAD FORMAT&gt;0x01 </p>
<p>FILE CHECKSUM&gt;0x0A01 </p>
<p>FLASH INDICATOR&gt;0 </p>
<p>FLASH ERASE SECTORS&gt;:0x0,0x480 </p>
<p>$ </p>
<p>:200000000B00021202DF02D8036E02976CADB745EEE018B746EDE81AC60E15FA04306</p>
<p>B8211</p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>3.3.5 </b></p>
<p><b>Output Files in VBF format (/XVBF) </b></p>
<p>The VBF file format was introduced in the Ford Group when JLR (Jaguar, Landrover) and </p>
<p>Volvo Cars were also member of this group. They were using the VBF version 2.2 to 2.4 in </p>
<p>common. After they have become independent, the three groups are still using VBF files </p>
<p>but in different versions. Hexview supports all currently know versions and can distinguish </p>
<p>the different formats by its version. The following table gives an overview of the currently </p>
<p>known versions to the associated groups: </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Reference Manual HexView </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 1.12.02 </p>
<p>106 </p>
<p>based on template version 5.1.0 </p>
<p><b>VBF version </b></p>
<p><b>Associated company </b></p>
<p>2.2, 2.3, 2.4 </p>
<p>Ford, JLR, VolvoCars </p>
<p>2.5, 2.6 </p>
<p>VolvoCars </p>
<p>3.0, 3.1 </p>
<p>Ford </p>
<p>JLR3.0 </p>
<p>JLR </p>
<p>Table 3-13:   VBF versions known by Hexview and associated companies </p>
<p>Hexview shows the detected VBF OEM format of the currently loaded VBF in the lower </p>
<p>right corner. The VBF file format is generated  when exporting it using the /XVBF output </p>
<p>format option. The VBF requires additional information that is provided through an INI-file.  </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>Due to the wide variety of options in different formats, the GUI export dialog will only </p>
<p>support all parameters up to VBF V2.4. Even though the different VBF versions can be </p>
<p>specified in the dialog, not all VBF parameters are editable in the dialog. </p>
<p>When exporting through the GUI, Hexview writes currently available parameters into </p>
<p>the currently active INI-File. This can be used as a reference to further edit and extend </p>
<p>the INI file. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p>A  validation  or  verification  structure  can  be  useful  or  is  even  mandatory  for  some  VBF </p>
<p>versions.  Therefore,  Hexview  can  or </p>
<p>will  generate  such  a  structure </p>
<p>automatically  if </p>
<p>necessary parameter are provided in the [VBFHEADER] section of the INI-file. Mainly, the </p>
<p>VS_ADDRESS value is needed here along with the BlockChecksumType as listed in the </p>
<p>table below. Other parameters described in section 3.2.30 can be useful here as well and </p>
<p>will be accepted even if they appear in the [VBFHEADER] section. </p>
<p>The values for ERASE_ADDRESS and ERASE_LENGTH will be aligned with the erase </p>
<p>alignment value in a way that erase address and length are a multiple of this parameter. </p>
<p>See sections 2.2.2.4 and 3.2.3 describes on how to specify this value.  </p>
<p>Options  and  data  generation  is  also </p>
<p>controlled  by  an  INI-file.  The  following  INI-file </p>
<p>parameters are used to control the output: </p>
<p><b>[VBFHEADER]</b></p>
<p><b> </b></p>
<p><b>Support </b></p>
<p><b>in VBF </b></p>
<p><b> </b></p>
<p>VBF_VERSION=2.2 </p>
<p>All </p>
<p>Possible values are 2.2, 2.3, 2.4, 2.5, 2.6, </p>
<p>3.0, 3.1 or JLR3.0 (see reference </p>
<p>Table </p>
<p>3-13</p>
<p>). </p>
<p>SW_PART_NUMBER=12345678            *) </p>
<p>All </p>
<p>Part-number. Any arbitrary text string. </p>
<p>SW_PART_TYPE=EXE </p>
<p>All </p>
<p>Software part type can be: </p>
<p>EXE, DATA, GBL, CAFCFG, CUSTOM, </p>
<p>SIGCFG, TEST </p>
<p>SW_CALL_ADDRESS </p>
<p>All </p>
<p>Only used if SW_PART_TYPE=SBL or TEST. </p>
<p>When SW_PART_TYPE is SBL, the call </p>
<p>address is mandatory. </p>
<h1 style="page-break-before:always; "></h1>
<p>Reference Manual HexView </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 1.12.02 </p>
<p>107 </p>
<p>based on template version 5.1.0 </p>
<p><b>[VBFHEADER]</b></p>
<p><b> </b></p>
<p><b>Support </b></p>
<p><b>in VBF </b></p>
<p><b> </b></p>
<p>SW_VERSION </p>
<p>2.5, 2.6 </p>
<p>The software version.  </p>
<p>FRAME_FORMAT=CAN_STANDARD </p>
<p>2.2, 2.3, </p>
<p>2.4, 3.0, </p>
<p>3.1, </p>
<p>JLR3.0 </p>
<p>FRAME Format can be: </p>
<p>CAN_STANDARD, CAN_EXTENDED or </p>
<p>16BIT_STANDARD </p>
<p>(16BIT_STANDARD is not allowed in all </p>
<p>versions, Hexview doesn’t check if it is </p>
<p>allowed in the version or not). </p>
<p>DESCRIPTION1=This is the demo </p>
<p>application for                            *) </p>
<p>All </p>
<p>Description field, part #1.  </p>
<p>DESCRIPTION2=the FJ16LX FBL-Ford </p>
<p>FNOS-I3.                                    *) </p>
<p>All </p>
<p>Description field, part #2 </p>
<p>NETWORK=CAN_MS                *) </p>
<p>2.2, 2.3, </p>
<p>2.4, </p>
<p>JLR3.0 </p>
<p>Network parameter. Can be: </p>
<p>CAN_HS, CAN_MS, SUB_MOST, </p>
<p>SUB_CAN1, SUB_CAN2, SUB_LIN1, </p>
<p>SUB_LIN2, SUB_OTHER </p>
<p>ECU_ADDRESS=0x7E0             *) </p>
<p>All </p>
<p>ECU-Address </p>
<p>ERASE_LIST_GEN_MODE </p>
<p>All </p>
<p>This specifies how the erase table shall be </p>
<p>generated: </p>
<p>0 = Generate no erase table </p>
<p>1 = AUTO. Each segment of the input file will </p>
<p>correspond to an address range. The values </p>
<p>can be aligned to a multiple of a factor given </p>
<p>with the /AE parameter. This is useful to let </p>
<p>Hexview generate automatically the erase </p>
<p>table. </p>
<p>2 = Manual: You must specify erase address </p>
<p>and length value in this INI file (see below)! </p>
<p>ERASE_ADDRESS                    *) </p>
<p> </p>
<p>All </p>
<p>Erase address and length information. This </p>
<p>parameter is not allowed if </p>
<p>SW_PART_TYPE=SBL. </p>
<p> </p>
<p>ERASE_LENGTH                       *) </p>
<p> </p>
<p>All </p>
<p>See ERASE_ADDRESS. </p>
<p>DATA_FORMAT_ID </p>
<p>&gt;= 2.4  </p>
<p>Data format identifier. </p>
<p>DATPROC_PARAM </p>
<p>&gt;= 2.4 </p>
<p>Data processing parameter. Normally empty </p>
<p>if no data processing or just data </p>
<p>compression is used. </p>
<p>DATPROC_METHOD </p>
<p>&gt;= 2.4 </p>
<p>ID of the data processing method (see </p>
<p>chapter 3.2.11). </p>
<p>DATPROC_PARAM </p>
<p>&gt;= 2.4 </p>
<p>Data processing parameter. Normally empty </p>
<p>if no data processing or just data </p>
<p>compression is used. </p>
<p>DATPROC_METHOD </p>
<p>&gt;= 2.4 </p>
<p>ID of the data processing method (see </p>
<p>chapter 3.2.11). </p>
<p>DATPROC_METHOD2 </p>
<p>&gt;= 2.4 </p>
<p>If you need to chain two data processing </p>
<p>operations, the second operation can be </p>
<p>specified with this parameter. For example, if </p>
<h1 style="page-break-before:always; "></h1>
<p>Reference Manual HexView </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 1.12.02 </p>
<p>108 </p>
<p>based on template version 5.1.0 </p>
<p><b>[VBFHEADER]</b></p>
<p><b> </b></p>
<p><b>Support </b></p>
<p><b>in VBF </b></p>
<p><b> </b></p>
<p>you want to first compress and then encrypt </p>
<p>data, this second operation need to be used. </p>
<p>DATPROC_PARAM2 </p>
<p>&gt;= 2.4 </p>
<p>The parameter for the second data </p>
<p>processing operation if necessary. </p>
<p>SIGNATURE_METHOD </p>
<p>2.6, 3.1 </p>
<p>Specifies the method to calculate the </p>
<p>signature. A signature parameter </p>
<p>(SIGNATURE_PARAM) is required if </p>
<p>specified as the private key. </p>
<p>SIGNATURE_PARAM=private_key.pem </p>
<p>2.6, 3.1 </p>
<p>The parameter for the signature generation. </p>
<p>This is typically the private key in PEM </p>
<p>format (use unencrypted PEM keys only!). </p>
<p>HIS key format is also accepted (see chapter </p>
<p>3.2.11). </p>
<p>CSUM_TABLE_STARTADDRESS           *) </p>
<p>2.2, 2.3, </p>
<p>JLR3.0 </p>
<p>Checksum table in the VBF header </p>
<p>CSUM_TABLE_STOPADDRESS             *) </p>
<p>2.2, 2.3, </p>
<p>JLR3.0 </p>
<p>See above. </p>
<p>CSUM_TABLE_CSUM                             *) </p>
<p>2.2, 2.3, </p>
<p>JLR3.0 </p>
<p>The checksum value for the address range. </p>
<p>OMIT_ADDRESS                                     *) </p>
<p>2.3, 2.4,  </p>
<p>3.0, 3.1, </p>
<p>JLR3.0 </p>
<p>Values for the omit values in the VBF header. </p>
<p>OMIT_LENGTH                                        *) </p>
<p>2.3, 2.4, </p>
<p>3.0, 3.1, </p>
<p>JLR3.0 </p>
<p>The length for the corresponding omit </p>
<p>address value. </p>
<p>VS_ADDRESS </p>
<p>2.6, 3.1  </p>
<p>Validation resp verification structure address </p>
<p>IdTagBegin=0001 </p>
<p>All </p>
<p>This is a value written to the validation </p>
<p>structure. It specifies the beginning of it. </p>
<p>Force32BitFormat=1 </p>
<p>All </p>
<p>This value is required. All address and length </p>
<p>values are handled as 32-bit for the </p>
<p>validation structure. </p>
<p>BlockChecksumType </p>
<p>All </p>
<p>If a validation structure address is present, </p>
<p>this value specifies which checksum method </p>
<p>shall be used to generate a block checksum </p>
<p>in the validation (or verification) structure. </p>
<p>PUBLIC_KEY_HASH </p>
<p>3.1 </p>
<p>The value for the public key hash. Not used </p>
<p>by Hexview. The content is transferred “as is” </p>
<p>from/to the corresponding item of the VBF-</p>
<p>header. </p>
<p>CSUM_METHOD </p>
<p>2.6 </p>
<p>Checksum method ID to calculate the root </p>
<p>hash. </p>
<p>SW_CURRENT_PART_NUMBER            *) </p>
<p>2.6 </p>
<p>Part number(s) </p>
<p>SW_CURRENT_VERSION                       *) </p>
<p>2.6 </p>
<p>Current software version(s) </p>
<p>SW_SIGNATURE_DEV </p>
<p>2.6 </p>
<p>Data processing method ID to calculate the </p>
<p>signature for development.  </p>
<p>SIGNATURE_PARAM_DEV </p>
<p>2.6 </p>
<p>The parameter for the data processing </p>
<p>method ID, namely the reference to the </p>
<h1 style="page-break-before:always; "></h1>
<p>Reference Manual HexView </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 1.12.02 </p>
<p>109 </p>
<p>based on template version 5.1.0 </p>
<p><b>[VBFHEADER]</b></p>
<p><b> </b></p>
<p><b>Support </b></p>
<p><b>in VBF </b></p>
<p><b> </b></p>
<p>development private key. </p>
<p>SW_PART_NUMBER_DID </p>
<p>JLR3.0 </p>
<p>DID to read the software part number. </p>
<p> </p>
<p>Table 3-14  </p>
<p>INI-File description for VBF export configuration </p>
<p>*) The parameters marked with *) can be specified as a single parameter or in a list format. </p>
<p>In the list format, more than one value can be specified for the item. The item name can be </p>
<p>specified multiple times but distinguished with a continuous counter number at the end of </p>
<p>the parameter. The first one starts with ‘1’, e.g. NETWORK1, NETWORK2, are two values </p>
<p>given for the networks. If the iterator name is used, the name without the number will be </p>
<p>ignored (e.g. NETWORK will not be used). It is much more convenient to generate this file </p>
<p>during  an  export  through  the  GUI  than  writing  this  INI-file  by  hand.  Make  modifications </p>
<p>after it has been generated. </p>
<p>The following is an example of a Ford VBF3.1: </p>
<p><b>[VBFHEADER] </b></p>
<p><b>Description </b></p>
<p>VBF_VERSION=3.1 </p>
<p>VBF version V3.1 (Ford) </p>
<p>SW_PART_TYPE=EXE </p>
<p>One of the allowed part types as string. </p>
<p>SW_CALL_ADDRESS= </p>
<p>Call address. Omit or leave unset if not allowed for a </p>
<p>certain part type. </p>
<p>DATA_FORMAT_ID=00 </p>
<p>The format identifier (e.g. for compressed or encrypted </p>
<p>files. </p>
<p>DATPROC_PARAM </p>
<p>Data processing parameter. Normally empty if no data </p>
<p>processing or just data compression is used. </p>
<p>DATPROC_METHOD </p>
<p>ID of the data processing method (see chapter 3.2.11). </p>
<p>DATPROC_METHOD2 </p>
<p>If you need to chain two data processing operations, the </p>
<p>second operation can be specified with this parameter. </p>
<p>For example, if you want to first compress and then </p>
<p>encrypt data, this second operation need to be used. </p>
<p>DATPROC_PARAM2 </p>
<p>The parameter for the second data processing operation </p>
<p>if necessary. </p>
<p>FRAME_FORMAT=CAN_STANDARD </p>
<p>One of the allowed frame format specifier. </p>
<p>Description=This is a text file </p>
<p>Description field of the VBF (see examples above) </p>
<p>NETWORK=CAN_HS </p>
<p>See example above. </p>
<p>ECU_ADDRESS </p>
<p>The ECU address (see above) </p>
<p>SW_PART_NUMBER </p>
<p> </p>
<p>VS_ADDRESS=0x14000 </p>
<p>Specifies the start address of the validation structure. </p>
<p>SIGNATURE_METHOD=38 </p>
<p>Specifies the data processing method to calculate the </p>
<p>signature. A signature parameter is required if specified. </p>
<p>SIGNATURE_PARAM=private_key.pem </p>
<p>The parameter for the signature generation. This is </p>
<p>typically the private key in PEM format. HIS key format is </p>
<p>also accepted. </p>
<p>PUBLIC_KEY_HASH=abcdef… </p>
<p>This specifies the public key hash. The value is taken as </p>
<p>is and written into the VBF without verification. The value </p>
<h1 style="page-break-before:always; "></h1>
<p>Reference Manual HexView </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 1.12.02 </p>
<p>110 </p>
<p>based on template version 5.1.0 </p>
<p>cannot be generated automatically. </p>
<p>IdTagBegin=0001 </p>
<p>This is a value written to the validation structure. It </p>
<p>specifies the beginning of the VS. </p>
<p>Force32BitFormat=1 </p>
<p>This value is required. All address and length values are </p>
<p>handled as 32-bit for the validation structure. </p>
<p>Table 3-15  </p>
<p>An example for the Ford VBF V3.1 format to generate a signed VBF file. </p>
<h1 style="page-break-before:always; "></h1>
<p>Reference Manual HexView </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 1.12.02 </p>
<p>111 </p>
<p>based on template version 5.1.0 </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Example1 </b></p>
<p>Convert an SBL resp. flashdriver </p>
<p> </p>
<p>HexView.exe fhasdrv.hex /FA /s /e:cmderrors.err /xvbf /P:flashdrv.ini -o flashdrv.vbf </p>
<p>flashdrv.ini-File: </p>
<p>[VBFHEADER] </p>
<p>VBF_VERSION=2.4 </p>
<p>SW_PART_TYPE=SBL </p>
<p>SW_CALL_ADDRESS=0x10000 </p>
<p>DATA_FORMAT_ID=16 </p>
<p>SW_VERSION= </p>
<p>DATPROC_PARAM= </p>
<p>DATPROC_METHOD=21 </p>
<p>FRAME_FORMAT=CAN_STANDARD </p>
<p>DESCRIPTION=abc </p>
<p>NETWORK=CAN_HS </p>
<p>OMIT_ADDRESS=0x12000 </p>
<p>OMIT_LENGTH=0x0A00 </p>
<p>ECU_ADDRESS=740 </p>
<p>SW_PART_NUMBER=3456 </p>
<p>ERASE_LIST_GEN_MODE=2 </p>
<p>VS_ADDRESS=0x14000 </p>
<p> </p>
<p>Output of _page3a.vbf: </p>
<p>vbf_version = 2.4; </p>
<p>header { </p>
<p> </p>
<p>//********************************************************** </p>
<p> </p>
<p>//* </p>
<p> </p>
<p>//*   Vector Informatik GmbH </p>
<p> </p>
<p>//* </p>
<p> </p>
<p>//*   This file was created by Hexview V1.12.00 </p>
<p> </p>
<p>//* </p>
<p> </p>
<p>//********************************************************** </p>
<p> </p>
<p> </p>
<p>description = {&quot;abc&quot; </p>
<p> </p>
<p>              }; </p>
<p> </p>
<p>sw_part_number = &quot;3456&quot;; </p>
<p> </p>
<p>sw_part_type = SBL; </p>
<p> </p>
<p>data_format_identifier = 16; </p>
<p> </p>
<p>network = CAN_HS; </p>
<p> </p>
<p>ecu_address = 740; </p>
<p> </p>
<p>frame_format = CAN_STANDARD; </p>
<p> </p>
<p>omit = { { 0x12000, 0x0A00} </p>
<p> </p>
<p>        }; </p>
<p> </p>
<p>call = 0x10000; </p>
<p> </p>
<p>file_checksum = 0xf752c33f; </p>
<p>}</p>
<p>.</p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Example2 </b></p>
<p>Convert an application file for Ford VBF V3.1. Validation structure is on address 0x14000. </p>
<p> </p>
<p>HexView.exe testsuit.hex /AD2 /AL /s  /p:testsuit.ini /xvbf -o testsuit.vbf </p>
<p>testsuit.ini-File: </p>
<p>[VBFHEADER] </p>
<p>VBF_VERSION=3.1 </p>
<p>SW_PART_TYPE=EXE </p>
<h1 style="page-break-before:always; "></h1>
<p>Reference Manual HexView </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 1.12.02 </p>
<p>112 </p>
<p>based on template version 5.1.0 </p>
<p>SW_CALL_ADDRESS= </p>
<p>DATA_FORMAT_ID=00 </p>
<p>SW_VERSION= </p>
<p>DATPROC_PARAM= </p>
<p>DATPROC_METHOD=0 </p>
<p>FRAME_FORMAT=CAN_STANDARD </p>
<p>DESCRIPTION=abc </p>
<p>NETWORK=CAN_HS </p>
<p>OMIT_ADDRESS=0x12000 </p>
<p>OMIT_LENGTH=0x0A00 </p>
<p>ECU_ADDRESS=740 </p>
<p>SW_PART_NUMBER=3456 </p>
<p>ERASE_LIST_GEN_MODE=2 </p>
<p>VS_ADDRESS=0x14000 </p>
<p>SIGNATURE_METHOD=32 </p>
<p>PUBLIC_KEY_HASH=AABBCCDDEEFF0011223344556677889900112233445566778899AABBC</p>
<p>CDDEEFF </p>
<p>SIGNATURE_PARAM=.\input\private_key.pem </p>
<p>BlockChecksumType=20;Required! </p>
<p>IdTagBegin=0001 </p>
<p>Force32BitFormat=1;required! </p>
<p>ERASE_ADDRESS=0x00009000 </p>
<p>ERASE_LENGTH=0x00001000</p>
<p> </p>
<p> </p>
<p>testsuit.vbf-File: </p>
<p>vbf_version = 3.1; </p>
<p>header { </p>
<p> </p>
<p>//********************************************************** </p>
<p> </p>
<p>//* </p>
<p> </p>
<p>//*   Vector Informatik GmbH </p>
<p> </p>
<p>//* </p>
<p> </p>
<p>//*   This file was created by Hexview V1.12.00 </p>
<p> </p>
<p>//* </p>
<p> </p>
<p>//********************************************************** </p>
<p> </p>
<p>//Description </p>
<p> </p>
<p>description = {&quot;abc&quot; </p>
<p> </p>
<p>              }; </p>
<p> </p>
<p>//Software part number </p>
<p> </p>
<p>sw_part_number = &quot;3456&quot;; </p>
<p> </p>
<p>//Software part type </p>
<p> </p>
<p>sw_part_type = EXE; </p>
<p> </p>
<p>//Format identifier </p>
<p> </p>
<p>data_format_identifier = 00; </p>
<p> </p>
<p>//ecu_address or list </p>
<p> </p>
<p>ecu_address = 740; </p>
<p> </p>
<p>//Format frame </p>
<p> </p>
<p>frame_format = CAN_STANDARD; </p>
<p> </p>
<p>//erase block </p>
<p> </p>
<p>erase = { </p>
<p> </p>
<p>          { 0x00009000, 0x00001000} </p>
<p> </p>
<p>        }; </p>
<p> </p>
<p> </p>
<p>//omit block </p>
<p> </p>
<p>omit = { </p>
<p> </p>
<p>          { 0x12000, 0x0A00} </p>
<p> </p>
<p>       }; </p>
<p> </p>
<p>//Start address of the Validation structure </p>
<p> </p>
<p>verification_structure_address = { 0x14000 }; </p>
<p> </p>
<p>//software signature </p>
<p> </p>
<p>sw_signature =  </p>
<p> </p>
<p>{ </p>
<p> </p>
<p>&quot;726FEBA3A01E479E24419E23D9C1616BB8811F04A1C2BD6ABC5E5CF7F2E0B7</p>
<h1 style="page-break-before:always; "></h1>
<p>Reference Manual HexView </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 1.12.02 </p>
<p>113 </p>
<p>based on template version 5.1.0 </p>
<p>8784FE150B49BBF0B68D94BA6A7CA8CB4180FF69B4142F2D0D960E265743D588A5</p>
<p>5DCE3D75C73B1A0DBF2CF9B596978C916B6F83BDC4F35880FA345E21574A34E04F</p>
<p>161CDF8D4B81F34056BA72C3AB31B9D6459DFB529F2C21D41AB1DE33551FA3E5E6</p>
<p>A31E4CF9750D4EAD2EEF39F334A9FC634F1E426470444F9AB28FE4E98A1EF7E9D7</p>
<p>F69793B3DA238E261CEA12E611A64D4B1767B15D9F6176709918947222F61124CC</p>
<p>C99CE803E66F5EA89F96AE2B3733C75C1F20BC786DF3DD6A2EAADB44F89396F703</p>
<p>EF8F24B756A19ECFD24FD6021FA758524A3E88B2750DE71343AF0B&quot; </p>
<p> </p>
<p>}; </p>
<p> </p>
<p>//Public key hash </p>
<p> </p>
<p>public_key_hash </p>
<p>= </p>
<p>&quot;AABBCCDDEEFF0011223344556677889900112233445566778899AABBCCDDEEFF&quot;</p>
<p>; </p>
<p> </p>
<p>//file checksum </p>
<p> </p>
<p>file_checksum = 0xb5c077c7; </p>
<p>}.</p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>3.3.6 </b></p>
<p><b>Exchange the binary portion of a VBF (/xvbfsubst=&lt;&lt;file&gt;&gt;[;DFI=xx]) </b></p>
<p>It might be necessary to exchange just the binary part of the VBF file. This can be useful if </p>
<p>a VBF file has been created with plain data, including all VBF header information and the </p>
<p>binary part will be compressed or encrypted by an external tool. In this case it would be </p>
<p>necessary to create the VBF file with the VBF header information of the plain data but with </p>
<p>another DFI and the output data of the external (compression) tool. In this case, the input </p>
<p>file should be the VBF with the plain data substituted with the data specified with the option </p>
<p><b>/xvbfsubst=&lt;&lt;compressed-file&gt;&gt;,DFI=xx </b>applied (xx represents a character string and </p>
<p>will immediately replace the data_format_identifier item of the VBF header). Note that you </p>
<p>cannot change any VBF header information, e.g. through an INI file with this export option. </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Example commandline: </b></p>
<p> </p>
<p>Hexview PlainData.vbf –xvbfsubst=compressedData.hex;DFI=0x20 –o </p>
<p>CompressedData.vbf </p>
<p> </p>
<p>Takes the VBF header information from <i>PlainData.vbf</i>, substitutes the format_identifier </p>
<p>there with <i>0x20 </i>and replaces the data contents with the contents of </p>
<p><i>CompressedData.vbf</i>. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>3.3.7 </b></p>
<p><b>Output a GM-specific data file </b></p>
<p>A file used for a flash download within GM contains important information necessary for its </p>
<p>download  at  the  very  beginning.  This  is  the  so-called  GM  file-header.  It  contains  a </p>
<p>description of the download data and also some version information. A detailed description </p>
<p>of this file-header can be found in GMW3110, V1.5, section 11. </p>
<p>Roughly,  the  header  can  be  divided  up  into  two  groups,  the  header  for  the  operational </p>
<p>respectively executable software and the calibration file. The main difference is, that the </p>
<p>operational  software  contains  the  address  information  of  both  the  operational  and  the </p>
<h1 style="page-break-before:always; "></h1>
<p>Reference Manual HexView </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 1.12.02 </p>
<p>114 </p>
<p>based on template version 5.1.0 </p>
<p>calibration </p>
<p>software. </p>
<p>The </p>
<p>calibration </p>
<p>software </p>
<p>therefore </p>
<p>doesn’t </p>
<p>contain </p>
<p>any </p>
<p>address </p>
<p>information, even not about itself. </p>
<p> </p>
<p>The file header can roughly be divided up into two parts, a static part and a dynamic part. </p>
<p>The  static  part  contains  information  that  changes  only  the  version  management  and </p>
<p>contains, e.g. version information and other file descriptions like module-id, DLS-code and </p>
<p>DCID. The information is static in respect to the compile and link process. </p>
<p>The dynamic data part contains the address and length of all sections of a file and also the </p>
<p>total  checksum  over  all  sections.  Thus,  the  dynamic  data  contents  is  changing  by  the </p>
<p>compile and link process and must therefore be adapted after every link process. </p>
<p> </p>
<p>The command line options of HexView are therefore adapted to these two stages and can </p>
<p>roughly  be  divided  up  into two  groups: manipulating  the  dynamic part  within  an  existing </p>
<p>header of the hex-file or to create the complete header information including the static and </p>
<p>dynamic parts, without the existence of any predefined data.  </p>
<p> </p>
<p>If only the dynamic part is inserted, the static part must already be present in the loaded </p>
<p>file. In that case, HexView analyzes the static part and checks if enough placeholder has </p>
<p>been  reserved  to  insert  the  dynamic  part.  To  avoid  the  risk  that  HexView  accidentally </p>
<p>overwrites important software part data, a unique ID must be written at the very beginning </p>
<p>of the header block. This ID has the value 0x11AA.  </p>
<p>If  it’s  commanded  to  HexView  to  create  also  the  static  part,  the  whole  header  will  be </p>
<p>generated. This also implies, that the information of the static part must be given by the </p>
<p>command line options. These options are the /DLS, /SWMI, /DCID and the /MPFH.  </p>
<p>This document does not describe completely the format and meaning of the header. You </p>
<p>must refer to GMW3110 for further details. </p>
<p><b>3.3.7.1 </b></p>
<p><b>Manipulating Checksum and address/Length field within an existing </b></p>
<p><b>header (/XG) </b></p>
<p>The  option  /XG  is  used  to  command  HexView  to  change  the  checksum,  address  and </p>
<p>length information (the dynamic part) within the existing header data fields of the hex-file. It </p>
<p>is  a  prerequisite,  that  the  header  is  at  the  very  beginning  of  a  block  or  a  section.  The </p>
<p>header must contain all static information like Module-ID, SWMI, DLS and HFI. There must </p>
<p>also already be data as a placeholder for the PMA and the checksum. The placeholder for </p>
<p>the  checksum  must  have  the  value  0x11AA,  the  placeholder  data  for  the  address  and </p>
<p>length information can be of any value. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>HexView will overwrite these data during the conversion process. Make sure that no </p>
<p>important data is overwritten. <b>Test the output results carefully!!</b>. </p>
<p><b> </b></p>
<p><b> </b></p>
<p>By  default,  HexView  checks  the  presence  of  the  header  on  the  lowest  address  of  the </p>
<p>block. However, if the header is at the beginning of another block, the address information </p>
<p>of this block can be specified in this command line, separated by the colon. </p>
<h1 style="page-break-before:always; "></h1>
<p>Reference Manual HexView </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 1.12.02 </p>
<p>115 </p>
<p>based on template version 5.1.0 </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Example </b></p>
<p><b>/XG /CS5 test.dat </b></p>
<p>Reads in the file test.dat as Intel-HEX or S-Record file and tries to fill in the header </p>
<p>information into the lowest address. The value 0x11AA must be specified there. </p>
<p>Outputs the data into test.bin (GM-binary format) and test.hex (Intel-HEX). </p>
<p><b>/XG:0x1000 /CS6 </b></p>
<p>HexView searches for the block at address 0x1000. If this is not the first block in the </p>
<p>internal list (e.g. it’s not the lowest address of the block), the block will be moved to the </p>
<p>front. The specified address must be the beginning of a segment or block.  </p>
<p><b>moduleId01.hex /XG /CS6 /MPFH –o myGMfile.bin </b></p>
<p>The hex-file “moduleId01” contains a header with placeholder 0x11aa for the </p>
<p>checksum, SWMI, DLS, the HFI and a NOAR with dummy address/length information </p>
<p>and optional DCID. It also contains values for the additional modules (NOAM-fields). </p>
<p>Hexview will fill the placeholder 0x11AA with the calculated checksum, will adjust the </p>
<p>NOAR and address/length information from the address fields of “moduleId01.hex” and </p>
<p>then copies the NOAM fields to the end of the last address/length information.  </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>The parameter /CSx must be given when manipulating the header to specify the </p>
<p>checksum method for the checksum value. </p>
<p>If the existing header already contains data for the additional modules (NOAM-data), </p>
<p>the option /MPFH can be specified to let Hexview copy the contents of the NOAM field </p>
<p>adjacent to the end of the new address region. Extensive checks are done internally to </p>
<p>avoid overwriting existing data. Do not use the /MPFH option if you don’t use </p>
<p>calibration information within the GM file. </p>
<p><b> </b></p>
<p><b> </b></p>
<p>Besides the presence of the value 0x11AA, the parameter NOAR in the static part must be </p>
<p>equal or greater than the number of sections available in the hex-file. If the NOAR in the </p>
<p>static part is lower, HexView generates an error and does not write the output. </p>
<p>After the NOAR parameter, there must be at least 8*NOAR data bytes within the header, </p>
<p>reserved for the address and length information.  </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>HexView will overwrite these reserved data bytes with the address and length </p>
<p>information of the sections. Also, the value 0x11AA for the checksum will be overwritten </p>
<p>with the result of the checksum calculation value. </p>
<p><b> </b></p>
<p><b> </b></p>
<p>The output file format of HexView is a BIN-file. </p>
<p>If the –o parameter is not given, HexView will use the input filename and will replace the </p>
<p>file extension of the input file with “.bin” to specify the output filename.  </p>
<p>In addition, HexView will create an Intel-HEX file with the extension “.hex”. </p>
<p>If the output filename already contains the extension .hex, HexView will create a Motorola </p>
<p>S-record file with the extension “.s19”. </p>
<h1 style="page-break-before:always; "></h1>
<p>Reference Manual HexView </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 1.12.02 </p>
<p>116 </p>
<p>based on template version 5.1.0 </p>
<p><b>3.3.7.2 </b></p>
<p><b>Creating the GM file header for the operating software (/XGC[:address]) </b></p>
<p>This  option  is  used  to  create  the  header  for  the  operational  software  respectively  the </p>
<p>executable.  </p>
<p>Without any  address  information  in  the parameter,  the  header will  be  added at the  very </p>
<p>beginning of the first section (lowest address of the file). The address information will be </p>
<p>adapted according to the necessary size of the header (the size can vary depending on </p>
<p>the information in the header). If the header doesn’t fit to the lowest address, an error will </p>
<p>be generated and the output file will not be written. </p>
<p>Using the /XGC parameter, the HFI will always be a two byte value. If the parameter /DCID </p>
<p>and /MPFH are given, the corresponding bits in the HFI field will be set and the values </p>
<p>from the parameters will be added. If the parameters /SWMI and /DLS are not given, the </p>
<p>default values will be used. </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Example </b></p>
<p><b>myHexFile.hex /XGC /CS5 /DCID=0x8000 /DLS=AA /SWMI=12345678 </b></p>
<p><b>/MODID=1 /AL /AD4 /MPFH=cal1.hex+cal2.hex –o myGmFile.bin </b></p>
<p>This will create a full header with all options passed through command line. It </p>
<p>will put the header data upfront to the first block data on the lowest address. </p>
<p>The base address of the header will be shifted down to match the header size. </p>
<p>The data will be filled in to the block. The DCID-field will be added and the flag </p>
<p>in the HFI as well. The NOAM-field will be 2 followed either with the placeholder </p>
<p>or the real data of cal1.hex and cal2.hex. If placeholder or real data are used </p>
<p>depends on if HexView can read the contents of the data from cal1.hex and/or </p>
<p>cal2.hex. </p>
<p>Please note, that a GM-binary file cannot be used as an input file of CAL-files, </p>
<p>as this file doesn’t contain address information. </p>
<p> </p>
<p><b>myHexFile.hex /XGC:0x1000 /CS5 /DCID=0x8000 /DLS=AA </b></p>
<p><b>/SWMI=12345678 /MODID=1 /MPFH=cal1.hex+cal2.hex /AL /AD4 –o </b></p>
<p><b>myGmFile.bin </b></p>
<p>This will create the file header at the address 0x1000. The created section will be </p>
<p>located at the very beginning of the data. Thus, the header will be the first data in the </p>
<p>output file, regardless if there are any sections with lower addresses. </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>3.3.7.3 </b></p>
<p><b>Creating the GM file header for the calibration software (/XGCC[:address]) </b></p>
<p>The  option  /XGCC  is  used  to  create  the  header  for  the  calibration  software.  The  major </p>
<p>difference is, that the calibration file does not contain the PMA-field for address information </p>
<p>and the NOAR-field. The corresponding PMA-bitfield is not set in the HFI (typically 0x22). </p>
<p> </p>
<p>The parameters /DCID, /SWMI, /DLS and /CS are also accepted. The /MPFH parameter </p>
<p>must not be added to the command line. </p>
<h1 style="page-break-before:always; "></h1>
<p>Reference Manual HexView </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 1.12.02 </p>
<p>117 </p>
<p>based on template version 5.1.0 </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Example </b></p>
<p><b>myCalHexFile.hex /XGCC /CS5 /DCID=0x8000 /DLS=AA /SWMI=12345678 </b></p>
<p><b>/MODID=2 /FA /AL /AD4  –o myCalFile.bin </b></p>
<p>This will create a full header with all options passed through command line. It </p>
<p>will put the header data upfront to the first block data on the lowest address. </p>
<p>The base address of the header will be shifted down to match the header size. </p>
<p>The data will be filled in to the block. The DCID-field will be added and the flag </p>
<p>in the HFI as well. A NOAM-field is not allowed in CAL-files. Therefore, the </p>
<p>/MPFH option is <b>not allowed </b>to be used.  </p>
<p>Please note, that a GM-binary file cannot be used as an input file of CAL-files, </p>
<p>as this file doesn’t contain address information. However, Hexview will </p>
<p>automatically generate a myCalFile.hex in parallel to the bin-file. Make sure, </p>
<p>that your input file has not the same name as the output file as this will overwrite </p>
<p>your origin. </p>
<p><b>Note</b>: The option /FA should be used for CAL-files, because CALs are always </p>
<p>single-region files! </p>
<p> </p>
<p><b>myHexFile.hex /XGCC:0x1000 /CS5 /DCID=0x8000 /DLS=AA </b></p>
<p><b>/SWMI=12345678 /MODID=2 /FA /AL /AD4 –o myGmFile.bin </b></p>
<p>This will create the file header at the address 0x1000. The created section will be </p>
<p>located at the very beginning of the data. Thus, the header will be the first data in the </p>
<p>output file, regardless if there are any sections with lower addresses. </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>3.3.7.4 </b></p>
<p><b>Creating the GM file header with 1-byte HFI (/XGCS[:address]) </b></p>
<p>For backward compatibility, it is also possible to create the header with one-byte HFI.  </p>
<p>In that case, the parameters /DCID and /MPFH shall not be given as an option. </p>
<p>All other information are in accordance with the other options described above. </p>
<p><b>3.3.7.5 </b></p>
<p><b>Specify the SWMI data (/SWMI=xxxx) </b></p>
<p>The parameter /SWMI is used to specify the value within the SWMI field. The parameter in </p>
<p>the  command  line  option  is  used  to  add  it  to  the  field.  The  parameter  is  treaded  as  a </p>
<p>integer value and added to a 4-byte field in the SWMI-field of the header. The data can be </p>
<p>represented in decimal or in hex by a leading ‘0x’. </p>
<p>If the /SWMI parameter is omitted, HexView will use the default value 0x12345678. </p>
<p>This parameter is only useful in combination with /XGC, /XGCC or /XGCS. </p>
<p><b>3.3.7.6 </b></p>
<p><b>Adding the part number to the header (/PN) </b></p>
<p>In some cases, the part number needs to be added to the GM-header. The part number is </p>
<p>an ASCII representation of the SWMI value. If the option /PN is added in combination with </p>
<p>any /XGC option, the ASCII representation of the part number will be added to the header. </p>
<p>The corresponding bit of the 2</p>
<p>nd</p>
<p> byte of the HFI-field will be set if the option is given. </p>
<p>This parameter is only useful in combination with the option /XGC or /XGCC. </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Reference Manual HexView </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 1.12.02 </p>
<p>118 </p>
<p>based on template version 5.1.0 </p>
<p><b>3.3.7.7 </b></p>
<p><b>Specify the DLS values (/DLS=xx) </b></p>
<p>The  DLS  parameter  is  used  to  specify  the  DLS  field  information  in  the  header.  The </p>
<p>parameter is interpreted as ASCII characters and added to the DLS-field. The number of </p>
<p>characters  in  the  DLS-field  can  either  be  two  or  three  characters.  The  HFI-field  will  be </p>
<p>adapted according to the number of characters given in the parameters. </p>
<p>This parameter is only useful in combination with /XGC, /XGCC or /XGCS. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Example </b></p>
<p>/ <b>DLS=AA </b></p>
<p>The DLS is AA. The HFI field specifies a two-byte DLS field. </p>
<p> </p>
<p><b>/DLS=ABC </b></p>
<p>The DLS is ABC. The HFI field is set to be a three-byte field. </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>3.3.7.8 </b></p>
<p><b>Specify the Module-ID parameter (/MODID=value) </b></p>
<p>The /MODID parameter specifies the module id of the header. The parameter specifies the </p>
<p>number. The parameter can be either a decimal or a hexadecimal value if a ‘0x’ is added </p>
<p>upfront. </p>
<p>This parameter is only useful in combination with /XGC, /XGCC or /XGCS. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Example </b></p>
<p><b>/modid=1 </b></p>
<p>The module-ID is 0001 in the module-id field </p>
<p> </p>
<p><b>/MODID:0x0051 </b></p>
<p>The Module-ID is set to 81</p>
<p>dez</p>
<p> resp. 51</p>
<p>hex</p>
<p>. </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>3.3.7.9 </b></p>
<p><b>Specify the DCID-field (/DCID=value) </b></p>
<p>The /DCID parameter specifies the DCID-value in the GM-header. This option can only be </p>
<p>used for a 2-byte HFI. Thus, it can only combined with the options /XGC or /XGCC (not </p>
<p>with /XGCS or /XG). </p>
<p>The value can either a decimal or a hexadecimal value if it precedes with ‘0x’. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Example </b></p>
<p><b>/XGC /DCID:32238 </b></p>
<p><b>/XGCC /DCID=0x8000 </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>3.3.7.10 </b></p>
<p><b>Specify the MPFH field (/MPFH[=file1+file2+…] </b></p>
<p>The  /MPFH  option  is  added  to  specify  the  MPFH  data.  In  combination  with  /XGC  the </p>
<p>header will be extended to store the NOAM, DCID and address/length information from the </p>
<p>files specified in the options field. The value of NOAM is taken from the number of files </p>
<p>specified in the parameter field. Each file is separated by the ‘+’ sign. </p>
<h1 style="page-break-before:always; "></h1>
<p>Reference Manual HexView </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 1.12.02 </p>
<p>119 </p>
<p>based on template version 5.1.0 </p>
<p>In combination with the /XG or /XGC parameter, HexView will scan the files listed in the </p>
<p>parameter  field.  If  they  could  be  found,  the  address,  length  and  DCID-fields  will  be </p>
<p>extracted and added to the header information.  </p>
<p>Note that the files listed in the MPFH parameter must be single region files. If they contain </p>
<p>multiple sections, an error will be generated and the address/length information will not be </p>
<p>added.  </p>
<p>File format: HexView first tries to read the files as Intel-Hex or Motorola-S-Record files. If </p>
<p>this is not possible, that means, if it results in a zero data container, it will try to read it as a </p>
<p>GM-binary file. </p>
<p> </p>
<p>In  combination  with  the  /XGC  option,  HexView  will  create  sufficient  data  information  to </p>
<p>store the information for the calibration files. </p>
<p>If  this  option  is  added  with  /XG,  Hexview  will  analyse  for  existing  data  of  additional </p>
<p>modules and will copy this field to the end of the address- and length field. </p>
<p><b>3.3.7.11 </b></p>
<p><b>GM header alignment (/GMAD=val, /GMAL[=val]) </b></p>
<p>The  command  line  options  /AL  and  /AD  are  generally  used  to  align  the  data  before </p>
<p>processing. The alignment operation is typically applied to the loaded file and, in respect to </p>
<p>the GM header generation, the data are aligned before the header is generated. However, </p>
<p>it might be necessary to provide align information for the GM header only  and keep the </p>
<p>binary  data  as  is  without  the  alignment.  For  this  use  case,  the  additional  parameters </p>
<p>/GMAD and /GMAL have been introduced. These align values are applied after the header </p>
<p>is generated. Thus, the alignment of the binary data can be separated or even if no /AL or </p>
<p>/AD is provided, the binary data are kept as is. </p>
<p>/GMAD  typically  provides  the  align  value  and  is  used  to  align  address  information.  If </p>
<p>/GMAL is provided without an additional length value, the length will be aligned using the </p>
<p>length parameter specified by /GMAD:len. However, the length alignment value can also </p>
<p>specified  as  a  standalone  parameter  or  even  with  another  parameter.  Thus,  the  length </p>
<p>value for /GMAL is optional. The length value for /GMAL is typically used if no /GMAD is </p>
<p>specified (e.g. when only the header length shall be aligned) or when the length alignment </p>
<p>shall be different from the address alignment. </p>
<p>Note that if /GMAL or /GMAD is not specified, but /AL or /AD is specified, the values from </p>
<p>/AL respectively /AD will be used for the header alignment (for backward compatibility). </p>
<p><b>3.3.7.12 </b></p>
<p><b>Signature version (/sigver=<i>value</i>) </b></p>
<p>With Global Bootloader specification V2.2, GM introduces signature verification within the </p>
<p>Bootloader. The GM-header requires to contain signature information that the Bootloader </p>
<p>will use for signature verification. These values are the signature version, the signature key </p>
<p>ID </p>
<p>and  the </p>
<p>signature </p>
<p>itself.  With </p>
<p>Hexview </p>
<p>V1.08.00, </p>
<p>it </p>
<p>is  possible </p>
<p>to </p>
<p>generate </p>
<p>this </p>
<p>information in the header file. </p>
<p>One essential parameter for hexview is the signature version. This value is placed into the </p>
<p>header at the required position and is passed to Hexview with this option. The value can </p>
<p>either  be  an  integer  or  a  HEX-number.  Example  #1  (integer  value):  /sigver=12345678. </p>
<p>Example #2 (hex value): /sigver=0x12345678. </p>
<p>The signature version is a 4 byte value in the header. </p>
<h1 style="page-break-before:always; "></h1>
<p>Reference Manual HexView </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 1.12.02 </p>
<p>120 </p>
<p>based on template version 5.1.0 </p>
<p> </p>
<p>Note, that the parameter /DP must be used in conjunction with this parameter to instruct </p>
<p>Hexview  to  calculate  the  correct  signature.  Normally,  the  /DP  parameter  outputs  the </p>
<p>signature value into a file. But here with this option, Hexview will place the results into the </p>
<p>corresponding position of the header within the data. </p>
<p>If this option is given, Hexview outputs a concatenated file without the signature. It is the </p>
<p>exact same output, but without the signature itself. So, this file can be given to GM to let </p>
<p>them generate and insert the signature with real keys. </p>
<p><b>3.3.7.13 </b></p>
<p><b>Signature Key ID (/sigkeyid=<i>value</i>) </b></p>
<p>This  option  is  also  required  for  the  signature  header  generation.  It  provides  the  key  ID </p>
<p>information used for the signature calculation. It identifies uniquely the private/public key </p>
<p>combination for the signature. The value can be given in HEX or integer format, similar to </p>
<p>the  sigver  option.  The  value  will  be  placed  as  a  2-byte  value  into  the  corresponding </p>
<p>location of the header. </p>
<p><b>3.3.7.14 </b></p>
<p><b>Generate Routine header (/XGCR[:header-address]) </b></p>
<p>This option is similar to the /XGC, but generates a header suitable for the routines, e.g. </p>
<p>flashdriver, etc. The major difference is, that the start address will not decrease while the </p>
<p>header is placed upfront. Instead, the header is placed at the same start address where </p>
<p>the routines itself are placed to . This is because the Vector bootloader does use the start </p>
<p>address  of  the  header  as  the  start  address  for  the  code  itself  and  will  use  the  header </p>
<p>information only  for internal processes  but will  not  locate  this into  the memory  (typically </p>
<p>RAM). </p>
<p><b>3.3.7.15 </b></p>
<p><b>Generate key exchange header (/XGCK) </b></p>
<p>This  option  is  used  to  generate  a  key  exchange  file.  It  contains  only  the  header  and </p>
<p>signature information. The data after the header contains the new public key information </p>
<p>for proceeding signature values. </p>
<p>Note, that the signature must be built from the previous keys, not the new key! </p>
<p><b>3.3.8 </b></p>
<p><b>Output a VAG specific data file (/XV) </b></p>
<p>This  option  generates  an  SGM-file  that  can  be  used  for  the  VAS-tester.  The  file  is </p>
<p>generated as described in section 2.2.1.9.14.  </p>
<p>The VAG-export also requires parameters from an INI-file as described in section 0.  </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Example </b></p>
<p>HexView testappl.mhx /XV /P:vagparam.ini –o demoappl.sgm </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>3.3.9 </b></p>
<p><b>Output data as Intel-HEX (/XI[:reclinelen[:rectype]]) </b></p>
<p>This option generates the data in the Intel-HEX file format.  </p>
<p>The  output  can  be  either  as  Extended  Segment  or  Extended  Linear  Segment.  Hexview </p>
<p>selects the appropriate format automatically, depending on the highest address of the data </p>
<p>file.  If  you  want  to  force  Hexview  to  use  a  specific  output  file  format,  use  the  rectype </p>
<p>selector. The following selection is possible: </p>
<h1 style="page-break-before:always; "></h1>
<p>Reference Manual HexView </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 1.12.02 </p>
<p>121 </p>
<p>based on template version 5.1.0 </p>
<p><b></b></p>
<p><b> </b></p>
<p>Rectype = 0: Auto selection (same as omitting the parameter) </p>
<p><b></b></p>
<p><b> </b></p>
<p>Rectype = 1: Extended Linear Segment </p>
<p><b></b></p>
<p><b> </b></p>
<p>Rectype = 2: Extended Segment </p>
<p>Also,  the  number  of  data  bytes  in  the  output  line  can  be  specified  using  the  reclinelen </p>
<p>parameter. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Example </b></p>
<p>HexView anyfile.hex /XI:32 –o intelhex.hex </p>
<p>Hexview myhexfile.S19 /s /xi:16:2 –o myihex.hex </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>3.3.10 </b></p>
<p><b>Output data as Motorola S-Record (/XS[:reclinelen[:rectype]]) </b></p>
<p>This option generates the data in the Motorola S-Record format. </p>
<p>The format (S1, S2 or S3) is automatically detected by HexView according to the size of </p>
<p>the highest address. If this address is 16-bit, the S1-record format is used. If it is up to 24-</p>
<p>bit, the S2-record type is used. If it is up to 32 bit long, the S3-record format is used. </p>
<p>However, it could be useful to select the record type, e.g. when S2 or S3 is desired even </p>
<p>though the  highest  address  is below  its  threshold. In that  case,  the  “rectype” parameter </p>
<p>can be selected. Use the following settings: </p>
<p><b></b></p>
<p><b> </b></p>
<p>Rectype = 0: S1-Record </p>
<p><b></b></p>
<p><b> </b></p>
<p>Rectype = 1: S2-Record </p>
<p><b></b></p>
<p><b> </b></p>
<p>Rectype = 2: S3-Record. </p>
<p>Note that Hexview will throw an error if you select a rectype lower than the address ranges </p>
<p>can handle. No data will be generated. “Reclinelen” must be specified when usrecord type </p>
<p>shall be selected. </p>
<p>The number of data bytes per S-Record line can be specified in the reclinelen parameter. </p>
<p>The  parameter  is  separated  by  a  colon.  It  can  be  specified  in  integer  or  hexadecimal </p>
<p>format. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Example </b></p>
<p>HexView intelfile.hex /XS:32 –o srecord.s19 </p>
<p>Hexview myhexfile.S19 /s /xs:16:2 –o mysrecord.s3 </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>3.3.11 </b></p>
<p><b>Outputs to a CCP/XCP kernel file (/XK) </b></p>
<p>This option generates the flash kernel data file according to the file format necessary for </p>
<p>CANape to read the file. This file format specifies a header and the data itself as Intel-HEX </p>
<p>record format. </p>
<p>For detailed description refer to section 2.2.1.9.4. </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Reference Manual HexView </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 1.12.02 </p>
<p>122 </p>
<p>based on template version 5.1.0 </p>
<p><b>3.3.12 </b></p>
<p><b>Output to a GAC binary file (/XGAC, /XGACSWIL) </b></p>
<p>The GAC binary file can be generated in two ways. The standard file format contains a </p>
<p>header information with some container information such as DCIDs, software version, part </p>
<p>numbers, etc. A complete list of supported IDs are listed in the example for the INI-file.  </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Example </b></p>
<p>The following is an example of the INI-file information for the GAC header </p>
<p>[GACHEADERINFO] </p>
<p>DCID_0=0x00 </p>
<p>DCID_1=0x01 </p>
<p>DCID_2=0x00 </p>
<p>SoftwareVersion=&quot;123&quot; </p>
<p>SoftwarePartNumber=&quot;1234567890ABCD&quot; </p>
<p>AppOrCalVersion=&quot;123&quot; </p>
<p>EcuCodeAndSupplierId=&quot;123456789&quot;</p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p>The required information will take the tool from an INI-file. The corresponding format and </p>
<p>item is listed in the example above. </p>
<p>Besides this information, the GAC header also includes the address and length information </p>
<p>and the number of address/length info. Thus, the GAC  binary file header contains three </p>
<p>sections: </p>
<p>•</p>
<p> </p>
<p>The GAC software information </p>
<p>•</p>
<p> </p>
<p>The number of address/length, the address and length itself </p>
<p>•</p>
<p> </p>
<p>The data of the file. </p>
<p>We  distinguish  two  file  formats,  the  GAC  file  with  complete  information  of  all  three </p>
<p>sections,  which  is  typically  for  the  program  and  calibration  files,  and  the  file  for  the </p>
<p>software interlock (SWIL, sometimes also called as the “flash driver”). </p>
<p>The flash driver itself has no GAC software information and consists only of the two parts, </p>
<p>the address/length info and the binary data itself. Note that the SWIL should have just one </p>
<p>region, so it should start with the binary value ‘01’ as the first byte. </p>
<p>The SWIL file can only be generated through the commandline with the option /xgacswil, </p>
<p>whereas the standard GAC file can be generated through the commandline or with “File -&gt; </p>
<p>Export -&gt; GAC Binary File”. For the latter one it is required, that the corresponding INI-file </p>
<p>contains the valid entries (see example in this section). </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Reference Manual HexView </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 1.12.02 </p>
<p>123 </p>
<p>based on template version 5.1.0 </p>
<p><b>4 </b></p>
<p><b>EXPDATPROC </b></p>
<p>HexView provides an open interface for data processing and checksum calculation. The </p>
<p>interface is realized by a DLL, called EXPDATPROC.DLL (EXPorted DATa PROCessing). </p>
<p>This item describes how HexView calls these functions.  </p>
<p><b>4.1 </b></p>
<p><b>Interface function for checksum calculation </b></p>
<p>The checksum calculation is called whenever the /CSn parameter is used in the command </p>
<p>line or when “Edit -&gt;Checksum calculation” is used in the GUI. </p>
<p>The checksum calculation is also called during the export of Fiat-binary, GM-header and </p>
<p>the VAG-export. </p>
<p>The  following  diagram  shows  the  collaboration  of  function  calls  between  HexView  and </p>
<p>Expdatproc.dll. </p>
<p>To run the checksum calculation via the GUI, HexView first reads all available checksum </p>
<p>calculation methods from the DLL. It first reads the number of available methods by calling </p>
<p>the </p>
<p>GetChecksumFunctionCount()</p>
<p>, then reads the corresponding name by an iterate </p>
<p>call to </p>
<p>GetChecksumFunctionName()</p>
<p>. This builds the list box entries in the dialog. </p>
<p> </p>
<p> </p>
<p>Figure 4-1 </p>
<p>Build the list box entries for the GUI </p>
<p>After the method has been selected, HexView runs the calculation in three steps. First, it </p>
<p>initializes the calculation, runs the calculation by passing the data block wise to the DLL </p>
<p>and then concludes the calculation.  </p>
<p>Init and Deinit has the purpose to construct and destruct a context sensitive data section. </p>
<p>This section is passed to the calculation together with the data. </p>
<p>The function </p>
<p>GetChecksumSizeOfResult()</p>
<p> has been introduced to check the length of </p>
<p>the </p>
<p>results </p>
<p>of </p>
<p>the </p>
<p>checksum </p>
<p>calculation.  This </p>
<p>allows </p>
<p>HexView </p>
<p>to </p>
<p>prepare </p>
<p>the </p>
<p>data </p>
<p>container.  It  also  allows  HexView  to  spare  the  address  section  where  the  checksum </p>
<p>calculation shall be placed to. </p>
<p>The </p>
<p>following </p>
<p>diagram </p>
<p>shows </p>
<p>the </p>
<p>message </p>
<p>flow </p>
<p>when </p>
<p>processing </p>
<p>the </p>
<p>checksum </p>
<p>calculation method: </p>
<p><b>sd Build GUI entry</b></p>
<p><b>Hexv iew</b></p>
<p><b>Expdatproc</b></p>
<p>GetChecksumFunctionCount()</p>
<p>GetChecksumFunctionName()</p>
<h1 style="page-break-before:always; "></h1>
<p>Reference Manual HexView </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 1.12.02 </p>
<p>124 </p>
<p>based on template version 5.1.0 </p>
<p>An error code can be passed to HexView during the calculation. HexView asks for the text </p>
<p>description  in  a  separate  function. This  error  text  description  is  then  shown  in  the  error </p>
<p>report.  </p>
<p> </p>
<p> </p>
<p>Figure 4-2 </p>
<p>Function calls when running checksum calculation </p>
<p>The diagram above shows the function interface and the message sequence chart. The </p>
<p>function </p>
<p>DoCalculateChecksum </p>
<p>with  the  parameter </p>
<p>CSumActionDoData</p>
<p>  is  called </p>
<p>several  times.  Typically,  once  per  section.  The  segInData  contains  the  pointer  to  the </p>
<p>section  data,  dataInLength  specifies  the  length  of  the  data,  and  dataInAddress  contains </p>
<p>the base address of the section. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>segInData is a pointer to the internal data buffer of HexView. The function can therefore </p>
<p>operate and destroy the data. Be careful not to write to any location where segInData </p>
<p>or segOutData points to in the DoCalculateChecksum() function. </p>
<p><b> </b></p>
<p><b> </b></p>
<p>After the calculation has been completed, the </p>
<p>DoCalculateChecksum</p>
<p> function is called </p>
<p>the  last  time,  but  with  the  parameter  CSumActionEnd.  The  segOutData  must  contain </p>
<p>pointer  to  the  data  buffer,  that  holds  the  checksum.  The  segOutLength  specifies  the </p>
<p>number of bytes in segOutData. The segOutAddress parameter is not used  and ignored </p>
<p>here. </p>
<p><b>4.2 </b></p>
<p><b>Interface function for data processing </b></p>
<p>The data processing interface is similar to the interface of the checksum calculation. It’s </p>
<p>the </p>
<p>same </p>
<p>way </p>
<p>how </p>
<p>HexView </p>
<p>gets </p>
<p>the </p>
<p>available </p>
<p>methods </p>
<p>by </p>
<p>calling </p>
<p>the </p>
<p>functions </p>
<p>GetDataProcessingFunctionCount()</p>
<p> that returns the number of available methods, </p>
<p><b>sd Run Checksum calculation</b></p>
<p><b>Hexv iew</b></p>
<p><b>Expdatproc</b></p>
<p>GetChecksumSizeOfResult(methodIndex)</p>
<p>InitChecksum(TExportDataInfo)</p>
<p>DoCalculateChecksum(TExportDataInfo,CSumActionBegin)</p>
<p>RepeatPerSection</p>
<p>DoCalculateChecksum(TExportDataInfo,CSumActionDoData)</p>
<p>DoCalculateChecksum(TExportDataInfo,CSumActionEnd)</p>
<h1 style="page-break-before:always; "></h1>
<p>Reference Manual HexView </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 1.12.02 </p>
<p>125 </p>
<p>based on template version 5.1.0 </p>
<p>and then repetitively the function </p>
<p>GetDataProcessingFunctionName()</p>
<p> until one name </p>
<p>per method has been read.  </p>
<p>It </p>
<p>also </p>
<p>runs </p>
<p>first </p>
<p>the </p>
<p>function </p>
<p>InitDataProcessing(TExportDataInfo*)</p>
<p> </p>
<p>before </p>
<p>running the </p>
<p>DoDataProcessing()</p>
<p>. But with the difference, that the DoDataProcessing is </p>
<p>called  only  once.  HexView  does  not  distinguish  between  the  Begin,  DoData  and  End </p>
<p>function,  but  calls  the  DoDataProcessing  once.  But  the  TExportDataInfo  structure  also </p>
<p>contains  the  segInData,  segInLength and  segInAddress  information.  It  also  contains  the </p>
<p>structure </p>
<p>segOutData, </p>
<p>segoutLength </p>
<p>and </p>
<p>segOutAddress. </p>
<p>Before </p>
<p>HexView </p>
<p>calls </p>
<p>DoDataProcessing, it initializes segOutData and segOutLength with the values and pointer </p>
<p>of segInData and segInLength. Thus, if the data remains the same, HexView will use the </p>
<p>same data set.  </p>
<p>However, if the DoDataProcessing() function wants to manipulate the data, it can overwrite </p>
<p>the default output. HexView will then replace the returned data with the new contents. The </p>
<p>memory buffer where segOutBuffer points to will be used instead. The former segInBuffer </p>
<p>will  be  released    If  segOutLength  is  different,  the  segment  length  will  be  adapted.  The </p>
<p>operation is done for every segment or block. </p>
<p>It is also possible to manipulate the data in segInData without restructuring the data buffer </p>
<p>(only possible if the resulting data is not larger than the input data). The manipulation can </p>
<p>operate directly on the segInData buffer which is the internal data buffer of HexView. This </p>
<p>allows  to  run  data  encryption,  decryption,  compression  and  decompression  with  this </p>
<p>method. </p>
<p>Since most of these data processing operation requires a parameter, the TExportDataInfo-</p>
<p>&gt;generalParam contains a pointer to a parameter string. The parameter typically points to </p>
<p>the </p>
<p>data </p>
<p>buffer </p>
<p>from </p>
<p>the </p>
<p>‘parameter’ </p>
<p>field </p>
<p>of </p>
<p>the </p>
<p>dialog </p>
<p>(see </p>
<p>section: </p>
<p>“<i>Run </i></p>
<p><i>Data </i></p>
<p><i>Processing</i>”), or it points to the buffer of the command line if the command line option is </p>
<p>used </p>
<p>(option </p>
<p>‘param’ </p>
<p>in </p>
<p>section </p>
<p>3.2.11: </p>
<p>“<i>Run </i></p>
<p><i>Data </i></p>
<p><i>Processing </i></p>
<p><i>interface </i></p>
<p><i>(/DPn:param[,section,key][;outfilename])</i>”). </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Reference Manual HexView </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 1.12.02 </p>
<p>126 </p>
<p>based on template version 5.1.0 </p>
<p><b>5 </b></p>
<p><b>Glossary and Abbreviations </b></p>
<p><b>5.1 </b></p>
<p><b>Glossary </b></p>
<p><b>Term </b></p>
<p><b>Description </b></p>
<p>HEX-Files </p>
<p>Any file that is stored in Intel-HEX or Motorola S-Record format. </p>
<p><b>&gt; </b></p>
<p>Address Region </p>
<p><b>&gt; </b></p>
<p>PMA </p>
<p><b>&gt; </b></p>
<p>Section  </p>
<p><b>&gt; </b></p>
<p>Block  </p>
<p><b>&gt; </b></p>
<p>Segment </p>
<p>Area of coherent data that can be described by a start address and length </p>
<p>of data. </p>
<p> </p>
<p> </p>
<p><b>5.2 </b></p>
<p><b>Abbreviations </b></p>
<p><b>Abbreviation </b></p>
<p><b>Description </b></p>
<p>PMA </p>
<p>Programmable memory address </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Reference Manual HexView </p>
<p>© 2018 Vector Informatik GmbH </p>
<p>Version 1.12.02 </p>
<p>127 </p>
<p>based on template version 5.1.0 </p>
<p><b>6 </b></p>
<p><b>Contact </b></p>
<p>Visit our website for more information on </p>
<p> </p>
<p><b></b></p>
<p><b> </b></p>
<p>News </p>
<p><b></b></p>
<p><b> </b></p>
<p>Products </p>
<p><b></b></p>
<p><b> </b></p>
<p>Demo software </p>
<p><b></b></p>
<p><b> </b></p>
<p>Support </p>
<p><b></b></p>
<p><b> </b></p>
<p>Training data </p>
<p><b></b></p>
<p><b> </b></p>
<p>Addresses </p>
<p> </p>
<p>www.vector.com<b> </b></p>
<p>Send feedback to:  mailto:fblsupport@vector-informatik.de<b> </b></p>
</body>
</html>
{% endraw %}